import {
  AnimationProvider,
  CartesianProvider,
  ChartsAxesGradients,
  ChartsContinuousGradient,
  DEFAULT_MARGINS,
  DEFAULT_X_AXIS_KEY,
  DEFAULT_Y_AXIS_KEY,
  DrawingContext,
  DrawingProvider,
  HighlightedContext,
  HighlightedProvider,
  InteractionContext,
  InteractionProvider,
  PluginProvider,
  ResizableContainer,
  SeriesProvider,
  Symbol,
  ZAxisContext,
  ZAxisContextProvider,
  animated,
  arc_default,
  area_default,
  blueberryTwilightPalette,
  blueberryTwilightPaletteDark,
  blueberryTwilightPaletteLight,
  cartesianSeriesTypes,
  catmullRom_default,
  cheerfulFiestaPalette,
  cheerfulFiestaPaletteDark,
  cheerfulFiestaPaletteLight,
  color,
  getColor_default,
  getColor_default2,
  getColor_default3,
  getLabel,
  getSVGPoint,
  getScale,
  getStringSize,
  getValueToPositionMapper,
  isBandScale,
  isBandScaleConfig,
  isInfinity,
  isPointScaleConfig,
  line_default,
  linear_default,
  mangoFusionPalette,
  mangoFusionPaletteDark,
  mangoFusionPaletteLight,
  monotoneX,
  monotoneY,
  natural_default,
  stepAfter,
  stepBefore,
  step_default,
  string_default,
  symbolsFill,
  to,
  useBarChartProps,
  useBarSeries,
  useCartesianContext,
  useChartContainerDimensions,
  useChartContainerProps,
  useChartGradient,
  useChartId,
  useColorProcessor,
  useDrawingArea,
  useHighlighted,
  useInteractionItemProps,
  useItemHighlighted,
  useLineChartProps,
  useLineSeries,
  usePieSeries,
  useResponsiveChartContainerProps,
  useScatterChartProps,
  useScatterSeries,
  useSeries,
  useSkipAnimation,
  useSpring,
  useSvgRef,
  useTicks,
  useTransition,
  useXAxis,
  useXColorScale,
  useXScale,
  useYAxis,
  useYColorScale,
  useYScale,
  useZColorScale,
  warnOnce
} from "./chunk-CCSKJERT.js";
import {
  NoSsr_default,
  Typography_default
} from "./chunk-MY5RMQAE.js";
import {
  Popper_default
} from "./chunk-VHMTGXKX.js";
import "./chunk-XNBLTNAJ.js";
import "./chunk-ZXKOEA6Z.js";
import {
  useTheme,
  useThemeProps
} from "./chunk-LSOBBZR7.js";
import {
  shouldForwardProp,
  useRtl
} from "./chunk-JFPL7OI2.js";
import "./chunk-2UH2JP76.js";
import "./chunk-D7ZASVPN.js";
import {
  useEnhancedEffect_default,
  useForkRef,
  useSlotProps_default
} from "./chunk-ZJZYGGLM.js";
import {
  styled_default
} from "./chunk-7XZP2C3M.js";
import {
  composeClasses,
  generateUtilityClass,
  generateUtilityClasses
} from "./chunk-CTEFGNKA.js";
import {
  _extends,
  _objectWithoutPropertiesLoose,
  init_extends
} from "./chunk-FZK2LAQH.js";
import {
  clsx_default
} from "./chunk-VEB3A3D5.js";
import {
  require_prop_types
} from "./chunk-UUPSFRFT.js";
import {
  require_jsx_runtime
} from "./chunk-YKN4QASJ.js";
import {
  require_react
} from "./chunk-BWGHGES3.js";
import {
  __toESM
} from "./chunk-LK32TJAX.js";

// node_modules/@mui/x-charts/models/seriesType/index.js
function isDefaultizedBarSeries(series) {
  return series.type === "bar";
}
function isBarSeries(series) {
  return series.type === "bar";
}

// node_modules/@mui/x-charts/ChartsClipPath/ChartsClipPath.js
init_extends();
var React = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
var import_jsx_runtime = __toESM(require_jsx_runtime());
function ChartsClipPath(props) {
  const {
    id,
    offset: offsetProps
  } = props;
  const {
    left,
    top,
    width,
    height
  } = useDrawingArea();
  const offset = _extends({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, offsetProps);
  return (0, import_jsx_runtime.jsx)("clipPath", {
    id,
    children: (0, import_jsx_runtime.jsx)("rect", {
      x: left - offset.left,
      y: top - offset.top,
      width: width + offset.left + offset.right,
      height: height + offset.top + offset.bottom
    })
  });
}
true ? ChartsClipPath.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  id: import_prop_types.default.string.isRequired,
  offset: import_prop_types.default.shape({
    bottom: import_prop_types.default.number,
    left: import_prop_types.default.number,
    right: import_prop_types.default.number,
    top: import_prop_types.default.number
  })
} : void 0;

// node_modules/@mui/x-charts/ChartsReferenceLine/ChartsReferenceLine.js
init_extends();
var React5 = __toESM(require_react());
var import_prop_types3 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/ChartsReferenceLine/ChartsXReferenceLine.js
init_extends();
var React3 = __toESM(require_react());

// node_modules/@mui/x-charts/ChartsReferenceLine/common.js
init_extends();

// node_modules/@mui/x-charts/ChartsReferenceLine/chartsReferenceLineClasses.js
function getReferenceLineUtilityClass(slot) {
  return generateUtilityClass("MuiChartsReferenceLine", slot);
}
var referenceLineClasses = generateUtilityClasses("MuiChartsReferenceLine", ["root", "vertical", "horizontal", "line", "label"]);

// node_modules/@mui/x-charts/ChartsReferenceLine/common.js
var ReferenceLineRoot = styled_default("g")(({
  theme
}) => ({
  [`& .${referenceLineClasses.line}`]: {
    fill: "none",
    stroke: (theme.vars || theme).palette.text.primary,
    shapeRendering: "crispEdges",
    strokeWidth: 1,
    pointerEvents: "none"
  },
  [`& .${referenceLineClasses.label}`]: _extends({
    fill: (theme.vars || theme).palette.text.primary,
    stroke: "none",
    pointerEvents: "none",
    fontSize: 12
  }, theme.typography.body1)
}));

// node_modules/@mui/x-charts/ChartsText/ChartsText.js
init_extends();
var React2 = __toESM(require_react());
var import_prop_types2 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/internals/getWordsByLines.js
init_extends();
function getWordsByLines({
  style,
  needsComputation,
  text
}) {
  return text.split("\n").map((subText) => _extends({
    text: subText
  }, needsComputation ? getStringSize(subText, style) : {
    width: 0,
    height: 0
  }));
}

// node_modules/@mui/x-charts/ChartsText/ChartsText.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var _excluded = ["x", "y", "style", "text", "ownerState"];
var _excluded2 = ["angle", "textAnchor", "dominantBaseline"];
function ChartsText(props) {
  const {
    x,
    y,
    style: styleProps,
    text
  } = props, textProps = _objectWithoutPropertiesLoose(props, _excluded);
  const _ref = styleProps ?? {}, {
    angle,
    textAnchor,
    dominantBaseline
  } = _ref, style = _objectWithoutPropertiesLoose(_ref, _excluded2);
  const wordsByLines = React2.useMemo(() => getWordsByLines({
    style,
    needsComputation: text.includes("\n"),
    text
  }), [style, text]);
  let startDy;
  switch (dominantBaseline) {
    case "hanging":
      startDy = 0;
      break;
    case "central":
      startDy = (wordsByLines.length - 1) / 2 * -wordsByLines[0].height;
      break;
    default:
      startDy = (wordsByLines.length - 1) * -wordsByLines[0].height;
      break;
  }
  const transforms = [];
  if (angle) {
    transforms.push(`rotate(${angle}, ${x}, ${y})`);
  }
  return (0, import_jsx_runtime2.jsx)("text", _extends({}, textProps, {
    transform: transforms.length > 0 ? transforms.join(" ") : void 0,
    x,
    y,
    textAnchor,
    dominantBaseline,
    style,
    children: wordsByLines.map((line, index) => (0, import_jsx_runtime2.jsx)("tspan", {
      x,
      dy: `${index === 0 ? startDy : wordsByLines[0].height}px`,
      dominantBaseline,
      children: line.text
    }, index))
  }));
}
true ? ChartsText.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Height of a text line (in `em`).
   */
  lineHeight: import_prop_types2.default.number,
  /**
   * If `true`, the line width is computed.
   * @default false
   */
  needsComputation: import_prop_types2.default.bool,
  ownerState: import_prop_types2.default.any,
  /**
   * Style applied to text elements.
   */
  style: import_prop_types2.default.object,
  /**
   * Text displayed.
   */
  text: import_prop_types2.default.string.isRequired
} : void 0;

// node_modules/@mui/x-charts/ChartsReferenceLine/ChartsXReferenceLine.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var getTextParams = ({
  top,
  height,
  spacingY,
  labelAlign = "middle"
}) => {
  switch (labelAlign) {
    case "start":
      return {
        y: top + spacingY,
        style: {
          dominantBaseline: "hanging",
          textAnchor: "start"
        }
      };
    case "end":
      return {
        y: top + height - spacingY,
        style: {
          dominantBaseline: "auto",
          textAnchor: "start"
        }
      };
    default:
      return {
        y: top + height / 2,
        style: {
          dominantBaseline: "central",
          textAnchor: "start"
        }
      };
  }
};
function getXReferenceLineClasses(classes) {
  return composeClasses({
    root: ["root", "vertical"],
    line: ["line"],
    label: ["label"]
  }, getReferenceLineUtilityClass, classes);
}
function ChartsXReferenceLine(props) {
  const {
    x,
    label = "",
    spacing = 5,
    classes: inClasses,
    labelAlign,
    lineStyle,
    labelStyle,
    axisId
  } = props;
  const {
    top,
    height
  } = useDrawingArea();
  const xAxisScale = useXScale(axisId);
  const xPosition = xAxisScale(x);
  if (xPosition === void 0) {
    if (true) {
      warnOnce(`MUI X: the value ${x} does not exist in the data of x axis with id ${axisId}.`, "error");
    }
    return null;
  }
  const d = `M ${xPosition} ${top} l 0 ${height}`;
  const classes = getXReferenceLineClasses(inClasses);
  const spacingX = typeof spacing === "object" ? spacing.x ?? 0 : spacing;
  const spacingY = typeof spacing === "object" ? spacing.y ?? 0 : spacing;
  const textParams = _extends({
    x: xPosition + spacingX,
    text: label,
    fontSize: 12
  }, getTextParams({
    top,
    height,
    spacingY,
    labelAlign
  }), {
    className: classes.label
  });
  return (0, import_jsx_runtime3.jsxs)(ReferenceLineRoot, {
    className: classes.root,
    children: [(0, import_jsx_runtime3.jsx)("path", {
      d,
      className: classes.line,
      style: lineStyle
    }), (0, import_jsx_runtime3.jsx)(ChartsText, _extends({}, textParams, {
      style: _extends({}, textParams.style, labelStyle)
    }))]
  });
}

// node_modules/@mui/x-charts/ChartsReferenceLine/ChartsYReferenceLine.js
init_extends();
var React4 = __toESM(require_react());
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var getTextParams2 = ({
  left,
  width,
  spacingX,
  labelAlign = "middle"
}) => {
  switch (labelAlign) {
    case "start":
      return {
        x: left + spacingX,
        style: {
          dominantBaseline: "auto",
          textAnchor: "start"
        }
      };
    case "end":
      return {
        x: left + width - spacingX,
        style: {
          dominantBaseline: "auto",
          textAnchor: "end"
        }
      };
    default:
      return {
        x: left + width / 2,
        style: {
          dominantBaseline: "auto",
          textAnchor: "middle"
        }
      };
  }
};
function getYReferenceLineClasses(classes) {
  return composeClasses({
    root: ["root", "horizontal"],
    line: ["line"],
    label: ["label"]
  }, getReferenceLineUtilityClass, classes);
}
function ChartsYReferenceLine(props) {
  const {
    y,
    label = "",
    spacing = 5,
    classes: inClasses,
    labelAlign,
    lineStyle,
    labelStyle,
    axisId
  } = props;
  const {
    left,
    width
  } = useDrawingArea();
  const yAxisScale = useYScale(axisId);
  const yPosition = yAxisScale(y);
  if (yPosition === void 0) {
    if (true) {
      warnOnce(`MUI X: the value ${y} does not exist in the data of y axis with id ${axisId}.`, "error");
    }
    return null;
  }
  const d = `M ${left} ${yPosition} l ${width} 0`;
  const classes = getYReferenceLineClasses(inClasses);
  const spacingX = typeof spacing === "object" ? spacing.x ?? 0 : spacing;
  const spacingY = typeof spacing === "object" ? spacing.y ?? 0 : spacing;
  const textParams = _extends({
    y: yPosition - spacingY,
    text: label,
    fontSize: 12
  }, getTextParams2({
    left,
    width,
    spacingX,
    labelAlign
  }), {
    className: classes.label
  });
  return (0, import_jsx_runtime4.jsxs)(ReferenceLineRoot, {
    className: classes.root,
    children: [(0, import_jsx_runtime4.jsx)("path", {
      d,
      className: classes.line,
      style: lineStyle
    }), (0, import_jsx_runtime4.jsx)(ChartsText, _extends({}, textParams, {
      style: _extends({}, textParams.style, labelStyle)
    }))]
  });
}

// node_modules/@mui/x-charts/ChartsReferenceLine/ChartsReferenceLine.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
function ChartsReferenceLine(props) {
  const {
    x,
    y
  } = props;
  if (x !== void 0 && y !== void 0) {
    throw new Error("MUI X: The ChartsReferenceLine cannot have both `x` and `y` props set.");
  }
  if (x === void 0 && y === void 0) {
    throw new Error("MUI X: The ChartsReferenceLine should have a value in `x` or `y` prop.");
  }
  if (x !== void 0) {
    return (0, import_jsx_runtime5.jsx)(ChartsXReferenceLine, _extends({}, props));
  }
  return (0, import_jsx_runtime5.jsx)(ChartsYReferenceLine, _extends({}, props));
}
true ? ChartsReferenceLine.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The id of the axis used for the reference value.
   * @default The `id` of the first defined axis.
   */
  axisId: import_prop_types3.default.oneOfType([import_prop_types3.default.number, import_prop_types3.default.string]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types3.default.object,
  /**
   * The label to display along the reference line.
   */
  label: import_prop_types3.default.string,
  /**
   * The alignment if the label is in the chart drawing area.
   * @default 'middle'
   */
  labelAlign: import_prop_types3.default.oneOf(["end", "middle", "start"]),
  /**
   * The style applied to the label.
   */
  labelStyle: import_prop_types3.default.object,
  /**
   * The style applied to the line.
   */
  lineStyle: import_prop_types3.default.object,
  /**
   * Additional space around the label in px.
   * Can be a number or an object `{ x, y }` to distinguish space with the reference line and space with axes.
   * @default 5
   */
  spacing: import_prop_types3.default.oneOfType([import_prop_types3.default.number, import_prop_types3.default.shape({
    x: import_prop_types3.default.number,
    y: import_prop_types3.default.number
  })]),
  /**
   * The x value associated with the reference line.
   * If defined the reference line will be vertical.
   */
  x: import_prop_types3.default.oneOfType([import_prop_types3.default.instanceOf(Date), import_prop_types3.default.number, import_prop_types3.default.string]),
  /**
   * The y value associated with the reference line.
   * If defined the reference line will be horizontal.
   */
  y: import_prop_types3.default.oneOfType([import_prop_types3.default.instanceOf(Date), import_prop_types3.default.number, import_prop_types3.default.string])
} : void 0;

// node_modules/@mui/x-charts/ChartsAxis/ChartsAxis.js
init_extends();
var React9 = __toESM(require_react());
var import_prop_types6 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/ChartsXAxis/ChartsXAxis.js
init_extends();
var React7 = __toESM(require_react());
var import_prop_types4 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/ChartsAxis/axisClasses.js
function getAxisUtilityClass(slot) {
  return generateUtilityClass("MuiChartsAxis", slot);
}
var axisClasses = generateUtilityClasses("MuiChartsAxis", ["root", "line", "tickContainer", "tick", "tickLabel", "label", "directionX", "directionY", "top", "bottom", "left", "right"]);

// node_modules/@mui/x-charts/internals/components/AxisSharedComponents.js
init_extends();
var AxisRoot = styled_default("g", {
  name: "MuiChartsAxis",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})(({
  theme
}) => ({
  [`& .${axisClasses.tickLabel}`]: _extends({}, theme.typography.caption, {
    fill: (theme.vars || theme).palette.text.primary
  }),
  [`& .${axisClasses.label}`]: _extends({}, theme.typography.body1, {
    fill: (theme.vars || theme).palette.text.primary
  }),
  [`& .${axisClasses.line}`]: {
    stroke: (theme.vars || theme).palette.text.primary,
    shapeRendering: "crispEdges",
    strokeWidth: 1
  },
  [`& .${axisClasses.tick}`]: {
    stroke: (theme.vars || theme).palette.text.primary,
    shapeRendering: "crispEdges"
  }
}));

// node_modules/@mui/x-charts/internals/geometry.js
var ANGLE_APPROX = 5;
function getMinXTranslation(width, height, angle = 0) {
  if (true) {
    if (angle > 90 && angle < -90) {
      warnOnce([`MUI X: It seems you applied an angle larger than 90° or smaller than -90° to an axis text.`, `This could cause some text overlapping.`, `If you encounter a use case where it's needed, please open an issue.`]);
    }
  }
  const standardAngle = Math.min(Math.abs(angle) % 180, Math.abs(Math.abs(angle) % 180 - 180) % 180);
  if (standardAngle < ANGLE_APPROX) {
    return width;
  }
  if (standardAngle > 90 - ANGLE_APPROX) {
    return height;
  }
  const radAngle = standardAngle * Math.PI / 180;
  const angleSwich = Math.atan2(height, width);
  if (radAngle < angleSwich) {
    return width / Math.cos(radAngle);
  }
  return height / Math.sin(radAngle);
}

// node_modules/@mui/x-charts/hooks/useMounted.js
var React6 = __toESM(require_react());
function useMounted(defer = false) {
  const [mountedState, setMountedState] = React6.useState(false);
  useEnhancedEffect_default(() => {
    if (!defer) {
      setMountedState(true);
    }
  }, [defer]);
  React6.useEffect(() => {
    if (defer) {
      setMountedState(true);
    }
  }, [defer]);
  return mountedState;
}

// node_modules/@mui/x-charts/ChartsXAxis/ChartsXAxis.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var _excluded3 = ["scale", "tickNumber", "reverse"];
var useUtilityClasses = (ownerState) => {
  const {
    classes,
    position
  } = ownerState;
  const slots = {
    root: ["root", "directionX", position],
    line: ["line"],
    tickContainer: ["tickContainer"],
    tick: ["tick"],
    tickLabel: ["tickLabel"],
    label: ["label"]
  };
  return composeClasses(slots, getAxisUtilityClass, classes);
};
function addLabelDimension(xTicks, {
  tickLabelStyle: style,
  tickLabelInterval,
  reverse,
  isMounted
}) {
  const withDimension = xTicks.map((tick) => {
    if (!isMounted || tick.formattedValue === void 0) {
      return _extends({}, tick, {
        width: 0,
        height: 0
      });
    }
    const tickSizes = getWordsByLines({
      style,
      needsComputation: true,
      text: tick.formattedValue
    });
    return _extends({}, tick, {
      width: Math.max(...tickSizes.map((size) => size.width)),
      height: Math.max(tickSizes.length * tickSizes[0].height)
    });
  });
  if (typeof tickLabelInterval === "function") {
    return withDimension.map((item, index) => _extends({}, item, {
      skipLabel: !tickLabelInterval(item.value, index)
    }));
  }
  let currentTextLimit = 0;
  let previousTextLimit = 0;
  const direction = reverse ? -1 : 1;
  return withDimension.map((item, labelIndex) => {
    const {
      width,
      offset,
      labelOffset,
      height
    } = item;
    const distance = getMinXTranslation(width, height, style == null ? void 0 : style.angle);
    const textPosition = offset + labelOffset;
    const gapRatio = 1.2;
    currentTextLimit = textPosition - direction * (gapRatio * distance) / 2;
    if (labelIndex > 0 && direction * currentTextLimit < direction * previousTextLimit) {
      return _extends({}, item, {
        skipLabel: true
      });
    }
    previousTextLimit = textPosition + direction * (gapRatio * distance) / 2;
    return item;
  });
}
var XAxisRoot = styled_default(AxisRoot, {
  name: "MuiChartsXAxis",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({});
var defaultProps = {
  position: "bottom",
  disableLine: false,
  disableTicks: false,
  tickSize: 6
};
function ChartsXAxis(inProps) {
  const {
    xAxisIds,
    xAxis
  } = useCartesianContext();
  const _xAxis = xAxis[inProps.axisId ?? xAxisIds[0]], {
    scale: xScale,
    tickNumber,
    reverse
  } = _xAxis, settings = _objectWithoutPropertiesLoose(_xAxis, _excluded3);
  const isMounted = useMounted();
  const themedProps = useThemeProps({
    props: _extends({}, settings, inProps),
    name: "MuiChartsXAxis"
  });
  const defaultizedProps = _extends({}, defaultProps, themedProps);
  const {
    position,
    disableLine,
    disableTicks,
    tickLabelStyle,
    label,
    labelStyle,
    tickFontSize,
    labelFontSize,
    tickSize: tickSizeProp,
    valueFormatter,
    slots,
    slotProps,
    tickInterval,
    tickLabelInterval,
    tickPlacement,
    tickLabelPlacement,
    sx
  } = defaultizedProps;
  const theme = useTheme();
  const classes = useUtilityClasses(_extends({}, defaultizedProps, {
    theme
  }));
  const {
    left,
    top,
    width,
    height,
    isPointInside
  } = useDrawingArea();
  const tickSize = disableTicks ? 4 : tickSizeProp;
  const positionSign = position === "bottom" ? 1 : -1;
  const Line = (slots == null ? void 0 : slots.axisLine) ?? "line";
  const Tick = (slots == null ? void 0 : slots.axisTick) ?? "line";
  const TickLabel = (slots == null ? void 0 : slots.axisTickLabel) ?? ChartsText;
  const Label = (slots == null ? void 0 : slots.axisLabel) ?? ChartsText;
  const axisTickLabelProps = useSlotProps_default({
    elementType: TickLabel,
    externalSlotProps: slotProps == null ? void 0 : slotProps.axisTickLabel,
    additionalProps: {
      style: _extends({
        textAnchor: "middle",
        dominantBaseline: position === "bottom" ? "hanging" : "auto",
        fontSize: tickFontSize ?? 12
      }, tickLabelStyle)
    },
    className: classes.tickLabel,
    ownerState: {}
  });
  const xTicks = useTicks({
    scale: xScale,
    tickNumber,
    valueFormatter,
    tickInterval,
    tickPlacement,
    tickLabelPlacement
  });
  const xTicksWithDimension = addLabelDimension(xTicks, {
    tickLabelStyle: axisTickLabelProps.style,
    tickLabelInterval,
    reverse,
    isMounted
  });
  const labelRefPoint = {
    x: left + width / 2,
    y: positionSign * (tickSize + 22)
  };
  const axisLabelProps = useSlotProps_default({
    elementType: Label,
    externalSlotProps: slotProps == null ? void 0 : slotProps.axisLabel,
    additionalProps: {
      style: _extends({
        fontSize: labelFontSize ?? 14,
        textAnchor: "middle",
        dominantBaseline: position === "bottom" ? "hanging" : "auto"
      }, labelStyle)
    },
    ownerState: {}
  });
  const domain = xScale.domain();
  const ordinalAxis = isBandScale(xScale);
  if (ordinalAxis && domain.length === 0 || !ordinalAxis && domain.some(isInfinity)) {
    return null;
  }
  return (0, import_jsx_runtime6.jsxs)(XAxisRoot, {
    transform: `translate(0, ${position === "bottom" ? top + height : top})`,
    className: classes.root,
    sx,
    children: [!disableLine && (0, import_jsx_runtime6.jsx)(Line, _extends({
      x1: left,
      x2: left + width,
      className: classes.line
    }, slotProps == null ? void 0 : slotProps.axisLine)), xTicksWithDimension.map(({
      formattedValue,
      offset,
      labelOffset,
      skipLabel
    }, index) => {
      const xTickLabel = labelOffset ?? 0;
      const yTickLabel = positionSign * (tickSize + 3);
      const showTick = isPointInside({
        x: offset,
        y: -1
      }, {
        direction: "x"
      });
      const showTickLabel = isPointInside({
        x: offset + xTickLabel,
        y: -1
      }, {
        direction: "x"
      });
      return (0, import_jsx_runtime6.jsxs)("g", {
        transform: `translate(${offset}, 0)`,
        className: classes.tickContainer,
        children: [!disableTicks && showTick && (0, import_jsx_runtime6.jsx)(Tick, _extends({
          y2: positionSign * tickSize,
          className: classes.tick
        }, slotProps == null ? void 0 : slotProps.axisTick)), formattedValue !== void 0 && !skipLabel && showTickLabel && (0, import_jsx_runtime6.jsx)(TickLabel, _extends({
          x: xTickLabel,
          y: yTickLabel
        }, axisTickLabelProps, {
          text: formattedValue.toString()
        }))]
      }, index);
    }), label && (0, import_jsx_runtime6.jsx)("g", {
      className: classes.label,
      children: (0, import_jsx_runtime6.jsx)(Label, _extends({}, labelRefPoint, axisLabelProps, {
        text: label
      }))
    })]
  });
}
true ? ChartsXAxis.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The id of the axis to render.
   * If undefined, it will be the first defined axis.
   */
  axisId: import_prop_types4.default.oneOfType([import_prop_types4.default.number, import_prop_types4.default.string]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types4.default.object,
  /**
   * If true, the axis line is disabled.
   * @default false
   */
  disableLine: import_prop_types4.default.bool,
  /**
   * If true, the ticks are disabled.
   * @default false
   */
  disableTicks: import_prop_types4.default.bool,
  /**
   * The fill color of the axis text.
   * @default 'currentColor'
   */
  fill: import_prop_types4.default.string,
  /**
   * The label of the axis.
   */
  label: import_prop_types4.default.string,
  /**
   * The font size of the axis label.
   * @default 14
   * @deprecated Consider using `labelStyle.fontSize` instead.
   */
  labelFontSize: import_prop_types4.default.number,
  /**
   * The style applied to the axis label.
   */
  labelStyle: import_prop_types4.default.object,
  /**
   * Position of the axis.
   */
  position: import_prop_types4.default.oneOf(["bottom", "top"]),
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types4.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types4.default.object,
  /**
   * The stroke color of the axis line.
   * @default 'currentColor'
   */
  stroke: import_prop_types4.default.string,
  sx: import_prop_types4.default.oneOfType([import_prop_types4.default.arrayOf(import_prop_types4.default.oneOfType([import_prop_types4.default.func, import_prop_types4.default.object, import_prop_types4.default.bool])), import_prop_types4.default.func, import_prop_types4.default.object]),
  /**
   * The font size of the axis ticks text.
   * @default 12
   * @deprecated Consider using `tickLabelStyle.fontSize` instead.
   */
  tickFontSize: import_prop_types4.default.number,
  /**
   * Defines which ticks are displayed.
   * Its value can be:
   * - 'auto' In such case the ticks are computed based on axis scale and other parameters.
   * - a filtering function of the form `(value, index) => boolean` which is available only if the axis has "point" scale.
   * - an array containing the values where ticks should be displayed.
   * @see See {@link https://mui.com/x/react-charts/axis/#fixed-tick-positions}
   * @default 'auto'
   */
  tickInterval: import_prop_types4.default.oneOfType([import_prop_types4.default.oneOf(["auto"]), import_prop_types4.default.array, import_prop_types4.default.func]),
  /**
   * Defines which ticks get its label displayed. Its value can be:
   * - 'auto' In such case, labels are displayed if they do not overlap with the previous one.
   * - a filtering function of the form (value, index) => boolean. Warning: the index is tick index, not data ones.
   * @default 'auto'
   */
  tickLabelInterval: import_prop_types4.default.oneOfType([import_prop_types4.default.oneOf(["auto"]), import_prop_types4.default.func]),
  /**
   * The placement of ticks label. Can be the middle of the band, or the tick position.
   * Only used if scale is 'band'.
   * @default 'middle'
   */
  tickLabelPlacement: import_prop_types4.default.oneOf(["middle", "tick"]),
  /**
   * The style applied to ticks text.
   */
  tickLabelStyle: import_prop_types4.default.object,
  /**
   * Maximal step between two ticks.
   * When using time data, the value is assumed to be in ms.
   * Not supported by categorical axis (band, points).
   */
  tickMaxStep: import_prop_types4.default.number,
  /**
   * Minimal step between two ticks.
   * When using time data, the value is assumed to be in ms.
   * Not supported by categorical axis (band, points).
   */
  tickMinStep: import_prop_types4.default.number,
  /**
   * The number of ticks. This number is not guaranteed.
   * Not supported by categorical axis (band, points).
   */
  tickNumber: import_prop_types4.default.number,
  /**
   * The placement of ticks in regard to the band interval.
   * Only used if scale is 'band'.
   * @default 'extremities'
   */
  tickPlacement: import_prop_types4.default.oneOf(["end", "extremities", "middle", "start"]),
  /**
   * The size of the ticks.
   * @default 6
   */
  tickSize: import_prop_types4.default.number
} : void 0;

// node_modules/@mui/x-charts/ChartsYAxis/ChartsYAxis.js
init_extends();
var React8 = __toESM(require_react());
var import_prop_types5 = __toESM(require_prop_types());
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var _excluded4 = ["scale", "tickNumber"];
var useUtilityClasses2 = (ownerState) => {
  const {
    classes,
    position
  } = ownerState;
  const slots = {
    root: ["root", "directionY", position],
    line: ["line"],
    tickContainer: ["tickContainer"],
    tick: ["tick"],
    tickLabel: ["tickLabel"],
    label: ["label"]
  };
  return composeClasses(slots, getAxisUtilityClass, classes);
};
var YAxisRoot = styled_default(AxisRoot, {
  name: "MuiChartsYAxis",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({});
var defaultProps2 = {
  position: "left",
  disableLine: false,
  disableTicks: false,
  tickFontSize: 12,
  labelFontSize: 14,
  tickSize: 6
};
function ChartsYAxis(inProps) {
  const {
    yAxisIds,
    yAxis
  } = useCartesianContext();
  const _yAxis = yAxis[inProps.axisId ?? yAxisIds[0]], {
    scale: yScale,
    tickNumber
  } = _yAxis, settings = _objectWithoutPropertiesLoose(_yAxis, _excluded4);
  const themedProps = useThemeProps({
    props: _extends({}, settings, inProps),
    name: "MuiChartsYAxis"
  });
  const defaultizedProps = _extends({}, defaultProps2, themedProps);
  const {
    position,
    disableLine,
    disableTicks,
    tickFontSize,
    label,
    labelFontSize,
    labelStyle,
    tickLabelStyle,
    tickSize: tickSizeProp,
    valueFormatter,
    slots,
    slotProps,
    tickPlacement,
    tickLabelPlacement,
    tickInterval,
    tickLabelInterval,
    sx
  } = defaultizedProps;
  const theme = useTheme();
  const isRtl = useRtl();
  const classes = useUtilityClasses2(_extends({}, defaultizedProps, {
    theme
  }));
  const {
    left,
    top,
    width,
    height,
    isPointInside
  } = useDrawingArea();
  const tickSize = disableTicks ? 4 : tickSizeProp;
  const yTicks = useTicks({
    scale: yScale,
    tickNumber,
    valueFormatter,
    tickPlacement,
    tickLabelPlacement,
    tickInterval
  });
  const positionSign = position === "right" ? 1 : -1;
  const labelRefPoint = {
    x: positionSign * (tickFontSize + tickSize + 10),
    y: top + height / 2
  };
  const Line = (slots == null ? void 0 : slots.axisLine) ?? "line";
  const Tick = (slots == null ? void 0 : slots.axisTick) ?? "line";
  const TickLabel = (slots == null ? void 0 : slots.axisTickLabel) ?? ChartsText;
  const Label = (slots == null ? void 0 : slots.axisLabel) ?? ChartsText;
  const revertAnchor = !isRtl && position === "right" || isRtl && position !== "right";
  const axisTickLabelProps = useSlotProps_default({
    elementType: TickLabel,
    externalSlotProps: slotProps == null ? void 0 : slotProps.axisTickLabel,
    additionalProps: {
      style: _extends({
        fontSize: tickFontSize,
        textAnchor: revertAnchor ? "start" : "end",
        dominantBaseline: "central"
      }, tickLabelStyle)
    },
    className: classes.tickLabel,
    ownerState: {}
  });
  const axisLabelProps = useSlotProps_default({
    elementType: Label,
    externalSlotProps: slotProps == null ? void 0 : slotProps.axisLabel,
    additionalProps: {
      style: _extends({
        fontSize: labelFontSize,
        angle: positionSign * 90,
        textAnchor: "middle",
        dominantBaseline: "auto"
      }, labelStyle)
    },
    ownerState: {}
  });
  const lineSlotProps = useSlotProps_default({
    elementType: Line,
    externalSlotProps: slotProps == null ? void 0 : slotProps.axisLine,
    additionalProps: {
      strokeLinecap: "square"
    },
    ownerState: {}
  });
  const domain = yScale.domain();
  const ordinalAxis = isBandScale(yScale);
  if (ordinalAxis && domain.length === 0 || !ordinalAxis && domain.some(isInfinity)) {
    return null;
  }
  return (0, import_jsx_runtime7.jsxs)(YAxisRoot, {
    transform: `translate(${position === "right" ? left + width : left}, 0)`,
    className: classes.root,
    sx,
    children: [!disableLine && (0, import_jsx_runtime7.jsx)(Line, _extends({
      y1: top,
      y2: top + height,
      className: classes.line
    }, lineSlotProps)), yTicks.map(({
      formattedValue,
      offset,
      labelOffset,
      value
    }, index) => {
      const xTickLabel = positionSign * (tickSize + 2);
      const yTickLabel = labelOffset;
      const skipLabel = typeof tickLabelInterval === "function" && !(tickLabelInterval == null ? void 0 : tickLabelInterval(value, index));
      const showLabel = isPointInside({
        x: -1,
        y: offset
      }, {
        direction: "y"
      });
      if (!showLabel) {
        return null;
      }
      return (0, import_jsx_runtime7.jsxs)("g", {
        transform: `translate(0, ${offset})`,
        className: classes.tickContainer,
        children: [!disableTicks && (0, import_jsx_runtime7.jsx)(Tick, _extends({
          x2: positionSign * tickSize,
          className: classes.tick
        }, slotProps == null ? void 0 : slotProps.axisTick)), formattedValue !== void 0 && !skipLabel && (0, import_jsx_runtime7.jsx)(TickLabel, _extends({
          x: xTickLabel,
          y: yTickLabel,
          text: formattedValue.toString()
        }, axisTickLabelProps))]
      }, index);
    }), label && (0, import_jsx_runtime7.jsx)("g", {
      className: classes.label,
      children: (0, import_jsx_runtime7.jsx)(Label, _extends({}, labelRefPoint, axisLabelProps, {
        text: label
      }))
    })]
  });
}
true ? ChartsYAxis.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The id of the axis to render.
   * If undefined, it will be the first defined axis.
   */
  axisId: import_prop_types5.default.oneOfType([import_prop_types5.default.number, import_prop_types5.default.string]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types5.default.object,
  /**
   * If true, the axis line is disabled.
   * @default false
   */
  disableLine: import_prop_types5.default.bool,
  /**
   * If true, the ticks are disabled.
   * @default false
   */
  disableTicks: import_prop_types5.default.bool,
  /**
   * The fill color of the axis text.
   * @default 'currentColor'
   */
  fill: import_prop_types5.default.string,
  /**
   * The label of the axis.
   */
  label: import_prop_types5.default.string,
  /**
   * The font size of the axis label.
   * @default 14
   * @deprecated Consider using `labelStyle.fontSize` instead.
   */
  labelFontSize: import_prop_types5.default.number,
  /**
   * The style applied to the axis label.
   */
  labelStyle: import_prop_types5.default.object,
  /**
   * Position of the axis.
   */
  position: import_prop_types5.default.oneOf(["left", "right"]),
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types5.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types5.default.object,
  /**
   * The stroke color of the axis line.
   * @default 'currentColor'
   */
  stroke: import_prop_types5.default.string,
  sx: import_prop_types5.default.oneOfType([import_prop_types5.default.arrayOf(import_prop_types5.default.oneOfType([import_prop_types5.default.func, import_prop_types5.default.object, import_prop_types5.default.bool])), import_prop_types5.default.func, import_prop_types5.default.object]),
  /**
   * The font size of the axis ticks text.
   * @default 12
   * @deprecated Consider using `tickLabelStyle.fontSize` instead.
   */
  tickFontSize: import_prop_types5.default.number,
  /**
   * Defines which ticks are displayed.
   * Its value can be:
   * - 'auto' In such case the ticks are computed based on axis scale and other parameters.
   * - a filtering function of the form `(value, index) => boolean` which is available only if the axis has "point" scale.
   * - an array containing the values where ticks should be displayed.
   * @see See {@link https://mui.com/x/react-charts/axis/#fixed-tick-positions}
   * @default 'auto'
   */
  tickInterval: import_prop_types5.default.oneOfType([import_prop_types5.default.oneOf(["auto"]), import_prop_types5.default.array, import_prop_types5.default.func]),
  /**
   * Defines which ticks get its label displayed. Its value can be:
   * - 'auto' In such case, labels are displayed if they do not overlap with the previous one.
   * - a filtering function of the form (value, index) => boolean. Warning: the index is tick index, not data ones.
   * @default 'auto'
   */
  tickLabelInterval: import_prop_types5.default.oneOfType([import_prop_types5.default.oneOf(["auto"]), import_prop_types5.default.func]),
  /**
   * The placement of ticks label. Can be the middle of the band, or the tick position.
   * Only used if scale is 'band'.
   * @default 'middle'
   */
  tickLabelPlacement: import_prop_types5.default.oneOf(["middle", "tick"]),
  /**
   * The style applied to ticks text.
   */
  tickLabelStyle: import_prop_types5.default.object,
  /**
   * Maximal step between two ticks.
   * When using time data, the value is assumed to be in ms.
   * Not supported by categorical axis (band, points).
   */
  tickMaxStep: import_prop_types5.default.number,
  /**
   * Minimal step between two ticks.
   * When using time data, the value is assumed to be in ms.
   * Not supported by categorical axis (band, points).
   */
  tickMinStep: import_prop_types5.default.number,
  /**
   * The number of ticks. This number is not guaranteed.
   * Not supported by categorical axis (band, points).
   */
  tickNumber: import_prop_types5.default.number,
  /**
   * The placement of ticks in regard to the band interval.
   * Only used if scale is 'band'.
   * @default 'extremities'
   */
  tickPlacement: import_prop_types5.default.oneOf(["end", "extremities", "middle", "start"]),
  /**
   * The size of the ticks.
   * @default 6
   */
  tickSize: import_prop_types5.default.number
} : void 0;

// node_modules/@mui/x-charts/ChartsAxis/ChartsAxis.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
var getAxisId = (propsValue, defaultAxisId) => {
  if (propsValue == null) {
    return null;
  }
  if (typeof propsValue === "object") {
    return propsValue.axisId ?? defaultAxisId ?? null;
  }
  return propsValue;
};
var mergeProps = (axisConfig, slots, slotProps) => {
  return typeof axisConfig === "object" ? _extends({}, axisConfig, {
    slots: _extends({}, slots, axisConfig == null ? void 0 : axisConfig.slots),
    slotProps: _extends({}, slotProps, axisConfig == null ? void 0 : axisConfig.slotProps)
  }) : {
    slots,
    slotProps
  };
};
function ChartsAxis(props) {
  const {
    topAxis,
    leftAxis,
    rightAxis,
    bottomAxis,
    slots,
    slotProps
  } = props;
  const {
    xAxis,
    xAxisIds,
    yAxis,
    yAxisIds
  } = useCartesianContext();
  const leftId = getAxisId(leftAxis === void 0 ? yAxisIds[0] : leftAxis, yAxisIds[0]);
  const bottomId = getAxisId(bottomAxis === void 0 ? xAxisIds[0] : bottomAxis, xAxisIds[0]);
  const topId = getAxisId(topAxis, xAxisIds[0]);
  const rightId = getAxisId(rightAxis, yAxisIds[0]);
  if (topId !== null && !xAxis[topId]) {
    throw new Error([`MUI X: id used for top axis "${topId}" is not defined.`, `Available ids are: ${xAxisIds.join(", ")}.`].join("\n"));
  }
  if (leftId !== null && !yAxis[leftId]) {
    throw new Error([`MUI X: id used for left axis "${leftId}" is not defined.`, `Available ids are: ${yAxisIds.join(", ")}.`].join("\n"));
  }
  if (rightId !== null && !yAxis[rightId]) {
    throw new Error([`MUI X: id used for right axis "${rightId}" is not defined.`, `Available ids are: ${yAxisIds.join(", ")}.`].join("\n"));
  }
  if (bottomId !== null && !xAxis[bottomId]) {
    throw new Error([`MUI X: id used for bottom axis "${bottomId}" is not defined.`, `Available ids are: ${xAxisIds.join(", ")}.`].join("\n"));
  }
  const topAxisProps = mergeProps(topAxis, slots, slotProps);
  const bottomAxisProps = mergeProps(bottomAxis, slots, slotProps);
  const leftAxisProps = mergeProps(leftAxis, slots, slotProps);
  const rightAxisProps = mergeProps(rightAxis, slots, slotProps);
  return (0, import_jsx_runtime8.jsxs)(React9.Fragment, {
    children: [topId && (0, import_jsx_runtime8.jsx)(ChartsXAxis, _extends({}, topAxisProps, {
      position: "top",
      axisId: topId
    })), bottomId && (0, import_jsx_runtime8.jsx)(ChartsXAxis, _extends({}, bottomAxisProps, {
      position: "bottom",
      axisId: bottomId
    })), leftId && (0, import_jsx_runtime8.jsx)(ChartsYAxis, _extends({}, leftAxisProps, {
      position: "left",
      axisId: leftId
    })), rightId && (0, import_jsx_runtime8.jsx)(ChartsYAxis, _extends({}, rightAxisProps, {
      position: "right",
      axisId: rightId
    }))]
  });
}
true ? ChartsAxis.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Indicate which axis to display the bottom of the charts.
   * Can be a string (the id of the axis) or an object `ChartsXAxisProps`.
   * @default xAxisIds[0] The id of the first provided axis
   */
  bottomAxis: import_prop_types6.default.oneOfType([import_prop_types6.default.object, import_prop_types6.default.string]),
  /**
   * Indicate which axis to display the left of the charts.
   * Can be a string (the id of the axis) or an object `ChartsYAxisProps`.
   * @default yAxisIds[0] The id of the first provided axis
   */
  leftAxis: import_prop_types6.default.oneOfType([import_prop_types6.default.object, import_prop_types6.default.string]),
  /**
   * Indicate which axis to display the right of the charts.
   * Can be a string (the id of the axis) or an object `ChartsYAxisProps`.
   * @default null
   */
  rightAxis: import_prop_types6.default.oneOfType([import_prop_types6.default.object, import_prop_types6.default.string]),
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types6.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types6.default.object,
  /**
   * Indicate which axis to display the top of the charts.
   * Can be a string (the id of the axis) or an object `ChartsXAxisProps`.
   * @default null
   */
  topAxis: import_prop_types6.default.oneOfType([import_prop_types6.default.object, import_prop_types6.default.string])
} : void 0;

// node_modules/@mui/x-charts/ChartsGrid/ChartsGrid.js
init_extends();
var React12 = __toESM(require_react());
var import_prop_types7 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/ChartsGrid/chartsGridClasses.js
function getChartsGridUtilityClass(slot) {
  return generateUtilityClass("MuiChartsGrid", slot);
}
var chartsGridClasses = generateUtilityClasses("MuiChartsGrid", ["root", "line", "horizontalLine", "verticalLine"]);

// node_modules/@mui/x-charts/ChartsGrid/styledCommonents.js
var GridRoot = styled_default("g", {
  name: "MuiChartsGrid",
  slot: "Root",
  overridesResolver: (props, styles) => [{
    [`&.${chartsGridClasses.verticalLine}`]: styles.verticalLine
  }, {
    [`&.${chartsGridClasses.horizontalLine}`]: styles.horizontalLine
  }, styles.root]
})({});
var GridLine = styled_default("line", {
  name: "MuiChartsGrid",
  slot: "Line",
  overridesResolver: (props, styles) => styles.line
})(({
  theme
}) => ({
  stroke: (theme.vars || theme).palette.divider,
  shapeRendering: "crispEdges",
  strokeWidth: 1
}));

// node_modules/@mui/x-charts/ChartsGrid/ChartsVerticalGrid.js
var React10 = __toESM(require_react());
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
function ChartsGridVertical(props) {
  const {
    axis,
    drawingArea,
    classes
  } = props;
  const {
    scale: scale2,
    tickNumber,
    tickInterval
  } = axis;
  const xTicks = useTicks({
    scale: scale2,
    tickNumber,
    tickInterval
  });
  return (0, import_jsx_runtime9.jsx)(React10.Fragment, {
    children: xTicks.map(({
      formattedValue,
      offset
    }) => (0, import_jsx_runtime9.jsx)(GridLine, {
      y1: drawingArea.top,
      y2: drawingArea.top + drawingArea.height,
      x1: offset,
      x2: offset,
      className: classes.verticalLine
    }, `vertical-${formattedValue}`))
  });
}

// node_modules/@mui/x-charts/ChartsGrid/ChartsHorizontalGrid.js
var React11 = __toESM(require_react());
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
function ChartsGridHorizontal(props) {
  const {
    axis,
    drawingArea,
    classes
  } = props;
  const {
    scale: scale2,
    tickNumber,
    tickInterval
  } = axis;
  const yTicks = useTicks({
    scale: scale2,
    tickNumber,
    tickInterval
  });
  return (0, import_jsx_runtime10.jsx)(React11.Fragment, {
    children: yTicks.map(({
      formattedValue,
      offset
    }) => (0, import_jsx_runtime10.jsx)(GridLine, {
      y1: offset,
      y2: offset,
      x1: drawingArea.left,
      x2: drawingArea.left + drawingArea.width,
      className: classes.horizontalLine
    }, `horizontal-${formattedValue}`))
  });
}

// node_modules/@mui/x-charts/ChartsGrid/ChartsGrid.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime());
var _excluded5 = ["vertical", "horizontal"];
var useUtilityClasses3 = ({
  classes
}) => {
  const slots = {
    root: ["root"],
    verticalLine: ["line", "verticalLine"],
    horizontalLine: ["line", "horizontalLine"]
  };
  return composeClasses(slots, getChartsGridUtilityClass, classes);
};
function ChartsGrid(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiChartsGrid"
  });
  const drawingArea = useDrawingArea();
  const {
    vertical,
    horizontal
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded5);
  const {
    xAxis,
    xAxisIds,
    yAxis,
    yAxisIds
  } = useCartesianContext();
  const classes = useUtilityClasses3(props);
  const horizontalAxis = yAxis[yAxisIds[0]];
  const verticalAxis = xAxis[xAxisIds[0]];
  return (0, import_jsx_runtime11.jsxs)(GridRoot, _extends({}, other, {
    className: classes.root,
    children: [vertical && (0, import_jsx_runtime11.jsx)(ChartsGridVertical, {
      axis: verticalAxis,
      drawingArea,
      classes
    }), horizontal && (0, import_jsx_runtime11.jsx)(ChartsGridHorizontal, {
      axis: horizontalAxis,
      drawingArea,
      classes
    })]
  }));
}
true ? ChartsGrid.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types7.default.object,
  /**
   * Displays horizontal grid.
   */
  horizontal: import_prop_types7.default.bool,
  /**
   * Displays vertical grid.
   */
  vertical: import_prop_types7.default.bool
} : void 0;

// node_modules/@mui/x-charts/ChartsTooltip/ChartsTooltip.js
init_extends();
var React18 = __toESM(require_react());
var import_prop_types10 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/ChartsTooltip/utils.js
init_extends();
var React13 = __toESM(require_react());
function generateVirtualElement(mousePosition) {
  if (mousePosition === null) {
    return {
      getBoundingClientRect: () => ({
        width: 0,
        height: 0,
        x: 0,
        y: 0,
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        toJSON: () => ""
      })
    };
  }
  const {
    x,
    y
  } = mousePosition;
  const boundingBox = {
    width: 0,
    height: 0,
    x,
    y,
    top: y,
    right: x,
    bottom: y,
    left: x
  };
  return {
    getBoundingClientRect: () => _extends({}, boundingBox, {
      toJSON: () => JSON.stringify(boundingBox)
    })
  };
}
function useMouseTracker() {
  const svgRef = useSvgRef();
  const [mousePosition, setMousePosition] = React13.useState(null);
  React13.useEffect(() => {
    const element = svgRef.current;
    if (element === null) {
      return () => {
      };
    }
    const handleOut = (event) => {
      if (event.pointerType !== "mouse") {
        setMousePosition(null);
      }
    };
    const handleMove = (event) => {
      setMousePosition({
        x: event.clientX,
        y: event.clientY,
        height: event.height,
        pointerType: event.pointerType
      });
    };
    element.addEventListener("pointerdown", handleMove);
    element.addEventListener("pointermove", handleMove);
    element.addEventListener("pointerup", handleOut);
    return () => {
      element.removeEventListener("pointerdown", handleMove);
      element.removeEventListener("pointermove", handleMove);
      element.removeEventListener("pointerup", handleOut);
    };
  }, [svgRef]);
  return mousePosition;
}
function getTooltipHasData(trigger, displayedData) {
  if (trigger === "item") {
    return displayedData !== null;
  }
  const hasAxisXData = displayedData.x !== null;
  const hasAxisYData = displayedData.y !== null;
  return hasAxisXData || hasAxisYData;
}
function utcFormatter(v2) {
  if (v2 instanceof Date) {
    return v2.toUTCString();
  }
  return v2.toLocaleString();
}

// node_modules/@mui/x-charts/ChartsTooltip/ChartsItemTooltipContent.js
init_extends();
var React15 = __toESM(require_react());

// node_modules/@mui/x-charts/ChartsTooltip/DefaultChartsItemTooltipContent.js
init_extends();
var React14 = __toESM(require_react());
var import_prop_types8 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/ChartsTooltip/chartsTooltipClasses.js
function getChartsTooltipUtilityClass(slot) {
  return generateUtilityClass("MuiChartsTooltip", slot);
}
var chartsTooltipClasses = generateUtilityClasses("MuiChartsTooltip", ["root", "paper", "table", "row", "cell", "mark", "markCell", "labelCell", "valueCell"]);

// node_modules/@mui/x-charts/ChartsTooltip/ChartsTooltipTable.js
var ChartsTooltipPaper = styled_default("div", {
  name: "MuiChartsTooltip",
  slot: "Container",
  overridesResolver: (props, styles) => styles.paper
})(({
  theme
}) => ({
  boxShadow: theme.shadows[1],
  backgroundColor: (theme.vars || theme).palette.background.paper,
  color: (theme.vars || theme).palette.text.primary,
  transition: theme.transitions.create("box-shadow"),
  borderRadius: theme.shape.borderRadius
}));
var ChartsTooltipTable = styled_default("table", {
  name: "MuiChartsTooltip",
  slot: "Table",
  overridesResolver: (props, styles) => styles.table
})(({
  theme
}) => ({
  borderSpacing: 0,
  "& thead td": {
    borderBottom: `solid ${(theme.vars || theme).palette.divider} 1px`
  }
}));
var ChartsTooltipRow = styled_default("tr", {
  name: "MuiChartsTooltip",
  slot: "Row",
  overridesResolver: (props, styles) => styles.row
})(({
  theme
}) => ({
  "tr:first-of-type& td": {
    paddingTop: theme.spacing(1)
  },
  "tr:last-of-type& td": {
    paddingBottom: theme.spacing(1)
  }
}));
var ChartsTooltipCell = styled_default("td", {
  name: "MuiChartsTooltip",
  slot: "Cell",
  overridesResolver: (props, styles) => styles.cell
})(({
  theme
}) => ({
  verticalAlign: "middle",
  color: (theme.vars || theme).palette.text.secondary,
  [`&.${chartsTooltipClasses.labelCell}`]: {
    paddingLeft: theme.spacing(1)
  },
  [`&.${chartsTooltipClasses.valueCell}`]: {
    paddingLeft: theme.spacing(4),
    color: (theme.vars || theme).palette.text.primary
  },
  "td:first-of-type&": {
    paddingLeft: theme.spacing(2)
  },
  "td:last-of-type&": {
    paddingRight: theme.spacing(2)
  }
}));
var ChartsTooltipMark = styled_default("div", {
  name: "MuiChartsTooltip",
  slot: "Mark",
  overridesResolver: (props, styles) => styles.mark,
  shouldForwardProp: (prop) => shouldForwardProp(prop) && prop !== "color"
})(({
  theme,
  color: color2
}) => ({
  width: theme.spacing(1),
  height: theme.spacing(1),
  borderRadius: "50%",
  boxShadow: theme.shadows[1],
  backgroundColor: color2,
  borderColor: (theme.vars || theme).palette.background.paper,
  border: `solid ${(theme.vars || theme).palette.background.paper} ${theme.spacing(0.25)}`,
  boxSizing: "content-box"
}));

// node_modules/@mui/x-charts/ChartsTooltip/DefaultChartsItemTooltipContent.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime());
function DefaultChartsItemTooltipContent(props) {
  var _a;
  const {
    series,
    itemData,
    sx,
    classes,
    getColor
  } = props;
  if (itemData.dataIndex === void 0 || !series.data[itemData.dataIndex]) {
    return null;
  }
  const {
    displayedLabel,
    color: color2
  } = series.type === "pie" ? {
    color: getColor(itemData.dataIndex),
    displayedLabel: getLabel(series.data[itemData.dataIndex].label, "tooltip")
  } : {
    color: getColor(itemData.dataIndex),
    displayedLabel: getLabel(series.label, "tooltip")
  };
  const value = series.type === "pie" ? _extends({}, series.data[itemData.dataIndex], {
    label: getLabel(series.data[itemData.dataIndex].label, "tooltip")
  }) : series.data[itemData.dataIndex];
  const formattedValue = (_a = series.valueFormatter) == null ? void 0 : _a.call(series, value, {
    dataIndex: itemData.dataIndex
  });
  return (0, import_jsx_runtime12.jsx)(ChartsTooltipPaper, {
    sx,
    className: classes.paper,
    children: (0, import_jsx_runtime12.jsx)(ChartsTooltipTable, {
      className: classes.table,
      children: (0, import_jsx_runtime12.jsx)("tbody", {
        children: (0, import_jsx_runtime12.jsxs)(ChartsTooltipRow, {
          className: classes.row,
          children: [(0, import_jsx_runtime12.jsx)(ChartsTooltipCell, {
            className: clsx_default(classes.markCell, classes.cell),
            children: (0, import_jsx_runtime12.jsx)(ChartsTooltipMark, {
              color: color2,
              className: classes.mark
            })
          }), (0, import_jsx_runtime12.jsx)(ChartsTooltipCell, {
            className: clsx_default(classes.labelCell, classes.cell),
            children: displayedLabel
          }), (0, import_jsx_runtime12.jsx)(ChartsTooltipCell, {
            className: clsx_default(classes.valueCell, classes.cell),
            children: formattedValue
          })]
        })
      })
    })
  });
}
true ? DefaultChartsItemTooltipContent.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types8.default.object.isRequired,
  /**
   * Get the color of the item with index `dataIndex`.
   * @param {number} dataIndex The data index of the item.
   * @returns {string} The color to display.
   */
  getColor: import_prop_types8.default.func.isRequired,
  /**
   * The data used to identify the triggered item.
   */
  itemData: import_prop_types8.default.shape({
    dataIndex: import_prop_types8.default.number,
    seriesId: import_prop_types8.default.oneOfType([import_prop_types8.default.number, import_prop_types8.default.string]).isRequired,
    type: import_prop_types8.default.oneOf(["bar", "line", "pie", "scatter"]).isRequired
  }).isRequired,
  /**
   * The series linked to the triggered axis.
   */
  series: import_prop_types8.default.object.isRequired,
  sx: import_prop_types8.default.oneOfType([import_prop_types8.default.arrayOf(import_prop_types8.default.oneOfType([import_prop_types8.default.func, import_prop_types8.default.object, import_prop_types8.default.bool])), import_prop_types8.default.func, import_prop_types8.default.object])
} : void 0;

// node_modules/@mui/x-charts/ChartsTooltip/ChartsItemTooltipContent.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime());
function ChartsItemTooltipContent(props) {
  var _a;
  const {
    content,
    itemData,
    sx,
    classes,
    contentProps
  } = props;
  const series = useSeries()[itemData.type].series[itemData.seriesId];
  const {
    xAxis,
    yAxis,
    xAxisIds,
    yAxisIds
  } = useCartesianContext();
  const {
    zAxis,
    zAxisIds
  } = React15.useContext(ZAxisContext);
  const colorProcessors = useColorProcessor();
  const xAxisId = series.xAxisId ?? series.xAxisKey ?? xAxisIds[0];
  const yAxisId = series.yAxisId ?? series.yAxisKey ?? yAxisIds[0];
  const zAxisId = series.zAxisId ?? series.zAxisKey ?? zAxisIds[0];
  const getColor = ((_a = colorProcessors[series.type]) == null ? void 0 : _a.call(colorProcessors, series, xAxisId && xAxis[xAxisId], yAxisId && yAxis[yAxisId], zAxisId && zAxis[zAxisId])) ?? (() => "");
  const Content = content ?? DefaultChartsItemTooltipContent;
  const chartTooltipContentProps = useSlotProps_default({
    elementType: Content,
    externalSlotProps: contentProps,
    additionalProps: {
      itemData,
      series,
      sx,
      classes,
      getColor
    },
    ownerState: {}
  });
  return (0, import_jsx_runtime13.jsx)(Content, _extends({}, chartTooltipContentProps));
}

// node_modules/@mui/x-charts/ChartsTooltip/ChartsAxisTooltipContent.js
init_extends();
var React17 = __toESM(require_react());

// node_modules/@mui/x-charts/ChartsTooltip/DefaultChartsAxisTooltipContent.js
var React16 = __toESM(require_react());
var import_prop_types9 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/internals/isCartesian.js
function isCartesianSeriesType(seriesType) {
  return cartesianSeriesTypes.getTypes().has(seriesType);
}
function isCartesianSeries(series) {
  return isCartesianSeriesType(series.type);
}

// node_modules/@mui/x-charts/ChartsTooltip/DefaultChartsAxisTooltipContent.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime());
function DefaultChartsAxisTooltipContent(props) {
  const {
    series,
    axis,
    dataIndex,
    axisValue,
    sx,
    classes
  } = props;
  if (dataIndex == null) {
    return null;
  }
  const axisFormatter = axis.valueFormatter ?? ((v2) => axis.scaleType === "utc" ? utcFormatter(v2) : v2.toLocaleString());
  return (0, import_jsx_runtime14.jsx)(ChartsTooltipPaper, {
    sx,
    className: classes.paper,
    children: (0, import_jsx_runtime14.jsxs)(ChartsTooltipTable, {
      className: classes.table,
      children: [axisValue != null && !axis.hideTooltip && (0, import_jsx_runtime14.jsx)("thead", {
        children: (0, import_jsx_runtime14.jsx)(ChartsTooltipRow, {
          children: (0, import_jsx_runtime14.jsx)(ChartsTooltipCell, {
            colSpan: 3,
            children: (0, import_jsx_runtime14.jsx)(Typography_default, {
              children: axisFormatter(axisValue, {
                location: "tooltip"
              })
            })
          })
        })
      }), (0, import_jsx_runtime14.jsx)("tbody", {
        children: series.filter(isCartesianSeries).map(({
          id,
          label,
          valueFormatter,
          data,
          getColor
        }) => {
          const formattedValue = valueFormatter(data[dataIndex] ?? null, {
            dataIndex
          });
          if (formattedValue == null) {
            return null;
          }
          const formattedLabel = getLabel(label, "tooltip");
          const color2 = getColor(dataIndex);
          return (0, import_jsx_runtime14.jsxs)(ChartsTooltipRow, {
            className: classes.row,
            children: [(0, import_jsx_runtime14.jsx)(ChartsTooltipCell, {
              className: clsx_default(classes.markCell, classes.cell),
              children: color2 && (0, import_jsx_runtime14.jsx)(ChartsTooltipMark, {
                color: color2,
                className: classes.mark
              })
            }), (0, import_jsx_runtime14.jsx)(ChartsTooltipCell, {
              className: clsx_default(classes.labelCell, classes.cell),
              children: formattedLabel ? (0, import_jsx_runtime14.jsx)(Typography_default, {
                children: formattedLabel
              }) : null
            }), (0, import_jsx_runtime14.jsx)(ChartsTooltipCell, {
              className: clsx_default(classes.valueCell, classes.cell),
              children: (0, import_jsx_runtime14.jsx)(Typography_default, {
                children: formattedValue
              })
            })]
          }, id);
        })
      })]
    })
  });
}
true ? DefaultChartsAxisTooltipContent.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The properties of the triggered axis.
   */
  axis: import_prop_types9.default.object.isRequired,
  /**
   * Data identifying the triggered axis.
   */
  axisData: import_prop_types9.default.shape({
    x: import_prop_types9.default.shape({
      index: import_prop_types9.default.number,
      value: import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number, import_prop_types9.default.string]).isRequired
    }),
    y: import_prop_types9.default.shape({
      index: import_prop_types9.default.number,
      value: import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number, import_prop_types9.default.string]).isRequired
    })
  }).isRequired,
  /**
   * The value associated to the current mouse position.
   */
  axisValue: import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number, import_prop_types9.default.string]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types9.default.object.isRequired,
  /**
   * The index of the data item triggered.
   */
  dataIndex: import_prop_types9.default.number,
  /**
   * The series linked to the triggered axis.
   */
  series: import_prop_types9.default.arrayOf(import_prop_types9.default.object).isRequired,
  sx: import_prop_types9.default.oneOfType([import_prop_types9.default.arrayOf(import_prop_types9.default.oneOfType([import_prop_types9.default.func, import_prop_types9.default.object, import_prop_types9.default.bool])), import_prop_types9.default.func, import_prop_types9.default.object])
} : void 0;

// node_modules/@mui/x-charts/ChartsTooltip/ChartsAxisTooltipContent.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime());
function ChartsAxisTooltipContent(props) {
  const {
    content,
    contentProps,
    axisData,
    sx,
    classes
  } = props;
  const isXaxis = axisData.x && axisData.x.index !== -1;
  const dataIndex = isXaxis ? axisData.x && axisData.x.index : axisData.y && axisData.y.index;
  const axisValue = isXaxis ? axisData.x && axisData.x.value : axisData.y && axisData.y.value;
  const {
    xAxisIds,
    xAxis,
    yAxisIds,
    yAxis
  } = useCartesianContext();
  const {
    zAxisIds,
    zAxis
  } = React17.useContext(ZAxisContext);
  const series = useSeries();
  const colorProcessors = useColorProcessor();
  const USED_AXIS_ID = isXaxis ? xAxisIds[0] : yAxisIds[0];
  const relevantSeries = React17.useMemo(() => {
    const rep = [];
    Object.keys(series).filter(isCartesianSeriesType).forEach((seriesType) => {
      series[seriesType].seriesOrder.forEach((seriesId) => {
        var _a;
        const item = series[seriesType].series[seriesId];
        const providedXAxisId = item.xAxisId ?? item.xAxisKey;
        const providedYAxisId = item.yAxisId ?? item.yAxisKey;
        const axisKey = isXaxis ? providedXAxisId : providedYAxisId;
        if (axisKey === void 0 || axisKey === USED_AXIS_ID) {
          const seriesToAdd = series[seriesType].series[seriesId];
          const xAxisId = providedXAxisId ?? xAxisIds[0];
          const yAxisId = providedYAxisId ?? yAxisIds[0];
          const zAxisId = seriesToAdd.zAxisId ?? seriesToAdd.zAxisKey ?? zAxisIds[0];
          const getColor = ((_a = colorProcessors[seriesType]) == null ? void 0 : _a.call(colorProcessors, seriesToAdd, xAxis[xAxisId], yAxis[yAxisId], zAxisId && zAxis[zAxisId])) ?? (() => "");
          rep.push(_extends({}, seriesToAdd, {
            getColor
          }));
        }
      });
    });
    return rep;
  }, [USED_AXIS_ID, colorProcessors, isXaxis, series, xAxis, xAxisIds, yAxis, yAxisIds, zAxis, zAxisIds]);
  const relevantAxis = React17.useMemo(() => {
    return isXaxis ? xAxis[USED_AXIS_ID] : yAxis[USED_AXIS_ID];
  }, [USED_AXIS_ID, isXaxis, xAxis, yAxis]);
  const Content = content ?? DefaultChartsAxisTooltipContent;
  const chartTooltipContentProps = useSlotProps_default({
    elementType: Content,
    externalSlotProps: contentProps,
    additionalProps: {
      axisData,
      series: relevantSeries,
      axis: relevantAxis,
      dataIndex,
      axisValue,
      sx,
      classes
    },
    ownerState: {}
  });
  return (0, import_jsx_runtime15.jsx)(Content, _extends({}, chartTooltipContentProps));
}

// node_modules/@mui/x-charts/ChartsTooltip/ChartsTooltip.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime());
var useUtilityClasses4 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    paper: ["paper"],
    table: ["table"],
    row: ["row"],
    cell: ["cell"],
    mark: ["mark"],
    markCell: ["markCell"],
    labelCell: ["labelCell"],
    valueCell: ["valueCell"]
  };
  return composeClasses(slots, getChartsTooltipUtilityClass, classes);
};
var ChartsTooltipRoot = styled_default(Popper_default, {
  name: "MuiChartsTooltip",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})(({
  theme
}) => ({
  pointerEvents: "none",
  zIndex: theme.zIndex.modal
}));
function ChartsTooltip(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiChartsTooltip"
  });
  const {
    trigger = "axis",
    itemContent,
    axisContent,
    slots,
    slotProps
  } = props;
  const mousePosition = useMouseTracker();
  const {
    item,
    axis
  } = React18.useContext(InteractionContext);
  const displayedData = trigger === "item" ? item : axis;
  const tooltipHasData = getTooltipHasData(trigger, displayedData);
  const popperOpen = mousePosition !== null && tooltipHasData;
  const classes = useUtilityClasses4({
    classes: props.classes
  });
  const PopperComponent = (slots == null ? void 0 : slots.popper) ?? ChartsTooltipRoot;
  const popperProps = useSlotProps_default({
    elementType: PopperComponent,
    externalSlotProps: slotProps == null ? void 0 : slotProps.popper,
    additionalProps: {
      open: popperOpen,
      placement: (mousePosition == null ? void 0 : mousePosition.pointerType) === "mouse" ? "right-start" : "top",
      anchorEl: generateVirtualElement(mousePosition),
      modifiers: [{
        name: "offset",
        options: {
          offset: [0, (mousePosition == null ? void 0 : mousePosition.pointerType) === "touch" ? 40 - mousePosition.height : 0]
        }
      }]
    },
    ownerState: {}
  });
  if (trigger === "none") {
    return null;
  }
  return (0, import_jsx_runtime16.jsx)(NoSsr_default, {
    children: popperOpen && (0, import_jsx_runtime16.jsx)(PopperComponent, _extends({}, popperProps, {
      className: classes.root,
      children: trigger === "item" ? (0, import_jsx_runtime16.jsx)(ChartsItemTooltipContent, {
        itemData: displayedData,
        content: (slots == null ? void 0 : slots.itemContent) ?? itemContent,
        contentProps: slotProps == null ? void 0 : slotProps.itemContent,
        sx: {
          mx: 2
        },
        classes
      }) : (0, import_jsx_runtime16.jsx)(ChartsAxisTooltipContent, {
        axisData: displayedData,
        content: (slots == null ? void 0 : slots.axisContent) ?? axisContent,
        contentProps: slotProps == null ? void 0 : slotProps.axisContent,
        sx: {
          mx: 2
        },
        classes
      })
    }))
  });
}
true ? ChartsTooltip.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Component to override the tooltip content when trigger is set to 'axis'.
   * @deprecated Use slots.axisContent instead
   */
  axisContent: import_prop_types10.default.elementType,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types10.default.object,
  /**
   * Component to override the tooltip content when trigger is set to 'item'.
   * @deprecated Use slots.itemContent instead
   */
  itemContent: import_prop_types10.default.elementType,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types10.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types10.default.object,
  /**
   * Select the kind of tooltip to display
   * - 'item': Shows data about the item below the mouse.
   * - 'axis': Shows values associated with the hovered x value
   * - 'none': Does not display tooltip
   * @default 'axis'
   */
  trigger: import_prop_types10.default.oneOf(["axis", "item", "none"])
} : void 0;

// node_modules/@mui/x-charts/ChartsTooltip/useItemTooltip.js
init_extends();
var React19 = __toESM(require_react());
function useItemTooltip() {
  var _a, _b, _c;
  const {
    item
  } = React19.useContext(InteractionContext);
  const series = useSeries();
  const {
    xAxis,
    yAxis,
    xAxisIds,
    yAxisIds
  } = useCartesianContext();
  const {
    zAxis,
    zAxisIds
  } = React19.useContext(ZAxisContext);
  const colorProcessors = useColorProcessor();
  const xAxisId = series.xAxisId ?? series.xAxisKey ?? xAxisIds[0];
  const yAxisId = series.yAxisId ?? series.yAxisKey ?? yAxisIds[0];
  const zAxisId = series.zAxisId ?? series.zAxisKey ?? zAxisIds[0];
  if (!item || item.dataIndex === void 0) {
    return null;
  }
  const itemSeries = series[item.type].series[item.seriesId];
  const getColor = ((_a = colorProcessors[itemSeries.type]) == null ? void 0 : _a.call(colorProcessors, itemSeries, xAxisId && xAxis[xAxisId], yAxisId && yAxis[yAxisId], zAxisId && zAxis[zAxisId])) ?? (() => "");
  if (itemSeries.type === "pie") {
    const point = itemSeries.data[item.dataIndex];
    const label2 = getLabel(point.label, "tooltip");
    const value2 = _extends({}, point, {
      label: label2
    });
    const formattedValue2 = (_b = itemSeries.valueFormatter) == null ? void 0 : _b.call(itemSeries, value2, {
      dataIndex: item.dataIndex
    });
    return {
      identifier: item,
      color: getColor(item.dataIndex),
      label: label2,
      value: value2,
      formattedValue: formattedValue2
    };
  }
  const label = getLabel(itemSeries.label, "tooltip");
  const value = itemSeries.data[item.dataIndex];
  const formattedValue = (_c = itemSeries.valueFormatter) == null ? void 0 : _c.call(itemSeries, value, {
    dataIndex: item.dataIndex
  });
  return {
    identifier: item,
    color: getColor(item.dataIndex),
    label,
    value,
    formattedValue
  };
}

// node_modules/@mui/x-charts/ChartsTooltip/useAxisTooltip.js
var React20 = __toESM(require_react());
function useAxisTooltip() {
  const {
    axis
  } = React20.useContext(InteractionContext);
  const series = useSeries();
  const {
    xAxis,
    yAxis,
    xAxisIds,
    yAxisIds
  } = useCartesianContext();
  const {
    zAxis,
    zAxisIds
  } = React20.useContext(ZAxisContext);
  const colorProcessors = useColorProcessor();
  const isXaxis = axis.x !== null && axis.x.index !== -1;
  const axisData = isXaxis ? axis.x && axis.x : axis.y && axis.y;
  if (axisData === null) {
    return null;
  }
  const {
    index: dataIndex,
    value: axisValue
  } = axisData;
  const USED_AXIS_ID = isXaxis ? xAxisIds[0] : yAxisIds[0];
  const usedAxis = isXaxis ? xAxis[USED_AXIS_ID] : yAxis[USED_AXIS_ID];
  const relevantSeries = Object.keys(series).filter(isCartesianSeriesType).flatMap((seriesType) => {
    const seriesOfType = series[seriesType];
    if (!seriesOfType) {
      return [];
    }
    return seriesOfType.seriesOrder.map((seriesId) => {
      var _a;
      const seriesToAdd = seriesOfType.series[seriesId];
      const providedXAxisId = seriesToAdd.xAxisId ?? seriesToAdd.xAxisKey;
      const providedYAxisId = seriesToAdd.yAxisId ?? seriesToAdd.yAxisKey;
      const axisKey = isXaxis ? providedXAxisId : providedYAxisId;
      if (axisKey === void 0 || axisKey === USED_AXIS_ID) {
        const xAxisId = providedXAxisId ?? xAxisIds[0];
        const yAxisId = providedYAxisId ?? yAxisIds[0];
        const zAxisId = seriesToAdd.zAxisId ?? seriesToAdd.zAxisKey ?? zAxisIds[0];
        const color2 = ((_a = colorProcessors[seriesType]) == null ? void 0 : _a.call(colorProcessors, seriesToAdd, xAxis[xAxisId], yAxis[yAxisId], zAxisId && zAxis[zAxisId])(dataIndex)) ?? "";
        const value = seriesToAdd.data[dataIndex] ?? null;
        const formattedValue = seriesToAdd.valueFormatter(value, {
          dataIndex
        });
        const formattedLabel = getLabel(seriesToAdd.label, "tooltip") ?? null;
        return {
          seriesId,
          color: color2,
          value,
          formattedValue,
          formattedLabel
        };
      }
      return void 0;
    });
  }).filter((item) => item != null);
  const axisFormatter = usedAxis.valueFormatter ?? ((v2) => usedAxis.scaleType === "utc" ? utcFormatter(v2) : v2.toLocaleString());
  const axisFormattedValue = axisFormatter(axisValue, {
    location: "tooltip"
  });
  return {
    identifier: axis,
    seriesItems: relevantSeries,
    axisValue,
    axisFormattedValue
  };
}

// node_modules/@mui/x-charts/ChartsLegend/ChartsLegend.js
init_extends();
var React24 = __toESM(require_react());
var import_prop_types12 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/BarChart/legend.js
var legendGetter = (params) => {
  const {
    seriesOrder,
    series
  } = params;
  return seriesOrder.reduce((acc, seriesId) => {
    const formattedLabel = getLabel(series[seriesId].label, "legend");
    if (formattedLabel === void 0) {
      return acc;
    }
    acc.push({
      id: seriesId,
      seriesId,
      color: series[seriesId].color,
      label: formattedLabel
    });
    return acc;
  }, []);
};
var legend_default = legendGetter;

// node_modules/@mui/x-charts/ScatterChart/legend.js
var legendGetter2 = (params) => {
  const {
    seriesOrder,
    series
  } = params;
  return seriesOrder.reduce((acc, seriesId) => {
    const formattedLabel = getLabel(series[seriesId].label, "legend");
    if (formattedLabel === void 0) {
      return acc;
    }
    acc.push({
      id: seriesId,
      seriesId,
      color: series[seriesId].color,
      label: formattedLabel
    });
    return acc;
  }, []);
};
var legend_default2 = legendGetter2;

// node_modules/@mui/x-charts/LineChart/legend.js
var legendGetter3 = (params) => {
  const {
    seriesOrder,
    series
  } = params;
  return seriesOrder.reduce((acc, seriesId) => {
    const formattedLabel = getLabel(series[seriesId].label, "legend");
    if (formattedLabel === void 0) {
      return acc;
    }
    acc.push({
      id: seriesId,
      seriesId,
      color: series[seriesId].color,
      label: formattedLabel
    });
    return acc;
  }, []);
};
var legend_default3 = legendGetter3;

// node_modules/@mui/x-charts/PieChart/legend.js
var legendGetter4 = (params) => {
  const {
    seriesOrder,
    series
  } = params;
  return seriesOrder.reduce((acc, seriesId) => {
    series[seriesId].data.forEach((item) => {
      const formattedLabel = getLabel(item.label, "legend");
      if (formattedLabel === void 0) {
        return;
      }
      acc.push({
        id: item.id,
        seriesId,
        color: item.color,
        label: formattedLabel,
        itemId: item.id
      });
    });
    return acc;
  }, []);
};
var legend_default4 = legendGetter4;

// node_modules/@mui/x-charts/ChartsLegend/utils.js
var legendGetter5 = {
  bar: legend_default,
  scatter: legend_default2,
  line: legend_default3,
  pie: legend_default4
};
function getSeriesToDisplay(series) {
  return Object.keys(series).flatMap((seriesType) => {
    const getter = legendGetter5[seriesType];
    return getter === void 0 ? [] : getter(series[seriesType]);
  });
}

// node_modules/@mui/x-charts/ChartsLegend/chartsLegendClasses.js
function getLegendUtilityClass(slot) {
  return generateUtilityClass("MuiChartsLegend", slot);
}
var legendClasses = generateUtilityClasses("MuiChartsLegend", ["root", "series", "itemBackground", "mark", "label", "column", "row"]);

// node_modules/@mui/x-charts/ChartsLegend/DefaultChartsLegend.js
init_extends();
var React23 = __toESM(require_react());
var import_prop_types11 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/ChartsLegend/LegendPerItem.js
init_extends();
var React22 = __toESM(require_react());

// node_modules/@mui/x-charts/ChartsLegend/legendItemsPlacement.js
init_extends();
var _excluded6 = ["label"];
function legendItemPlacements(itemsToDisplay, getItemSpace, labelStyle, direction, availableWidth, availableHeight, itemGap) {
  let x = 0;
  let y = 0;
  let totalWidthUsed = 0;
  let totalHeightUsed = 0;
  let rowIndex = 0;
  const rowMaxHeight = [0];
  const seriesWithRawPosition = itemsToDisplay.map((_ref) => {
    let {
      label
    } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded6);
    const itemSpace = getItemSpace(label, labelStyle);
    const rep = _extends({}, other, {
      label,
      positionX: x,
      positionY: y,
      innerHeight: itemSpace.innerHeight,
      innerWidth: itemSpace.innerWidth,
      outerHeight: itemSpace.outerHeight,
      outerWidth: itemSpace.outerWidth,
      rowIndex
    });
    if (direction === "row") {
      if (x + itemSpace.innerWidth > availableWidth) {
        x = 0;
        y += rowMaxHeight[rowIndex];
        rowIndex += 1;
        if (rowMaxHeight.length <= rowIndex) {
          rowMaxHeight.push(0);
        }
        rep.positionX = x;
        rep.positionY = y;
        rep.rowIndex = rowIndex;
      }
      totalWidthUsed = Math.max(totalWidthUsed, x + itemSpace.outerWidth);
      totalHeightUsed = Math.max(totalHeightUsed, y + itemSpace.outerHeight);
      rowMaxHeight[rowIndex] = Math.max(rowMaxHeight[rowIndex], itemSpace.outerHeight);
      x += itemSpace.outerWidth;
    }
    if (direction === "column") {
      if (y + itemSpace.innerHeight > availableHeight) {
        x = totalWidthUsed + itemGap;
        y = 0;
        rowIndex = 0;
        rep.positionX = x;
        rep.positionY = y;
        rep.rowIndex = rowIndex;
      }
      if (rowMaxHeight.length <= rowIndex) {
        rowMaxHeight.push(0);
      }
      totalWidthUsed = Math.max(totalWidthUsed, x + itemSpace.outerWidth);
      totalHeightUsed = Math.max(totalHeightUsed, y + itemSpace.outerHeight);
      rowIndex += 1;
      y += itemSpace.outerHeight;
    }
    return rep;
  });
  return [seriesWithRawPosition.map((item) => _extends({}, item, {
    positionY: item.positionY + (direction === "row" ? rowMaxHeight[item.rowIndex] / 2 : item.outerHeight / 2)
    // Get the center of the item
  })), totalWidthUsed, totalHeightUsed];
}

// node_modules/@mui/x-charts/ChartsLegend/ChartsLegendItem.js
init_extends();
var React21 = __toESM(require_react());
var import_jsx_runtime17 = __toESM(require_jsx_runtime());
function ChartsLegendItem(props) {
  const isRTL = useRtl();
  const {
    id,
    positionY,
    label,
    positionX,
    innerHeight,
    innerWidth,
    legendWidth,
    color: color2,
    gapX,
    gapY,
    itemMarkHeight,
    itemMarkWidth,
    markGap,
    labelStyle,
    classes,
    onClick
  } = props;
  return (0, import_jsx_runtime17.jsxs)("g", {
    className: clsx_default(classes == null ? void 0 : classes.series, `${classes == null ? void 0 : classes.series}-${id}`),
    transform: `translate(${gapX + (isRTL ? legendWidth - positionX : positionX)} ${gapY + positionY})`,
    children: [(0, import_jsx_runtime17.jsx)("rect", {
      x: isRTL ? -(innerWidth + 2) : -2,
      y: -itemMarkHeight / 2 - 2,
      width: innerWidth + 4,
      height: innerHeight + 4,
      fill: "transparent",
      className: classes == null ? void 0 : classes.itemBackground,
      onClick,
      style: {
        pointerEvents: onClick ? "all" : "none",
        cursor: onClick ? "pointer" : "unset"
      }
    }), (0, import_jsx_runtime17.jsx)("rect", {
      className: classes == null ? void 0 : classes.mark,
      x: isRTL ? -itemMarkWidth : 0,
      y: -itemMarkHeight / 2,
      width: itemMarkWidth,
      height: itemMarkHeight,
      fill: color2,
      style: {
        pointerEvents: "none"
      }
    }), (0, import_jsx_runtime17.jsx)(ChartsText, {
      style: _extends({
        pointerEvents: "none"
      }, labelStyle),
      text: label,
      x: (isRTL ? -1 : 1) * (itemMarkWidth + markGap),
      y: 0
    })]
  });
}

// node_modules/@mui/x-charts/ChartsLegend/LegendPerItem.js
var import_react = __toESM(require_react());
var import_jsx_runtime18 = __toESM(require_jsx_runtime());
var _excluded7 = ["rotate", "dominantBaseline"];
var ChartsLegendRoot = styled_default("g", {
  name: "MuiChartsLegend",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({});
var getStandardizedPadding = (padding) => {
  if (typeof padding === "number") {
    return {
      left: padding,
      right: padding,
      top: padding,
      bottom: padding
    };
  }
  return _extends({
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
  }, padding);
};
function LegendPerItem(props) {
  const {
    position,
    direction,
    itemsToDisplay,
    classes,
    itemMarkWidth = 20,
    itemMarkHeight = 20,
    markGap = 5,
    itemGap = 10,
    padding: paddingProps = 10,
    labelStyle: inLabelStyle,
    onItemClick
  } = props;
  const theme = useTheme();
  const drawingArea = useDrawingArea();
  const labelStyle = React22.useMemo(
    () => _extends({}, theme.typography.subtitle1, {
      color: "inherit",
      dominantBaseline: "central",
      textAnchor: "start",
      fill: (theme.vars || theme).palette.text.primary,
      lineHeight: 1
    }, inLabelStyle),
    // To say to TS that the dominantBaseline and textAnchor are correct
    [inLabelStyle, theme]
  );
  const padding = React22.useMemo(() => getStandardizedPadding(paddingProps), [paddingProps]);
  const getItemSpace = React22.useCallback((label, inStyle = {}) => {
    const style = _objectWithoutPropertiesLoose(inStyle, _excluded7);
    const linesSize = getWordsByLines({
      style,
      needsComputation: true,
      text: label
    });
    const innerSize = {
      innerWidth: itemMarkWidth + markGap + Math.max(...linesSize.map((size) => size.width)),
      innerHeight: Math.max(itemMarkHeight, linesSize.length * linesSize[0].height)
    };
    return _extends({}, innerSize, {
      outerWidth: innerSize.innerWidth + itemGap,
      outerHeight: innerSize.innerHeight + itemGap
    });
  }, [itemGap, itemMarkHeight, itemMarkWidth, markGap]);
  const totalWidth = drawingArea.left + drawingArea.width + drawingArea.right;
  const totalHeight = drawingArea.top + drawingArea.height + drawingArea.bottom;
  const availableWidth = totalWidth - padding.left - padding.right;
  const availableHeight = totalHeight - padding.top - padding.bottom;
  const [itemsWithPosition, legendWidth, legendHeight] = React22.useMemo(() => legendItemPlacements(itemsToDisplay, getItemSpace, labelStyle, direction, availableWidth, availableHeight, itemGap), [itemsToDisplay, getItemSpace, labelStyle, direction, availableWidth, availableHeight, itemGap]);
  const gapX = React22.useMemo(() => {
    switch (position.horizontal) {
      case "left":
        return padding.left;
      case "right":
        return totalWidth - padding.right - legendWidth;
      default:
        return (totalWidth - legendWidth) / 2;
    }
  }, [position.horizontal, padding.left, padding.right, totalWidth, legendWidth]);
  const gapY = React22.useMemo(() => {
    switch (position.vertical) {
      case "top":
        return padding.top;
      case "bottom":
        return totalHeight - padding.bottom - legendHeight;
      default:
        return (totalHeight - legendHeight) / 2;
    }
  }, [position.vertical, padding.top, padding.bottom, totalHeight, legendHeight]);
  return (0, import_jsx_runtime18.jsx)(NoSsr_default, {
    children: (0, import_jsx_runtime18.jsx)(ChartsLegendRoot, {
      className: classes == null ? void 0 : classes.root,
      children: itemsWithPosition.map((item, i) => (0, import_react.createElement)(ChartsLegendItem, _extends({}, item, {
        key: item.id,
        gapX,
        gapY,
        legendWidth,
        itemMarkHeight,
        itemMarkWidth,
        markGap,
        labelStyle,
        classes,
        onClick: onItemClick ? (event) => onItemClick(event, i) : void 0
      })))
    })
  });
}

// node_modules/@mui/x-charts/ChartsLegend/DefaultChartsLegend.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime());
var _excluded8 = ["drawingArea", "seriesToDisplay", "hidden", "onItemClick"];
var seriesContextBuilder = (context) => ({
  type: "series",
  color: context.color,
  label: context.label,
  seriesId: context.seriesId,
  itemId: context.itemId
});
function DefaultChartsLegend(props) {
  const {
    seriesToDisplay,
    hidden,
    onItemClick
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded8);
  if (hidden) {
    return null;
  }
  return (0, import_jsx_runtime19.jsx)(LegendPerItem, _extends({}, other, {
    itemsToDisplay: seriesToDisplay,
    onItemClick: onItemClick ? (event, i) => onItemClick(event, seriesContextBuilder(seriesToDisplay[i]), i) : void 0
  }));
}
true ? DefaultChartsLegend.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types11.default.object,
  /**
   * The direction of the legend layout.
   * The default depends on the chart.
   */
  direction: import_prop_types11.default.oneOf(["column", "row"]).isRequired,
  /**
   * @deprecated Use the `useDrawingArea` hook instead.
   */
  drawingArea: import_prop_types11.default.shape({
    bottom: import_prop_types11.default.number.isRequired,
    height: import_prop_types11.default.number.isRequired,
    left: import_prop_types11.default.number.isRequired,
    right: import_prop_types11.default.number.isRequired,
    top: import_prop_types11.default.number.isRequired,
    width: import_prop_types11.default.number.isRequired
  }).isRequired,
  /**
   * Set to true to hide the legend.
   * @default false
   */
  hidden: import_prop_types11.default.bool,
  /**
   * Space between two legend items (in px).
   * @default 10
   */
  itemGap: import_prop_types11.default.number,
  /**
   * Height of the item mark (in px).
   * @default 20
   */
  itemMarkHeight: import_prop_types11.default.number,
  /**
   * Width of the item mark (in px).
   * @default 20
   */
  itemMarkWidth: import_prop_types11.default.number,
  /**
   * Style applied to legend labels.
   * @default theme.typography.subtitle1
   */
  labelStyle: import_prop_types11.default.object,
  /**
   * Space between the mark and the label (in px).
   * @default 5
   */
  markGap: import_prop_types11.default.number,
  /**
   * Callback fired when a legend item is clicked.
   * @param {React.MouseEvent<SVGRectElement, MouseEvent>} event The click event.
   * @param {SeriesLegendItemContext} legendItem The legend item data.
   * @param {number} index The index of the clicked legend item.
   */
  onItemClick: import_prop_types11.default.func,
  /**
   * Legend padding (in px).
   * Can either be a single number, or an object with top, left, bottom, right properties.
   * @default 10
   */
  padding: import_prop_types11.default.oneOfType([import_prop_types11.default.number, import_prop_types11.default.shape({
    bottom: import_prop_types11.default.number,
    left: import_prop_types11.default.number,
    right: import_prop_types11.default.number,
    top: import_prop_types11.default.number
  })]),
  /**
   * The position of the legend.
   */
  position: import_prop_types11.default.shape({
    horizontal: import_prop_types11.default.oneOf(["left", "middle", "right"]).isRequired,
    vertical: import_prop_types11.default.oneOf(["bottom", "middle", "top"]).isRequired
  }).isRequired,
  series: import_prop_types11.default.object.isRequired,
  seriesToDisplay: import_prop_types11.default.arrayOf(import_prop_types11.default.shape({
    color: import_prop_types11.default.string.isRequired,
    id: import_prop_types11.default.oneOfType([import_prop_types11.default.number, import_prop_types11.default.string]).isRequired,
    itemId: import_prop_types11.default.oneOfType([import_prop_types11.default.number, import_prop_types11.default.string]),
    label: import_prop_types11.default.string.isRequired,
    maxValue: import_prop_types11.default.oneOfType([import_prop_types11.default.instanceOf(Date), import_prop_types11.default.number]),
    minValue: import_prop_types11.default.oneOfType([import_prop_types11.default.instanceOf(Date), import_prop_types11.default.number]),
    seriesId: import_prop_types11.default.oneOfType([import_prop_types11.default.number, import_prop_types11.default.string])
  })).isRequired
} : void 0;

// node_modules/@mui/x-charts/ChartsLegend/ChartsLegend.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime());
var _excluded9 = ["slots", "slotProps"];
var useUtilityClasses5 = (ownerState) => {
  const {
    classes,
    direction
  } = ownerState;
  const slots = {
    root: ["root", direction],
    mark: ["mark"],
    label: ["label"],
    series: ["series"],
    itemBackground: ["itemBackground"]
  };
  return composeClasses(slots, getLegendUtilityClass, classes);
};
function ChartsLegend(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiChartsLegend"
  });
  const defaultizedProps = _extends({
    direction: "row"
  }, props, {
    position: _extends({
      horizontal: "middle",
      vertical: "top"
    }, props.position)
  });
  const {
    slots,
    slotProps
  } = defaultizedProps, other = _objectWithoutPropertiesLoose(defaultizedProps, _excluded9);
  const theme = useTheme();
  const classes = useUtilityClasses5(_extends({}, defaultizedProps, {
    theme
  }));
  const drawingArea = useDrawingArea();
  const series = useSeries();
  const seriesToDisplay = getSeriesToDisplay(series);
  const ChartLegendRender = (slots == null ? void 0 : slots.legend) ?? DefaultChartsLegend;
  const chartLegendRenderProps = useSlotProps_default({
    elementType: ChartLegendRender,
    externalSlotProps: slotProps == null ? void 0 : slotProps.legend,
    additionalProps: _extends({}, other, {
      classes,
      drawingArea,
      series,
      seriesToDisplay
    }),
    ownerState: {}
  });
  return (0, import_jsx_runtime20.jsx)(ChartLegendRender, _extends({}, chartLegendRenderProps));
}
true ? ChartsLegend.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types12.default.object,
  /**
   * The direction of the legend layout.
   * The default depends on the chart.
   */
  direction: import_prop_types12.default.oneOf(["column", "row"]),
  /**
   * Set to true to hide the legend.
   * @default false
   */
  hidden: import_prop_types12.default.bool,
  /**
   * Space between two legend items (in px).
   * @default 10
   */
  itemGap: import_prop_types12.default.number,
  /**
   * Height of the item mark (in px).
   * @default 20
   */
  itemMarkHeight: import_prop_types12.default.number,
  /**
   * Width of the item mark (in px).
   * @default 20
   */
  itemMarkWidth: import_prop_types12.default.number,
  /**
   * Style applied to legend labels.
   * @default theme.typography.subtitle1
   */
  labelStyle: import_prop_types12.default.object,
  /**
   * Space between the mark and the label (in px).
   * @default 5
   */
  markGap: import_prop_types12.default.number,
  /**
   * Callback fired when a legend item is clicked.
   * @param {React.MouseEvent<SVGRectElement, MouseEvent>} event The click event.
   * @param {SeriesLegendItemContext} legendItem The legend item data.
   * @param {number} index The index of the clicked legend item.
   */
  onItemClick: import_prop_types12.default.func,
  /**
   * Legend padding (in px).
   * Can either be a single number, or an object with top, left, bottom, right properties.
   * @default 10
   */
  padding: import_prop_types12.default.oneOfType([import_prop_types12.default.number, import_prop_types12.default.shape({
    bottom: import_prop_types12.default.number,
    left: import_prop_types12.default.number,
    right: import_prop_types12.default.number,
    top: import_prop_types12.default.number
  })]),
  /**
   * The position of the legend.
   */
  position: import_prop_types12.default.shape({
    horizontal: import_prop_types12.default.oneOf(["left", "middle", "right"]).isRequired,
    vertical: import_prop_types12.default.oneOf(["bottom", "middle", "top"]).isRequired
  }),
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types12.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types12.default.object
} : void 0;

// node_modules/@mui/x-charts/ChartsLegend/ContinuousColorLegend.js
init_extends();
var React26 = __toESM(require_react());
var import_prop_types13 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/internals/getPercentageValue.js
function getPercentageValue(value, refValue) {
  if (typeof value === "number") {
    return value;
  }
  if (value === "100%") {
    return refValue;
  }
  if (value.endsWith("%")) {
    const percentage = Number.parseFloat(value.slice(0, value.length - 1));
    if (!Number.isNaN(percentage)) {
      return percentage * refValue / 100;
    }
  }
  if (value.endsWith("px")) {
    const val = Number.parseFloat(value.slice(0, value.length - 2));
    if (!Number.isNaN(val)) {
      return val;
    }
  }
  throw new Error(`MUI X: Received an unknown value "${value}". It should be a number, or a string with a percentage value.`);
}

// node_modules/@mui/x-charts/ChartsLegend/useAxis.js
var React25 = __toESM(require_react());
function useAxis({
  axisDirection,
  axisId
}) {
  const {
    xAxis,
    xAxisIds,
    yAxis,
    yAxisIds
  } = useCartesianContext();
  const {
    zAxis,
    zAxisIds
  } = React25.useContext(ZAxisContext);
  switch (axisDirection) {
    case "x": {
      const id = typeof axisId === "string" ? axisId : xAxisIds[axisId ?? 0];
      return xAxis[id];
    }
    case "y": {
      const id = typeof axisId === "string" ? axisId : yAxisIds[axisId ?? 0];
      return yAxis[id];
    }
    case "z":
    default: {
      const id = typeof axisId === "string" ? axisId : zAxisIds[axisId ?? 0];
      return zAxis[id];
    }
  }
}

// node_modules/@mui/x-charts/ChartsLegend/ContinuousColorLegend.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime());
function getPositionOffset(position, legendBox, svgBox) {
  let offsetX = 0;
  let offsetY = 0;
  switch (position.horizontal) {
    case "left":
      offsetX = 0;
      break;
    case "middle":
      offsetX = (svgBox.width - legendBox.width) / 2;
      break;
    case "right":
    default:
      offsetX = svgBox.width - legendBox.width;
      break;
  }
  switch (position.vertical) {
    case "top":
      offsetY = 0;
      break;
    case "middle":
      offsetY = (svgBox.height - legendBox.height) / 2;
      break;
    case "bottom":
    default:
      offsetY = svgBox.height - legendBox.height;
      break;
  }
  return {
    offsetX,
    offsetY
  };
}
function getElementPositions(text1Box, barBox, text2Box, params) {
  if (params.direction === "column") {
    const text1 = {
      y: text1Box.height,
      dominantBaseline: "auto"
    };
    const text2 = {
      y: text1Box.height + 2 * params.spacing + barBox.height,
      dominantBaseline: "hanging"
    };
    const bar = {
      y: text1Box.height + params.spacing
    };
    const totalWidth = Math.max(text1Box.width, barBox.width, text2Box.width);
    const totalHeight = text1Box.height + barBox.height + text2Box.height + 2 * params.spacing;
    const boundingBox = {
      width: totalWidth,
      height: totalHeight
    };
    switch (params.align) {
      case "start":
        return {
          text1: _extends({}, text1, {
            textAnchor: "start",
            x: 0
          }),
          text2: _extends({}, text2, {
            textAnchor: "start",
            x: 0
          }),
          bar: _extends({}, bar, {
            x: 0
          }),
          boundingBox
        };
      case "end":
        return {
          text1: _extends({}, text1, {
            textAnchor: "end",
            x: totalWidth
          }),
          text2: _extends({}, text2, {
            textAnchor: "end",
            x: totalWidth
          }),
          bar: _extends({}, bar, {
            x: totalWidth - barBox.width
          }),
          boundingBox
        };
      case "middle":
      default:
        return {
          text1: _extends({}, text1, {
            textAnchor: "middle",
            x: totalWidth / 2
          }),
          text2: _extends({}, text2, {
            textAnchor: "middle",
            x: totalWidth / 2
          }),
          bar: _extends({}, bar, {
            x: totalWidth / 2 - barBox.width / 2
          }),
          boundingBox
        };
    }
  } else {
    const text1 = {
      x: text1Box.width,
      textAnchor: "end"
    };
    const text2 = {
      x: text1Box.width + 2 * params.spacing + barBox.width,
      textAnchor: "start"
    };
    const bar = {
      x: text1Box.width + params.spacing
    };
    const totalHeight = Math.max(text1Box.height, barBox.height, text2Box.height);
    const totalWidth = text1Box.width + barBox.width + text2Box.width + 2 * params.spacing;
    const boundingBox = {
      width: totalWidth,
      height: totalHeight
    };
    switch (params.align) {
      case "start":
        return {
          text1: _extends({}, text1, {
            dominantBaseline: "hanging",
            y: 0
          }),
          text2: _extends({}, text2, {
            dominantBaseline: "hanging",
            y: 0
          }),
          bar: _extends({}, bar, {
            y: 0
          }),
          boundingBox
        };
      case "end":
        return {
          text1: _extends({}, text1, {
            dominantBaseline: "auto",
            y: totalHeight
          }),
          text2: _extends({}, text2, {
            dominantBaseline: "auto",
            y: totalHeight
          }),
          bar: _extends({}, bar, {
            y: totalHeight - barBox.height
          }),
          boundingBox
        };
      case "middle":
      default:
        return {
          text1: _extends({}, text1, {
            dominantBaseline: "central",
            y: totalHeight / 2
          }),
          text2: _extends({}, text2, {
            dominantBaseline: "central",
            y: totalHeight / 2
          }),
          bar: _extends({}, bar, {
            y: totalHeight / 2 - barBox.height / 2
          }),
          boundingBox
        };
    }
  }
}
var defaultLabelFormatter = ({
  formattedValue
}) => formattedValue;
function ContinuousColorLegend(props) {
  var _a, _b;
  const theme = useTheme();
  const isRtl = useRtl();
  const {
    id: idProp,
    minLabel = defaultLabelFormatter,
    maxLabel = defaultLabelFormatter,
    scaleType = "linear",
    direction,
    length = "50%",
    thickness = 5,
    spacing = 4,
    align = "middle",
    labelStyle = theme.typography.subtitle1,
    position,
    axisDirection,
    axisId
  } = props;
  const chartId = useChartId();
  const id = idProp ?? `gradient-legend-${chartId}`;
  const axisItem = useAxis({
    axisDirection,
    axisId
  });
  const {
    width,
    height,
    left,
    right,
    top,
    bottom
  } = useDrawingArea();
  const refLength = direction === "column" ? height + top + bottom : width + left + right;
  const size = getPercentageValue(length, refLength);
  const isReversed = direction === "column";
  const colorMap = axisItem == null ? void 0 : axisItem.colorMap;
  if (!colorMap || !colorMap.type || colorMap.type !== "continuous") {
    return null;
  }
  const colorScale = axisItem.colorScale;
  const minValue = colorMap.min ?? 0;
  const maxValue = colorMap.max ?? 100;
  const scale2 = getScale(scaleType, [minValue, maxValue], isReversed ? [size, 0] : [0, size]);
  const formattedMin = ((_a = axisItem.valueFormatter) == null ? void 0 : _a.call(axisItem, minValue, {
    location: "legend"
  })) ?? minValue.toLocaleString();
  const formattedMax = ((_b = axisItem.valueFormatter) == null ? void 0 : _b.call(axisItem, maxValue, {
    location: "legend"
  })) ?? maxValue.toLocaleString();
  const minText = typeof minLabel === "string" ? minLabel : minLabel({
    value: minValue ?? 0,
    formattedValue: formattedMin
  });
  const maxText = typeof maxLabel === "string" ? maxLabel : maxLabel({
    value: maxValue ?? 0,
    formattedValue: formattedMax
  });
  const text1 = isReversed ? maxText : minText;
  const text2 = isReversed ? minText : maxText;
  const text1Box = getStringSize(text1, _extends({}, labelStyle));
  const text2Box = getStringSize(text2, _extends({}, labelStyle));
  const barBox = direction === "column" || isRtl && direction === "row" ? {
    width: thickness,
    height: size
  } : {
    width: size,
    height: thickness
  };
  const legendPositions = getElementPositions(text1Box, barBox, text2Box, {
    spacing,
    align,
    direction
  });
  const svgBoundingBox = {
    width: width + left + right,
    height: height + top + bottom
  };
  const positionOffset = getPositionOffset(_extends({
    horizontal: "middle",
    vertical: "top"
  }, position), legendPositions.boundingBox, svgBoundingBox);
  return (0, import_jsx_runtime21.jsxs)(React26.Fragment, {
    children: [(0, import_jsx_runtime21.jsx)(ChartsContinuousGradient, {
      isReversed,
      gradientId: id,
      size,
      direction: direction === "row" ? "x" : "y",
      scale: scale2,
      colorScale,
      colorMap,
      gradientUnits: "objectBoundingBox"
    }), (0, import_jsx_runtime21.jsx)(ChartsText, {
      text: text1,
      x: positionOffset.offsetX + legendPositions.text1.x,
      y: positionOffset.offsetY + legendPositions.text1.y,
      style: _extends({
        dominantBaseline: legendPositions.text1.dominantBaseline,
        textAnchor: legendPositions.text1.textAnchor
      }, labelStyle)
    }), (0, import_jsx_runtime21.jsx)("rect", _extends({
      x: positionOffset.offsetX + legendPositions.bar.x,
      y: positionOffset.offsetY + legendPositions.bar.y
    }, barBox, {
      fill: `url(#${id})`
    })), (0, import_jsx_runtime21.jsx)(ChartsText, {
      text: text2,
      x: positionOffset.offsetX + legendPositions.text2.x,
      y: positionOffset.offsetY + legendPositions.text2.y,
      style: _extends({
        dominantBaseline: legendPositions.text2.dominantBaseline,
        textAnchor: legendPositions.text2.textAnchor
      }, labelStyle)
    })]
  });
}
true ? ContinuousColorLegend.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The alignment of the texts with the gradient bar.
   * @default 'middle'
   */
  align: import_prop_types13.default.oneOf(["end", "middle", "start"]),
  /**
   * The axis direction containing the color configuration to represent.
   * @default 'z'
   */
  axisDirection: import_prop_types13.default.oneOf(["x", "y", "z"]),
  /**
   * The id of the axis item with the color configuration to represent.
   * @default The first axis item.
   */
  axisId: import_prop_types13.default.oneOfType([import_prop_types13.default.number, import_prop_types13.default.string]),
  /**
   * The direction of the legend layout.
   * The default depends on the chart.
   */
  direction: import_prop_types13.default.oneOf(["column", "row"]),
  /**
   * A unique identifier for the gradient.
   * @default auto-generated id
   */
  id: import_prop_types13.default.string,
  /**
   * The style applied to labels.
   * @default theme.typography.subtitle1
   */
  labelStyle: import_prop_types13.default.object,
  /**
   * The length of the gradient bar.
   * Can be a number (in px) or a string with a percentage such as '50%'.
   * The '100%' is the length of the svg.
   * @default '50%'
   */
  length: import_prop_types13.default.oneOfType([import_prop_types13.default.number, import_prop_types13.default.string]),
  /**
   * The label to display at the maximum side of the gradient.
   * Can either be a string, or a function.
   * If not defined, the formatted maximal value is display.
   * @default ({ formattedValue }) => formattedValue
   */
  maxLabel: import_prop_types13.default.oneOfType([import_prop_types13.default.func, import_prop_types13.default.string]),
  /**
   * The label to display at the minimum side of the gradient.
   * Can either be a string, or a function.
   * @default ({ formattedValue }) => formattedValue
   */
  minLabel: import_prop_types13.default.oneOfType([import_prop_types13.default.func, import_prop_types13.default.string]),
  /**
   * The position of the legend.
   */
  position: import_prop_types13.default.shape({
    horizontal: import_prop_types13.default.oneOf(["left", "middle", "right"]).isRequired,
    vertical: import_prop_types13.default.oneOf(["bottom", "middle", "top"]).isRequired
  }),
  /**
   * The scale used to display gradient colors.
   * @default 'linear'
   */
  scaleType: import_prop_types13.default.oneOf(["linear", "log", "pow", "sqrt", "time", "utc"]),
  /**
   * The space between the gradient bar and the labels.
   * @default 4
   */
  spacing: import_prop_types13.default.number,
  /**
   * The thickness of the gradient bar.
   * @default 5
   */
  thickness: import_prop_types13.default.number
} : void 0;

// node_modules/@mui/x-charts/ChartsLegend/PiecewiseColorLegend.js
init_extends();
var React27 = __toESM(require_react());
var import_prop_types14 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/internals/notNull.js
function notNull(value) {
  return value !== null;
}

// node_modules/@mui/x-charts/ChartsLegend/PiecewiseColorLegend.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime());
var _excluded10 = ["axisDirection", "axisId", "hideFirst", "hideLast", "labelFormatter", "onItemClick"];
function defaultLabelFormatter2(params) {
  if (params.min === null) {
    return `<${params.formattedMax}`;
  }
  if (params.max === null) {
    return `>${params.formattedMin}`;
  }
  return `${params.formattedMin}-${params.formattedMax}`;
}
var piecewiseColorContextBuilder = (context) => ({
  type: "piecewiseColor",
  color: context.color,
  label: context.label,
  maxValue: context.maxValue,
  minValue: context.minValue
});
function PiecewiseColorLegend(props) {
  const {
    axisDirection,
    axisId,
    hideFirst,
    hideLast,
    labelFormatter = defaultLabelFormatter2,
    onItemClick
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded10);
  const axisItem = useAxis({
    axisDirection,
    axisId
  });
  const colorMap = axisItem == null ? void 0 : axisItem.colorMap;
  if (!colorMap || !colorMap.type || colorMap.type !== "piecewise") {
    return null;
  }
  const valueFormatter = (v2) => {
    var _a;
    return ((_a = axisItem.valueFormatter) == null ? void 0 : _a.call(axisItem, v2, {
      location: "legend"
    })) ?? v2.toLocaleString();
  };
  const formattedLabels = colorMap.thresholds.map(valueFormatter);
  const itemsToDisplay = colorMap.colors.map((color2, index) => {
    const isFirst = index === 0;
    const isLast = index === colorMap.colors.length - 1;
    if (hideFirst && isFirst || hideLast && isLast) {
      return null;
    }
    const data = _extends({}, isFirst ? {
      min: null,
      formattedMin: null
    } : {
      min: colorMap.thresholds[index - 1],
      formattedMin: formattedLabels[index - 1]
    }, isLast ? {
      max: null,
      formattedMax: null
    } : {
      max: colorMap.thresholds[index],
      formattedMax: formattedLabels[index]
    });
    const label = labelFormatter(data);
    if (label === null) {
      return null;
    }
    return {
      id: label,
      color: color2,
      label,
      minValue: data.min,
      maxValue: data.max
    };
  }).filter(notNull);
  return (0, import_jsx_runtime22.jsx)(LegendPerItem, _extends({}, other, {
    itemsToDisplay,
    onItemClick: onItemClick ? (event, i) => onItemClick(event, piecewiseColorContextBuilder(itemsToDisplay[i]), i) : void 0
  }));
}
true ? PiecewiseColorLegend.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The axis direction containing the color configuration to represent.
   * @default 'z'
   */
  axisDirection: import_prop_types14.default.oneOf(["x", "y", "z"]),
  /**
   * The id of the axis item with the color configuration to represent.
   * @default The first axis item.
   */
  axisId: import_prop_types14.default.oneOfType([import_prop_types14.default.number, import_prop_types14.default.string]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types14.default.object,
  /**
   * The direction of the legend layout.
   * The default depends on the chart.
   */
  direction: import_prop_types14.default.oneOf(["column", "row"]).isRequired,
  /**
   * Hide the first item of the legend, corresponding to the [-infinity, min] piece.
   * @default false
   */
  hideFirst: import_prop_types14.default.bool,
  /**
   * Hide the last item of the legend, corresponding to the [max, +infinity] piece.
   * @default false
   */
  hideLast: import_prop_types14.default.bool,
  /**
   * Space between two legend items (in px).
   * @default 10
   */
  itemGap: import_prop_types14.default.number,
  /**
   * Height of the item mark (in px).
   * @default 20
   */
  itemMarkHeight: import_prop_types14.default.number,
  /**
   * Width of the item mark (in px).
   * @default 20
   */
  itemMarkWidth: import_prop_types14.default.number,
  /**
   * Format the legend labels.
   * @param {PiecewiseLabelFormatterParams} params The bound of the piece to format.
   * @returns {string|null} The displayed label, or `null` to skip the item.
   */
  labelFormatter: import_prop_types14.default.func,
  /**
   * Style applied to legend labels.
   * @default theme.typography.subtitle1
   */
  labelStyle: import_prop_types14.default.object,
  /**
   * Space between the mark and the label (in px).
   * @default 5
   */
  markGap: import_prop_types14.default.number,
  /**
   * Callback fired when a legend item is clicked.
   * @param {React.MouseEvent<SVGRectElement, MouseEvent>} event The click event.
   * @param {PiecewiseColorLegendItemContext} legendItem The legend item data.
   * @param {number} index The index of the clicked legend item.
   */
  onItemClick: import_prop_types14.default.func,
  /**
   * Legend padding (in px).
   * Can either be a single number, or an object with top, left, bottom, right properties.
   * @default 10
   */
  padding: import_prop_types14.default.oneOfType([import_prop_types14.default.number, import_prop_types14.default.shape({
    bottom: import_prop_types14.default.number,
    left: import_prop_types14.default.number,
    right: import_prop_types14.default.number,
    top: import_prop_types14.default.number
  })]),
  /**
   * The position of the legend.
   */
  position: import_prop_types14.default.shape({
    horizontal: import_prop_types14.default.oneOf(["left", "middle", "right"]).isRequired,
    vertical: import_prop_types14.default.oneOf(["bottom", "middle", "top"]).isRequired
  }).isRequired
} : void 0;

// node_modules/@mui/x-charts/ChartsAxisHighlight/ChartsAxisHighlight.js
init_extends();
var React28 = __toESM(require_react());
var import_prop_types15 = __toESM(require_prop_types());
var import_jsx_runtime23 = __toESM(require_jsx_runtime());
function getAxisHighlightUtilityClass(slot) {
  return generateUtilityClass("MuiChartsAxisHighlight", slot);
}
var chartsAxisHighlightClasses = generateUtilityClasses("MuiChartsAxisHighlight", ["root"]);
var useUtilityClasses6 = () => {
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getAxisHighlightUtilityClass);
};
var ChartsAxisHighlightPath = styled_default("path", {
  name: "MuiChartsAxisHighlight",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})(({
  theme
}) => ({
  pointerEvents: "none",
  variants: [{
    props: {
      axisHighlight: "band"
    },
    style: _extends({
      fill: "white",
      fillOpacity: 0.1
    }, theme.applyStyles("light", {
      fill: "gray"
    }))
  }, {
    props: {
      axisHighlight: "line"
    },
    style: _extends({
      strokeDasharray: "5 2",
      stroke: "#ffffff"
    }, theme.applyStyles("light", {
      stroke: "#000000"
    }))
  }]
}));
function ChartsAxisHighlight(props) {
  const {
    x: xAxisHighlight,
    y: yAxisHighlight
  } = props;
  const {
    xAxisIds,
    xAxis,
    yAxisIds,
    yAxis
  } = useCartesianContext();
  const classes = useUtilityClasses6();
  const USED_X_AXIS_ID = xAxisIds[0];
  const USED_Y_AXIS_ID = yAxisIds[0];
  const xScale = xAxis[USED_X_AXIS_ID].scale;
  const yScale = yAxis[USED_Y_AXIS_ID].scale;
  const {
    axis
  } = React28.useContext(InteractionContext);
  const getXPosition = getValueToPositionMapper(xScale);
  const getYPosition = getValueToPositionMapper(yScale);
  const axisX = axis.x;
  const axisY = axis.y;
  const isBandScaleX = xAxisHighlight === "band" && axisX !== null && isBandScale(xScale);
  const isBandScaleY = yAxisHighlight === "band" && axisY !== null && isBandScale(yScale);
  if (true) {
    const isXError = isBandScaleX && xScale(axisX.value) === void 0;
    const isYError = isBandScaleY && yScale(axisY.value) === void 0;
    if (isXError || isYError) {
      console.error([`MUI X: The position value provided for the axis is not valid for the current scale.`, `This probably means something is wrong with the data passed to the chart.`, `The ChartsAxisHighlight component will not be displayed.`].join("\n"));
    }
  }
  return (0, import_jsx_runtime23.jsxs)(React28.Fragment, {
    children: [isBandScaleX && xScale(axisX.value) !== void 0 && (0, import_jsx_runtime23.jsx)(
      ChartsAxisHighlightPath,
      {
        d: `M ${xScale(axisX.value) - (xScale.step() - xScale.bandwidth()) / 2} ${yScale.range()[0]} l ${xScale.step()} 0 l 0 ${yScale.range()[1] - yScale.range()[0]} l ${-xScale.step()} 0 Z`,
        className: classes.root,
        ownerState: {
          axisHighlight: "band"
        }
      }
    ), isBandScaleY && yScale(axisY.value) !== void 0 && (0, import_jsx_runtime23.jsx)(ChartsAxisHighlightPath, {
      d: `M ${xScale.range()[0]} ${// @ts-expect-error, yScale value is checked in the statement above
      yScale(axisY.value) - (yScale.step() - yScale.bandwidth()) / 2} l 0 ${yScale.step()} l ${xScale.range()[1] - xScale.range()[0]} 0 l 0 ${-yScale.step()} Z`,
      className: classes.root,
      ownerState: {
        axisHighlight: "band"
      }
    }), xAxisHighlight === "line" && axis.x !== null && (0, import_jsx_runtime23.jsx)(ChartsAxisHighlightPath, {
      d: `M ${getXPosition(axis.x.value)} ${yScale.range()[0]} L ${getXPosition(axis.x.value)} ${yScale.range()[1]}`,
      className: classes.root,
      ownerState: {
        axisHighlight: "line"
      }
    }), yAxisHighlight === "line" && axis.y !== null && (0, import_jsx_runtime23.jsx)(ChartsAxisHighlightPath, {
      d: `M ${xScale.range()[0]} ${getYPosition(axis.y.value)} L ${xScale.range()[1]} ${getYPosition(axis.y.value)}`,
      className: classes.root,
      ownerState: {
        axisHighlight: "line"
      }
    })]
  });
}
true ? ChartsAxisHighlight.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  x: import_prop_types15.default.oneOf(["band", "line", "none"]),
  y: import_prop_types15.default.oneOf(["band", "line", "none"])
} : void 0;

// node_modules/@mui/x-charts/ChartsVoronoiHandler/ChartsVoronoiHandler.js
var React29 = __toESM(require_react());
var import_prop_types16 = __toESM(require_prop_types());

// node_modules/robust-predicates/esm/util.js
var epsilon = 11102230246251565e-32;
var splitter = 134217729;
var resulterrbound = (3 + 8 * epsilon) * epsilon;
function sum(elen, e, flen, f, h) {
  let Q, Qnew, hh, bvirt;
  let enow = e[0];
  let fnow = f[0];
  let eindex = 0;
  let findex = 0;
  if (fnow > enow === fnow > -enow) {
    Q = enow;
    enow = e[++eindex];
  } else {
    Q = fnow;
    fnow = f[++findex];
  }
  let hindex = 0;
  if (eindex < elen && findex < flen) {
    if (fnow > enow === fnow > -enow) {
      Qnew = enow + Q;
      hh = Q - (Qnew - enow);
      enow = e[++eindex];
    } else {
      Qnew = fnow + Q;
      hh = Q - (Qnew - fnow);
      fnow = f[++findex];
    }
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
    while (eindex < elen && findex < flen) {
      if (fnow > enow === fnow > -enow) {
        Qnew = Q + enow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (enow - bvirt);
        enow = e[++eindex];
      } else {
        Qnew = Q + fnow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (fnow - bvirt);
        fnow = f[++findex];
      }
      Q = Qnew;
      if (hh !== 0) {
        h[hindex++] = hh;
      }
    }
  }
  while (eindex < elen) {
    Qnew = Q + enow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (enow - bvirt);
    enow = e[++eindex];
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
  }
  while (findex < flen) {
    Qnew = Q + fnow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (fnow - bvirt);
    fnow = f[++findex];
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
  }
  if (Q !== 0 || hindex === 0) {
    h[hindex++] = Q;
  }
  return hindex;
}
function estimate(elen, e) {
  let Q = e[0];
  for (let i = 1; i < elen; i++) Q += e[i];
  return Q;
}
function vec(n) {
  return new Float64Array(n);
}

// node_modules/robust-predicates/esm/orient2d.js
var ccwerrboundA = (3 + 16 * epsilon) * epsilon;
var ccwerrboundB = (2 + 12 * epsilon) * epsilon;
var ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;
var B = vec(4);
var C1 = vec(8);
var C2 = vec(12);
var D = vec(16);
var u = vec(4);
function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
  let acxtail, acytail, bcxtail, bcytail;
  let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u32;
  const acx = ax - cx;
  const bcx = bx - cx;
  const acy = ay - cy;
  const bcy = by - cy;
  s1 = acx * bcy;
  c = splitter * acx;
  ahi = c - (c - acx);
  alo = acx - ahi;
  c = splitter * bcy;
  bhi = c - (c - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acy * bcx;
  c = splitter * acy;
  ahi = c - (c - acy);
  alo = acy - ahi;
  c = splitter * bcx;
  bhi = c - (c - bcx);
  blo = bcx - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  B[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  B[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  B[2] = _j - (u32 - bvirt) + (_i - bvirt);
  B[3] = u32;
  let det = estimate(4, B);
  let errbound = ccwerrboundB * detsum;
  if (det >= errbound || -det >= errbound) {
    return det;
  }
  bvirt = ax - acx;
  acxtail = ax - (acx + bvirt) + (bvirt - cx);
  bvirt = bx - bcx;
  bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
  bvirt = ay - acy;
  acytail = ay - (acy + bvirt) + (bvirt - cy);
  bvirt = by - bcy;
  bcytail = by - (bcy + bvirt) + (bvirt - cy);
  if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
    return det;
  }
  errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
  det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
  if (det >= errbound || -det >= errbound) return det;
  s1 = acxtail * bcy;
  c = splitter * acxtail;
  ahi = c - (c - acxtail);
  alo = acxtail - ahi;
  c = splitter * bcy;
  bhi = c - (c - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acytail * bcx;
  c = splitter * acytail;
  ahi = c - (c - acytail);
  alo = acytail - ahi;
  c = splitter * bcx;
  bhi = c - (c - bcx);
  blo = bcx - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const C1len = sum(4, B, 4, u, C1);
  s1 = acx * bcytail;
  c = splitter * acx;
  ahi = c - (c - acx);
  alo = acx - ahi;
  c = splitter * bcytail;
  bhi = c - (c - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acy * bcxtail;
  c = splitter * acy;
  ahi = c - (c - acy);
  alo = acy - ahi;
  c = splitter * bcxtail;
  bhi = c - (c - bcxtail);
  blo = bcxtail - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const C2len = sum(C1len, C1, 4, u, C2);
  s1 = acxtail * bcytail;
  c = splitter * acxtail;
  ahi = c - (c - acxtail);
  alo = acxtail - ahi;
  c = splitter * bcytail;
  bhi = c - (c - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acytail * bcxtail;
  c = splitter * acytail;
  ahi = c - (c - acytail);
  alo = acytail - ahi;
  c = splitter * bcxtail;
  bhi = c - (c - bcxtail);
  blo = bcxtail - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const Dlen = sum(C2len, C2, 4, u, D);
  return D[Dlen - 1];
}
function orient2d(ax, ay, bx, by, cx, cy) {
  const detleft = (ay - cy) * (bx - cx);
  const detright = (ax - cx) * (by - cy);
  const det = detleft - detright;
  const detsum = Math.abs(detleft + detright);
  if (Math.abs(det) >= ccwerrboundA * detsum) return det;
  return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
}

// node_modules/robust-predicates/esm/orient3d.js
var o3derrboundA = (7 + 56 * epsilon) * epsilon;
var o3derrboundB = (3 + 28 * epsilon) * epsilon;
var o3derrboundC = (26 + 288 * epsilon) * epsilon * epsilon;
var bc = vec(4);
var ca = vec(4);
var ab = vec(4);
var at_b = vec(4);
var at_c = vec(4);
var bt_c = vec(4);
var bt_a = vec(4);
var ct_a = vec(4);
var ct_b = vec(4);
var bct = vec(8);
var cat = vec(8);
var abt = vec(8);
var u2 = vec(4);
var _8 = vec(8);
var _8b = vec(8);
var _16 = vec(8);
var _12 = vec(12);
var fin = vec(192);
var fin2 = vec(192);

// node_modules/robust-predicates/esm/incircle.js
var iccerrboundA = (10 + 96 * epsilon) * epsilon;
var iccerrboundB = (4 + 48 * epsilon) * epsilon;
var iccerrboundC = (44 + 576 * epsilon) * epsilon * epsilon;
var bc2 = vec(4);
var ca2 = vec(4);
var ab2 = vec(4);
var aa = vec(4);
var bb = vec(4);
var cc = vec(4);
var u3 = vec(4);
var v = vec(4);
var axtbc = vec(8);
var aytbc = vec(8);
var bxtca = vec(8);
var bytca = vec(8);
var cxtab = vec(8);
var cytab = vec(8);
var abt2 = vec(8);
var bct2 = vec(8);
var cat2 = vec(8);
var abtt = vec(4);
var bctt = vec(4);
var catt = vec(4);
var _82 = vec(8);
var _162 = vec(16);
var _16b = vec(16);
var _16c = vec(16);
var _32 = vec(32);
var _32b = vec(32);
var _48 = vec(48);
var _64 = vec(64);
var fin3 = vec(1152);
var fin22 = vec(1152);

// node_modules/robust-predicates/esm/insphere.js
var isperrboundA = (16 + 224 * epsilon) * epsilon;
var isperrboundB = (5 + 72 * epsilon) * epsilon;
var isperrboundC = (71 + 1408 * epsilon) * epsilon * epsilon;
var ab3 = vec(4);
var bc3 = vec(4);
var cd = vec(4);
var de = vec(4);
var ea = vec(4);
var ac = vec(4);
var bd = vec(4);
var ce = vec(4);
var da = vec(4);
var eb = vec(4);
var abc = vec(24);
var bcd = vec(24);
var cde = vec(24);
var dea = vec(24);
var eab = vec(24);
var abd = vec(24);
var bce = vec(24);
var cda = vec(24);
var deb = vec(24);
var eac = vec(24);
var adet = vec(1152);
var bdet = vec(1152);
var cdet = vec(1152);
var ddet = vec(1152);
var edet = vec(1152);
var abdet = vec(2304);
var cddet = vec(2304);
var cdedet = vec(3456);
var deter = vec(5760);
var _83 = vec(8);
var _8b2 = vec(8);
var _8c = vec(8);
var _163 = vec(16);
var _24 = vec(24);
var _482 = vec(48);
var _48b = vec(48);
var _96 = vec(96);
var _192 = vec(192);
var _384x = vec(384);
var _384y = vec(384);
var _384z = vec(384);
var _768 = vec(768);
var xdet = vec(96);
var ydet = vec(96);
var zdet = vec(96);
var fin4 = vec(1152);

// node_modules/delaunator/index.js
var EPSILON = Math.pow(2, -52);
var EDGE_STACK = new Uint32Array(512);
var Delaunator = class _Delaunator {
  static from(points, getX = defaultGetX, getY = defaultGetY) {
    const n = points.length;
    const coords = new Float64Array(n * 2);
    for (let i = 0; i < n; i++) {
      const p = points[i];
      coords[2 * i] = getX(p);
      coords[2 * i + 1] = getY(p);
    }
    return new _Delaunator(coords);
  }
  constructor(coords) {
    const n = coords.length >> 1;
    if (n > 0 && typeof coords[0] !== "number") throw new Error("Expected coords to contain numbers.");
    this.coords = coords;
    const maxTriangles = Math.max(2 * n - 5, 0);
    this._triangles = new Uint32Array(maxTriangles * 3);
    this._halfedges = new Int32Array(maxTriangles * 3);
    this._hashSize = Math.ceil(Math.sqrt(n));
    this._hullPrev = new Uint32Array(n);
    this._hullNext = new Uint32Array(n);
    this._hullTri = new Uint32Array(n);
    this._hullHash = new Int32Array(this._hashSize);
    this._ids = new Uint32Array(n);
    this._dists = new Float64Array(n);
    this.update();
  }
  update() {
    const { coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash } = this;
    const n = coords.length >> 1;
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    for (let i = 0; i < n; i++) {
      const x = coords[2 * i];
      const y = coords[2 * i + 1];
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
      this._ids[i] = i;
    }
    const cx = (minX + maxX) / 2;
    const cy = (minY + maxY) / 2;
    let i0, i1, i2;
    for (let i = 0, minDist = Infinity; i < n; i++) {
      const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
      if (d < minDist) {
        i0 = i;
        minDist = d;
      }
    }
    const i0x = coords[2 * i0];
    const i0y = coords[2 * i0 + 1];
    for (let i = 0, minDist = Infinity; i < n; i++) {
      if (i === i0) continue;
      const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
      if (d < minDist && d > 0) {
        i1 = i;
        minDist = d;
      }
    }
    let i1x = coords[2 * i1];
    let i1y = coords[2 * i1 + 1];
    let minRadius = Infinity;
    for (let i = 0; i < n; i++) {
      if (i === i0 || i === i1) continue;
      const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
      if (r < minRadius) {
        i2 = i;
        minRadius = r;
      }
    }
    let i2x = coords[2 * i2];
    let i2y = coords[2 * i2 + 1];
    if (minRadius === Infinity) {
      for (let i = 0; i < n; i++) {
        this._dists[i] = coords[2 * i] - coords[0] || coords[2 * i + 1] - coords[1];
      }
      quicksort(this._ids, this._dists, 0, n - 1);
      const hull = new Uint32Array(n);
      let j = 0;
      for (let i = 0, d0 = -Infinity; i < n; i++) {
        const id = this._ids[i];
        const d = this._dists[id];
        if (d > d0) {
          hull[j++] = id;
          d0 = d;
        }
      }
      this.hull = hull.subarray(0, j);
      this.triangles = new Uint32Array(0);
      this.halfedges = new Uint32Array(0);
      return;
    }
    if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
      const i = i1;
      const x = i1x;
      const y = i1y;
      i1 = i2;
      i1x = i2x;
      i1y = i2y;
      i2 = i;
      i2x = x;
      i2y = y;
    }
    const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
    this._cx = center.x;
    this._cy = center.y;
    for (let i = 0; i < n; i++) {
      this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);
    }
    quicksort(this._ids, this._dists, 0, n - 1);
    this._hullStart = i0;
    let hullSize = 3;
    hullNext[i0] = hullPrev[i2] = i1;
    hullNext[i1] = hullPrev[i0] = i2;
    hullNext[i2] = hullPrev[i1] = i0;
    hullTri[i0] = 0;
    hullTri[i1] = 1;
    hullTri[i2] = 2;
    hullHash.fill(-1);
    hullHash[this._hashKey(i0x, i0y)] = i0;
    hullHash[this._hashKey(i1x, i1y)] = i1;
    hullHash[this._hashKey(i2x, i2y)] = i2;
    this.trianglesLen = 0;
    this._addTriangle(i0, i1, i2, -1, -1, -1);
    for (let k = 0, xp, yp; k < this._ids.length; k++) {
      const i = this._ids[k];
      const x = coords[2 * i];
      const y = coords[2 * i + 1];
      if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;
      xp = x;
      yp = y;
      if (i === i0 || i === i1 || i === i2) continue;
      let start = 0;
      for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {
        start = hullHash[(key + j) % this._hashSize];
        if (start !== -1 && start !== hullNext[start]) break;
      }
      start = hullPrev[start];
      let e = start, q;
      while (q = hullNext[e], orient2d(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {
        e = q;
        if (e === start) {
          e = -1;
          break;
        }
      }
      if (e === -1) continue;
      let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);
      hullTri[i] = this._legalize(t + 2);
      hullTri[e] = t;
      hullSize++;
      let n2 = hullNext[e];
      while (q = hullNext[n2], orient2d(x, y, coords[2 * n2], coords[2 * n2 + 1], coords[2 * q], coords[2 * q + 1]) < 0) {
        t = this._addTriangle(n2, i, q, hullTri[i], -1, hullTri[n2]);
        hullTri[i] = this._legalize(t + 2);
        hullNext[n2] = n2;
        hullSize--;
        n2 = q;
      }
      if (e === start) {
        while (q = hullPrev[e], orient2d(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {
          t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
          this._legalize(t + 2);
          hullTri[q] = t;
          hullNext[e] = e;
          hullSize--;
          e = q;
        }
      }
      this._hullStart = hullPrev[i] = e;
      hullNext[e] = hullPrev[n2] = i;
      hullNext[i] = n2;
      hullHash[this._hashKey(x, y)] = i;
      hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
    }
    this.hull = new Uint32Array(hullSize);
    for (let i = 0, e = this._hullStart; i < hullSize; i++) {
      this.hull[i] = e;
      e = hullNext[e];
    }
    this.triangles = this._triangles.subarray(0, this.trianglesLen);
    this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
  }
  _hashKey(x, y) {
    return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;
  }
  _legalize(a) {
    const { _triangles: triangles, _halfedges: halfedges, coords } = this;
    let i = 0;
    let ar = 0;
    while (true) {
      const b = halfedges[a];
      const a0 = a - a % 3;
      ar = a0 + (a + 2) % 3;
      if (b === -1) {
        if (i === 0) break;
        a = EDGE_STACK[--i];
        continue;
      }
      const b0 = b - b % 3;
      const al = a0 + (a + 1) % 3;
      const bl = b0 + (b + 2) % 3;
      const p0 = triangles[ar];
      const pr = triangles[a];
      const pl = triangles[al];
      const p1 = triangles[bl];
      const illegal = inCircle(
        coords[2 * p0],
        coords[2 * p0 + 1],
        coords[2 * pr],
        coords[2 * pr + 1],
        coords[2 * pl],
        coords[2 * pl + 1],
        coords[2 * p1],
        coords[2 * p1 + 1]
      );
      if (illegal) {
        triangles[a] = p1;
        triangles[b] = p0;
        const hbl = halfedges[bl];
        if (hbl === -1) {
          let e = this._hullStart;
          do {
            if (this._hullTri[e] === bl) {
              this._hullTri[e] = a;
              break;
            }
            e = this._hullPrev[e];
          } while (e !== this._hullStart);
        }
        this._link(a, hbl);
        this._link(b, halfedges[ar]);
        this._link(ar, bl);
        const br = b0 + (b + 1) % 3;
        if (i < EDGE_STACK.length) {
          EDGE_STACK[i++] = br;
        }
      } else {
        if (i === 0) break;
        a = EDGE_STACK[--i];
      }
    }
    return ar;
  }
  _link(a, b) {
    this._halfedges[a] = b;
    if (b !== -1) this._halfedges[b] = a;
  }
  // add a new triangle given vertex indices and adjacent half-edge ids
  _addTriangle(i0, i1, i2, a, b, c) {
    const t = this.trianglesLen;
    this._triangles[t] = i0;
    this._triangles[t + 1] = i1;
    this._triangles[t + 2] = i2;
    this._link(t, a);
    this._link(t + 1, b);
    this._link(t + 2, c);
    this.trianglesLen += 3;
    return t;
  }
};
function pseudoAngle(dx, dy) {
  const p = dx / (Math.abs(dx) + Math.abs(dy));
  return (dy > 0 ? 3 - p : 1 + p) / 4;
}
function dist(ax, ay, bx, by) {
  const dx = ax - bx;
  const dy = ay - by;
  return dx * dx + dy * dy;
}
function inCircle(ax, ay, bx, by, cx, cy, px, py) {
  const dx = ax - px;
  const dy = ay - py;
  const ex = bx - px;
  const ey = by - py;
  const fx = cx - px;
  const fy = cy - py;
  const ap = dx * dx + dy * dy;
  const bp = ex * ex + ey * ey;
  const cp = fx * fx + fy * fy;
  return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
}
function circumradius(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x = (ey * bl - dy * cl) * d;
  const y = (dx * cl - ex * bl) * d;
  return x * x + y * y;
}
function circumcenter(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x = ax + (ey * bl - dy * cl) * d;
  const y = ay + (dx * cl - ex * bl) * d;
  return { x, y };
}
function quicksort(ids, dists, left, right) {
  if (right - left <= 20) {
    for (let i = left + 1; i <= right; i++) {
      const temp = ids[i];
      const tempDist = dists[temp];
      let j = i - 1;
      while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];
      ids[j + 1] = temp;
    }
  } else {
    const median = left + right >> 1;
    let i = left + 1;
    let j = right;
    swap(ids, median, i);
    if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);
    if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);
    if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);
    const temp = ids[i];
    const tempDist = dists[temp];
    while (true) {
      do
        i++;
      while (dists[ids[i]] < tempDist);
      do
        j--;
      while (dists[ids[j]] > tempDist);
      if (j < i) break;
      swap(ids, i, j);
    }
    ids[left + 1] = ids[j];
    ids[j] = temp;
    if (right - i + 1 >= j - left) {
      quicksort(ids, dists, i, right);
      quicksort(ids, dists, left, j - 1);
    } else {
      quicksort(ids, dists, left, j - 1);
      quicksort(ids, dists, i, right);
    }
  }
}
function swap(arr, i, j) {
  const tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
function defaultGetX(p) {
  return p[0];
}
function defaultGetY(p) {
  return p[1];
}

// node_modules/d3-delaunay/src/path.js
var epsilon2 = 1e-6;
var Path = class {
  constructor() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
  }
  moveTo(x, y) {
    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  }
  lineTo(x, y) {
    this._ += `L${this._x1 = +x},${this._y1 = +y}`;
  }
  arc(x, y, r) {
    x = +x, y = +y, r = +r;
    const x0 = x + r;
    const y0 = y;
    if (r < 0) throw new Error("negative radius");
    if (this._x1 === null) this._ += `M${x0},${y0}`;
    else if (Math.abs(this._x1 - x0) > epsilon2 || Math.abs(this._y1 - y0) > epsilon2) this._ += "L" + x0 + "," + y0;
    if (!r) return;
    this._ += `A${r},${r},0,1,1,${x - r},${y}A${r},${r},0,1,1,${this._x1 = x0},${this._y1 = y0}`;
  }
  rect(x, y, w, h) {
    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${+w}v${+h}h${-w}Z`;
  }
  value() {
    return this._ || null;
  }
};

// node_modules/d3-delaunay/src/polygon.js
var Polygon = class {
  constructor() {
    this._ = [];
  }
  moveTo(x, y) {
    this._.push([x, y]);
  }
  closePath() {
    this._.push(this._[0].slice());
  }
  lineTo(x, y) {
    this._.push([x, y]);
  }
  value() {
    return this._.length ? this._ : null;
  }
};

// node_modules/d3-delaunay/src/voronoi.js
var Voronoi = class {
  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error("invalid bounds");
    this.delaunay = delaunay;
    this._circumcenters = new Float64Array(delaunay.points.length * 2);
    this.vectors = new Float64Array(delaunay.points.length * 2);
    this.xmax = xmax, this.xmin = xmin;
    this.ymax = ymax, this.ymin = ymin;
    this._init();
  }
  update() {
    this.delaunay.update();
    this._init();
    return this;
  }
  _init() {
    const { delaunay: { points, hull, triangles }, vectors } = this;
    let bx, by;
    const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
    for (let i = 0, j = 0, n = triangles.length, x, y; i < n; i += 3, j += 2) {
      const t1 = triangles[i] * 2;
      const t2 = triangles[i + 1] * 2;
      const t3 = triangles[i + 2] * 2;
      const x12 = points[t1];
      const y12 = points[t1 + 1];
      const x2 = points[t2];
      const y2 = points[t2 + 1];
      const x3 = points[t3];
      const y3 = points[t3 + 1];
      const dx = x2 - x12;
      const dy = y2 - y12;
      const ex = x3 - x12;
      const ey = y3 - y12;
      const ab4 = (dx * ey - dy * ex) * 2;
      if (Math.abs(ab4) < 1e-9) {
        if (bx === void 0) {
          bx = by = 0;
          for (const i2 of hull) bx += points[i2 * 2], by += points[i2 * 2 + 1];
          bx /= hull.length, by /= hull.length;
        }
        const a = 1e9 * Math.sign((bx - x12) * ey - (by - y12) * ex);
        x = (x12 + x3) / 2 - a * ey;
        y = (y12 + y3) / 2 + a * ex;
      } else {
        const d = 1 / ab4;
        const bl = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        x = x12 + (ey * bl - dy * cl) * d;
        y = y12 + (dx * cl - ex * bl) * d;
      }
      circumcenters[j] = x;
      circumcenters[j + 1] = y;
    }
    let h = hull[hull.length - 1];
    let p0, p1 = h * 4;
    let x0, x1 = points[2 * h];
    let y0, y1 = points[2 * h + 1];
    vectors.fill(0);
    for (let i = 0; i < hull.length; ++i) {
      h = hull[i];
      p0 = p1, x0 = x1, y0 = y1;
      p1 = h * 4, x1 = points[2 * h], y1 = points[2 * h + 1];
      vectors[p0 + 2] = vectors[p1] = y0 - y1;
      vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;
    }
  }
  render(context) {
    const buffer = context == null ? context = new Path() : void 0;
    const { delaunay: { halfedges, inedges, hull }, circumcenters, vectors } = this;
    if (hull.length <= 1) return null;
    for (let i = 0, n = halfedges.length; i < n; ++i) {
      const j = halfedges[i];
      if (j < i) continue;
      const ti = Math.floor(i / 3) * 2;
      const tj = Math.floor(j / 3) * 2;
      const xi = circumcenters[ti];
      const yi = circumcenters[ti + 1];
      const xj = circumcenters[tj];
      const yj = circumcenters[tj + 1];
      this._renderSegment(xi, yi, xj, yj, context);
    }
    let h0, h1 = hull[hull.length - 1];
    for (let i = 0; i < hull.length; ++i) {
      h0 = h1, h1 = hull[i];
      const t = Math.floor(inedges[h1] / 3) * 2;
      const x = circumcenters[t];
      const y = circumcenters[t + 1];
      const v2 = h0 * 4;
      const p = this._project(x, y, vectors[v2 + 2], vectors[v2 + 3]);
      if (p) this._renderSegment(x, y, p[0], p[1], context);
    }
    return buffer && buffer.value();
  }
  renderBounds(context) {
    const buffer = context == null ? context = new Path() : void 0;
    context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
    return buffer && buffer.value();
  }
  renderCell(i, context) {
    const buffer = context == null ? context = new Path() : void 0;
    const points = this._clip(i);
    if (points === null || !points.length) return;
    context.moveTo(points[0], points[1]);
    let n = points.length;
    while (points[0] === points[n - 2] && points[1] === points[n - 1] && n > 1) n -= 2;
    for (let i2 = 2; i2 < n; i2 += 2) {
      if (points[i2] !== points[i2 - 2] || points[i2 + 1] !== points[i2 - 1])
        context.lineTo(points[i2], points[i2 + 1]);
    }
    context.closePath();
    return buffer && buffer.value();
  }
  *cellPolygons() {
    const { delaunay: { points } } = this;
    for (let i = 0, n = points.length / 2; i < n; ++i) {
      const cell = this.cellPolygon(i);
      if (cell) cell.index = i, yield cell;
    }
  }
  cellPolygon(i) {
    const polygon = new Polygon();
    this.renderCell(i, polygon);
    return polygon.value();
  }
  _renderSegment(x0, y0, x1, y1, context) {
    let S;
    const c0 = this._regioncode(x0, y0);
    const c1 = this._regioncode(x1, y1);
    if (c0 === 0 && c1 === 0) {
      context.moveTo(x0, y0);
      context.lineTo(x1, y1);
    } else if (S = this._clipSegment(x0, y0, x1, y1, c0, c1)) {
      context.moveTo(S[0], S[1]);
      context.lineTo(S[2], S[3]);
    }
  }
  contains(i, x, y) {
    if ((x = +x, x !== x) || (y = +y, y !== y)) return false;
    return this.delaunay._step(i, x, y) === i;
  }
  *neighbors(i) {
    const ci = this._clip(i);
    if (ci) for (const j of this.delaunay.neighbors(i)) {
      const cj = this._clip(j);
      if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {
        for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
          if (ci[ai] === cj[aj] && ci[ai + 1] === cj[aj + 1] && ci[(ai + 2) % li] === cj[(aj + lj - 2) % lj] && ci[(ai + 3) % li] === cj[(aj + lj - 1) % lj]) {
            yield j;
            break loop;
          }
        }
      }
    }
  }
  _cell(i) {
    const { circumcenters, delaunay: { inedges, halfedges, triangles } } = this;
    const e0 = inedges[i];
    if (e0 === -1) return null;
    const points = [];
    let e = e0;
    do {
      const t = Math.floor(e / 3);
      points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) break;
      e = halfedges[e];
    } while (e !== e0 && e !== -1);
    return points;
  }
  _clip(i) {
    if (i === 0 && this.delaunay.hull.length === 1) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    const points = this._cell(i);
    if (points === null) return null;
    const { vectors: V } = this;
    const v2 = i * 4;
    return this._simplify(V[v2] || V[v2 + 1] ? this._clipInfinite(i, points, V[v2], V[v2 + 1], V[v2 + 2], V[v2 + 3]) : this._clipFinite(i, points));
  }
  _clipFinite(i, points) {
    const n = points.length;
    let P = null;
    let x0, y0, x1 = points[n - 2], y1 = points[n - 1];
    let c0, c1 = this._regioncode(x1, y1);
    let e0, e1 = 0;
    for (let j = 0; j < n; j += 2) {
      x0 = x1, y0 = y1, x1 = points[j], y1 = points[j + 1];
      c0 = c1, c1 = this._regioncode(x1, y1);
      if (c0 === 0 && c1 === 0) {
        e0 = e1, e1 = 0;
        if (P) P.push(x1, y1);
        else P = [x1, y1];
      } else {
        let S, sx0, sy0, sx1, sy1;
        if (c0 === 0) {
          if ((S = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;
          [sx0, sy0, sx1, sy1] = S;
        } else {
          if ((S = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;
          [sx1, sy1, sx0, sy0] = S;
          e0 = e1, e1 = this._edgecode(sx0, sy0);
          if (e0 && e1) this._edge(i, e0, e1, P, P.length);
          if (P) P.push(sx0, sy0);
          else P = [sx0, sy0];
        }
        e0 = e1, e1 = this._edgecode(sx1, sy1);
        if (e0 && e1) this._edge(i, e0, e1, P, P.length);
        if (P) P.push(sx1, sy1);
        else P = [sx1, sy1];
      }
    }
    if (P) {
      e0 = e1, e1 = this._edgecode(P[0], P[1]);
      if (e0 && e1) this._edge(i, e0, e1, P, P.length);
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    return P;
  }
  _clipSegment(x0, y0, x1, y1, c0, c1) {
    const flip = c0 < c1;
    if (flip) [x0, y0, x1, y1, c0, c1] = [x1, y1, x0, y0, c1, c0];
    while (true) {
      if (c0 === 0 && c1 === 0) return flip ? [x1, y1, x0, y0] : [x0, y0, x1, y1];
      if (c0 & c1) return null;
      let x, y, c = c0 || c1;
      if (c & 8) x = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y = this.ymax;
      else if (c & 4) x = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y = this.ymin;
      else if (c & 2) y = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x = this.xmax;
      else y = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x = this.xmin;
      if (c0) x0 = x, y0 = y, c0 = this._regioncode(x0, y0);
      else x1 = x, y1 = y, c1 = this._regioncode(x1, y1);
    }
  }
  _clipInfinite(i, points, vx0, vy0, vxn, vyn) {
    let P = Array.from(points), p;
    if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);
    if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);
    if (P = this._clipFinite(i, P)) {
      for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
        c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
        if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;
      }
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
    }
    return P;
  }
  _edge(i, e0, e1, P, j) {
    while (e0 !== e1) {
      let x, y;
      switch (e0) {
        case 5:
          e0 = 4;
          continue;
        case 4:
          e0 = 6, x = this.xmax, y = this.ymin;
          break;
        case 6:
          e0 = 2;
          continue;
        case 2:
          e0 = 10, x = this.xmax, y = this.ymax;
          break;
        case 10:
          e0 = 8;
          continue;
        case 8:
          e0 = 9, x = this.xmin, y = this.ymax;
          break;
        case 9:
          e0 = 1;
          continue;
        case 1:
          e0 = 5, x = this.xmin, y = this.ymin;
          break;
      }
      if ((P[j] !== x || P[j + 1] !== y) && this.contains(i, x, y)) {
        P.splice(j, 0, x, y), j += 2;
      }
    }
    return j;
  }
  _project(x0, y0, vx, vy) {
    let t = Infinity, c, x, y;
    if (vy < 0) {
      if (y0 <= this.ymin) return null;
      if ((c = (this.ymin - y0) / vy) < t) y = this.ymin, x = x0 + (t = c) * vx;
    } else if (vy > 0) {
      if (y0 >= this.ymax) return null;
      if ((c = (this.ymax - y0) / vy) < t) y = this.ymax, x = x0 + (t = c) * vx;
    }
    if (vx > 0) {
      if (x0 >= this.xmax) return null;
      if ((c = (this.xmax - x0) / vx) < t) x = this.xmax, y = y0 + (t = c) * vy;
    } else if (vx < 0) {
      if (x0 <= this.xmin) return null;
      if ((c = (this.xmin - x0) / vx) < t) x = this.xmin, y = y0 + (t = c) * vy;
    }
    return [x, y];
  }
  _edgecode(x, y) {
    return (x === this.xmin ? 1 : x === this.xmax ? 2 : 0) | (y === this.ymin ? 4 : y === this.ymax ? 8 : 0);
  }
  _regioncode(x, y) {
    return (x < this.xmin ? 1 : x > this.xmax ? 2 : 0) | (y < this.ymin ? 4 : y > this.ymax ? 8 : 0);
  }
  _simplify(P) {
    if (P && P.length > 4) {
      for (let i = 0; i < P.length; i += 2) {
        const j = (i + 2) % P.length, k = (i + 4) % P.length;
        if (P[i] === P[j] && P[j] === P[k] || P[i + 1] === P[j + 1] && P[j + 1] === P[k + 1]) {
          P.splice(j, 2), i -= 2;
        }
      }
      if (!P.length) P = null;
    }
    return P;
  }
};

// node_modules/d3-delaunay/src/delaunay.js
var tau = 2 * Math.PI;
var pow = Math.pow;
function pointX(p) {
  return p[0];
}
function pointY(p) {
  return p[1];
}
function collinear(d) {
  const { triangles, coords } = d;
  for (let i = 0; i < triangles.length; i += 3) {
    const a = 2 * triangles[i], b = 2 * triangles[i + 1], c = 2 * triangles[i + 2], cross = (coords[c] - coords[a]) * (coords[b + 1] - coords[a + 1]) - (coords[b] - coords[a]) * (coords[c + 1] - coords[a + 1]);
    if (cross > 1e-10) return false;
  }
  return true;
}
function jitter(x, y, r) {
  return [x + Math.sin(x + y) * r, y + Math.cos(x - y) * r];
}
var Delaunay = class _Delaunay {
  static from(points, fx = pointX, fy = pointY, that) {
    return new _Delaunay("length" in points ? flatArray(points, fx, fy, that) : Float64Array.from(flatIterable(points, fx, fy, that)));
  }
  constructor(points) {
    this._delaunator = new Delaunator(points);
    this.inedges = new Int32Array(points.length / 2);
    this._hullIndex = new Int32Array(points.length / 2);
    this.points = this._delaunator.coords;
    this._init();
  }
  update() {
    this._delaunator.update();
    this._init();
    return this;
  }
  _init() {
    const d = this._delaunator, points = this.points;
    if (d.hull && d.hull.length > 2 && collinear(d)) {
      this.collinear = Int32Array.from({ length: points.length / 2 }, (_, i) => i).sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]);
      const e = this.collinear[0], f = this.collinear[this.collinear.length - 1], bounds = [points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1]], r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);
      for (let i = 0, n = points.length / 2; i < n; ++i) {
        const p = jitter(points[2 * i], points[2 * i + 1], r);
        points[2 * i] = p[0];
        points[2 * i + 1] = p[1];
      }
      this._delaunator = new Delaunator(points);
    } else {
      delete this.collinear;
    }
    const halfedges = this.halfedges = this._delaunator.halfedges;
    const hull = this.hull = this._delaunator.hull;
    const triangles = this.triangles = this._delaunator.triangles;
    const inedges = this.inedges.fill(-1);
    const hullIndex = this._hullIndex.fill(-1);
    for (let e = 0, n = halfedges.length; e < n; ++e) {
      const p = triangles[e % 3 === 2 ? e - 2 : e + 1];
      if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;
    }
    for (let i = 0, n = hull.length; i < n; ++i) {
      hullIndex[hull[i]] = i;
    }
    if (hull.length <= 2 && hull.length > 0) {
      this.triangles = new Int32Array(3).fill(-1);
      this.halfedges = new Int32Array(3).fill(-1);
      this.triangles[0] = hull[0];
      inedges[hull[0]] = 1;
      if (hull.length === 2) {
        inedges[hull[1]] = 0;
        this.triangles[1] = hull[1];
        this.triangles[2] = hull[1];
      }
    }
  }
  voronoi(bounds) {
    return new Voronoi(this, bounds);
  }
  *neighbors(i) {
    const { inedges, hull, _hullIndex, halfedges, triangles, collinear: collinear2 } = this;
    if (collinear2) {
      const l = collinear2.indexOf(i);
      if (l > 0) yield collinear2[l - 1];
      if (l < collinear2.length - 1) yield collinear2[l + 1];
      return;
    }
    const e0 = inedges[i];
    if (e0 === -1) return;
    let e = e0, p0 = -1;
    do {
      yield p0 = triangles[e];
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) return;
      e = halfedges[e];
      if (e === -1) {
        const p = hull[(_hullIndex[i] + 1) % hull.length];
        if (p !== p0) yield p;
        return;
      }
    } while (e !== e0);
  }
  find(x, y, i = 0) {
    if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;
    const i0 = i;
    let c;
    while ((c = this._step(i, x, y)) >= 0 && c !== i && c !== i0) i = c;
    return c;
  }
  _step(i, x, y) {
    const { inedges, hull, _hullIndex, halfedges, triangles, points } = this;
    if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);
    let c = i;
    let dc = pow(x - points[i * 2], 2) + pow(y - points[i * 2 + 1], 2);
    const e0 = inedges[i];
    let e = e0;
    do {
      let t = triangles[e];
      const dt = pow(x - points[t * 2], 2) + pow(y - points[t * 2 + 1], 2);
      if (dt < dc) dc = dt, c = t;
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) break;
      e = halfedges[e];
      if (e === -1) {
        e = hull[(_hullIndex[i] + 1) % hull.length];
        if (e !== t) {
          if (pow(x - points[e * 2], 2) + pow(y - points[e * 2 + 1], 2) < dc) return e;
        }
        break;
      }
    } while (e !== e0);
    return c;
  }
  render(context) {
    const buffer = context == null ? context = new Path() : void 0;
    const { points, halfedges, triangles } = this;
    for (let i = 0, n = halfedges.length; i < n; ++i) {
      const j = halfedges[i];
      if (j < i) continue;
      const ti = triangles[i] * 2;
      const tj = triangles[j] * 2;
      context.moveTo(points[ti], points[ti + 1]);
      context.lineTo(points[tj], points[tj + 1]);
    }
    this.renderHull(context);
    return buffer && buffer.value();
  }
  renderPoints(context, r) {
    if (r === void 0 && (!context || typeof context.moveTo !== "function")) r = context, context = null;
    r = r == void 0 ? 2 : +r;
    const buffer = context == null ? context = new Path() : void 0;
    const { points } = this;
    for (let i = 0, n = points.length; i < n; i += 2) {
      const x = points[i], y = points[i + 1];
      context.moveTo(x + r, y);
      context.arc(x, y, r, 0, tau);
    }
    return buffer && buffer.value();
  }
  renderHull(context) {
    const buffer = context == null ? context = new Path() : void 0;
    const { hull, points } = this;
    const h = hull[0] * 2, n = hull.length;
    context.moveTo(points[h], points[h + 1]);
    for (let i = 1; i < n; ++i) {
      const h2 = 2 * hull[i];
      context.lineTo(points[h2], points[h2 + 1]);
    }
    context.closePath();
    return buffer && buffer.value();
  }
  hullPolygon() {
    const polygon = new Polygon();
    this.renderHull(polygon);
    return polygon.value();
  }
  renderTriangle(i, context) {
    const buffer = context == null ? context = new Path() : void 0;
    const { points, triangles } = this;
    const t0 = triangles[i *= 3] * 2;
    const t1 = triangles[i + 1] * 2;
    const t2 = triangles[i + 2] * 2;
    context.moveTo(points[t0], points[t0 + 1]);
    context.lineTo(points[t1], points[t1 + 1]);
    context.lineTo(points[t2], points[t2 + 1]);
    context.closePath();
    return buffer && buffer.value();
  }
  *trianglePolygons() {
    const { triangles } = this;
    for (let i = 0, n = triangles.length / 3; i < n; ++i) {
      yield this.trianglePolygon(i);
    }
  }
  trianglePolygon(i) {
    const polygon = new Polygon();
    this.renderTriangle(i, polygon);
    return polygon.value();
  }
};
function flatArray(points, fx, fy, that) {
  const n = points.length;
  const array = new Float64Array(n * 2);
  for (let i = 0; i < n; ++i) {
    const p = points[i];
    array[i * 2] = fx.call(that, p, i, points);
    array[i * 2 + 1] = fy.call(that, p, i, points);
  }
  return array;
}
function* flatIterable(points, fx, fy, that) {
  let i = 0;
  for (const p of points) {
    yield fx.call(that, p, i, points);
    yield fy.call(that, p, i, points);
    ++i;
  }
}

// node_modules/@mui/x-charts/ChartsVoronoiHandler/ChartsVoronoiHandler.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime());
function ChartsVoronoiHandler(props) {
  const {
    voronoiMaxRadius,
    onItemClick
  } = props;
  const svgRef = useSvgRef();
  const drawingArea = useDrawingArea();
  const {
    xAxis,
    yAxis,
    xAxisIds,
    yAxisIds
  } = useCartesianContext();
  const {
    dispatch
  } = React29.useContext(InteractionContext);
  const {
    series,
    seriesOrder
  } = useScatterSeries() ?? {};
  const voronoiRef = React29.useRef({});
  const delauneyRef = React29.useRef(void 0);
  const lastFind = React29.useRef(void 0);
  const {
    setHighlighted,
    clearHighlighted
  } = useHighlighted();
  const defaultXAxisId = xAxisIds[0];
  const defaultYAxisId = yAxisIds[0];
  useEnhancedEffect_default(() => {
    dispatch({
      type: "updateVoronoiUsage",
      useVoronoiInteraction: true
    });
    return () => {
      dispatch({
        type: "updateVoronoiUsage",
        useVoronoiInteraction: false
      });
    };
  }, [dispatch]);
  useEnhancedEffect_default(() => {
    if (seriesOrder === void 0 || series === void 0) {
      return;
    }
    voronoiRef.current = {};
    let points = [];
    seriesOrder.forEach((seriesId) => {
      const {
        data,
        xAxisId,
        yAxisId,
        xAxisKey,
        yAxisKey
      } = series[seriesId];
      const xScale = xAxis[xAxisId ?? xAxisKey ?? defaultXAxisId].scale;
      const yScale = yAxis[yAxisId ?? yAxisKey ?? defaultYAxisId].scale;
      const getXPosition = getValueToPositionMapper(xScale);
      const getYPosition = getValueToPositionMapper(yScale);
      const seriesPoints = data.flatMap(({
        x,
        y
      }) => {
        const pointX2 = getXPosition(x);
        const pointY2 = getYPosition(y);
        if (!drawingArea.isPointInside({
          x: pointX2,
          y: pointY2
        })) {
          return [-drawingArea.width, -drawingArea.height];
        }
        return [pointX2, pointY2];
      });
      voronoiRef.current[seriesId] = {
        seriesId,
        startIndex: points.length,
        endIndex: points.length + seriesPoints.length
      };
      points = points.concat(seriesPoints);
    });
    delauneyRef.current = new Delaunay(points);
    lastFind.current = void 0;
  }, [defaultXAxisId, defaultYAxisId, series, seriesOrder, xAxis, yAxis, drawingArea]);
  React29.useEffect(() => {
    const element = svgRef.current;
    if (element === null) {
      return void 0;
    }
    function getClosestPoint(event) {
      const svgPoint = getSVGPoint(element, event);
      if (!drawingArea.isPointInside(svgPoint)) {
        lastFind.current = void 0;
        return "outside-chart";
      }
      if (!delauneyRef.current) {
        return "no-point-found";
      }
      const closestPointIndex = delauneyRef.current.find(svgPoint.x, svgPoint.y, lastFind.current);
      if (closestPointIndex === void 0) {
        return "no-point-found";
      }
      lastFind.current = closestPointIndex;
      const closestSeries = Object.values(voronoiRef.current).find((value) => {
        return 2 * closestPointIndex >= value.startIndex && 2 * closestPointIndex < value.endIndex;
      });
      if (closestSeries === void 0) {
        return "no-point-found";
      }
      const dataIndex = (2 * closestPointIndex - voronoiRef.current[closestSeries.seriesId].startIndex) / 2;
      if (voronoiMaxRadius !== void 0) {
        const pointX2 = delauneyRef.current.points[2 * closestPointIndex];
        const pointY2 = delauneyRef.current.points[2 * closestPointIndex + 1];
        const dist2 = (pointX2 - svgPoint.x) ** 2 + (pointY2 - svgPoint.y) ** 2;
        if (dist2 > voronoiMaxRadius ** 2) {
          return "outside-voronoi-max-radius";
        }
      }
      return {
        seriesId: closestSeries.seriesId,
        dataIndex
      };
    }
    const handleMouseLeave = () => {
      dispatch({
        type: "exitChart"
      });
      clearHighlighted();
    };
    const handleMouseMove = (event) => {
      const closestPoint = getClosestPoint(event);
      if (closestPoint === "outside-chart") {
        dispatch({
          type: "exitChart"
        });
        clearHighlighted();
        return;
      }
      if (closestPoint === "outside-voronoi-max-radius" || closestPoint === "no-point-found") {
        dispatch({
          type: "leaveItem",
          data: {
            type: "scatter"
          }
        });
        clearHighlighted();
        return;
      }
      const {
        seriesId,
        dataIndex
      } = closestPoint;
      dispatch({
        type: "enterItem",
        data: {
          type: "scatter",
          seriesId,
          dataIndex
        }
      });
      setHighlighted({
        seriesId,
        dataIndex
      });
    };
    const handleMouseClick = (event) => {
      if (!onItemClick) {
        return;
      }
      const closestPoint = getClosestPoint(event);
      if (typeof closestPoint === "string") {
        return;
      }
      const {
        seriesId,
        dataIndex
      } = closestPoint;
      onItemClick(event, {
        type: "scatter",
        seriesId,
        dataIndex
      });
    };
    element.addEventListener("pointerleave", handleMouseLeave);
    element.addEventListener("pointermove", handleMouseMove);
    element.addEventListener("click", handleMouseClick);
    return () => {
      element.removeEventListener("pointerleave", handleMouseLeave);
      element.removeEventListener("pointermove", handleMouseMove);
      element.removeEventListener("click", handleMouseClick);
    };
  }, [svgRef, dispatch, yAxis, xAxis, voronoiMaxRadius, onItemClick, setHighlighted, clearHighlighted, drawingArea]);
  return (0, import_jsx_runtime24.jsx)(React29.Fragment, {});
}
true ? ChartsVoronoiHandler.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Callback fired when clicking on a scatter item.
   * @param {MouseEvent} event Mouse event caught at the svg level
   * @param {ScatterItemIdentifier} scatterItemIdentifier Identify which item got clicked
   */
  onItemClick: import_prop_types16.default.func,
  /**
   * Defines the maximal distance between a scatter point and the pointer that triggers the interaction.
   * If `undefined`, the radius is assumed to be infinite.
   */
  voronoiMaxRadius: import_prop_types16.default.number
} : void 0;

// node_modules/@mui/x-charts/ChartsOnAxisClickHandler/ChartsOnAxisClickHandler.js
var React30 = __toESM(require_react());
var import_prop_types17 = __toESM(require_prop_types());
var import_jsx_runtime25 = __toESM(require_jsx_runtime());
function ChartsOnAxisClickHandler(props) {
  const {
    onAxisClick
  } = props;
  const svgRef = useSvgRef();
  const series = useSeries();
  const {
    axis
  } = React30.useContext(InteractionContext);
  const {
    xAxisIds,
    xAxis,
    yAxisIds,
    yAxis
  } = useCartesianContext();
  React30.useEffect(() => {
    const element = svgRef.current;
    if (element === null || !onAxisClick) {
      return () => {
      };
    }
    const handleMouseClick = (event) => {
      var _a;
      event.preventDefault();
      const isXaxis = axis.x && axis.x.index !== -1;
      const USED_AXIS_ID = isXaxis ? xAxisIds[0] : yAxisIds[0];
      const dataIndex = isXaxis ? axis.x && axis.x.index : axis.y && axis.y.index;
      if (dataIndex == null) {
        return;
      }
      const seriesValues = {};
      Object.keys(series).filter((seriesType) => ["bar", "line"].includes(seriesType)).forEach((seriesType) => {
        var _a2;
        (_a2 = series[seriesType]) == null ? void 0 : _a2.seriesOrder.forEach((seriesId) => {
          const seriesItem = series[seriesType].series[seriesId];
          const providedXAxisId = seriesItem.xAxisId ?? seriesItem.xAxisKey;
          const providedYAxisId = seriesItem.yAxisId ?? seriesItem.yAxisKey;
          const axisKey = isXaxis ? providedXAxisId : providedYAxisId;
          if (axisKey === void 0 || axisKey === USED_AXIS_ID) {
            seriesValues[seriesId] = seriesItem.data[dataIndex];
          }
        });
      });
      const axisValue = (_a = (isXaxis ? xAxis : yAxis)[USED_AXIS_ID].data) == null ? void 0 : _a[dataIndex];
      onAxisClick(event, {
        dataIndex,
        axisValue,
        seriesValues
      });
    };
    element.addEventListener("click", handleMouseClick);
    return () => {
      element.removeEventListener("click", handleMouseClick);
    };
  }, [axis.x, axis.y, onAxisClick, series, svgRef, xAxis, xAxisIds, yAxis, yAxisIds]);
  return (0, import_jsx_runtime25.jsx)(React30.Fragment, {});
}
true ? ChartsOnAxisClickHandler.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The function called for onClick events.
   * The second argument contains information about all line/bar elements at the current mouse position.
   * @param {MouseEvent} event The mouse event recorded on the `<svg/>` element.
   * @param {null | AxisData} data The data about the clicked axis and items associated with it.
   */
  onAxisClick: import_prop_types17.default.func
} : void 0;

// node_modules/@mui/x-charts/BarChart/BarChart.js
init_extends();
var React44 = __toESM(require_react());
var import_prop_types25 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/BarChart/BarPlot.js
init_extends();
var React36 = __toESM(require_react());
var import_prop_types21 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/BarChart/BarElement.js
init_extends();
var React31 = __toESM(require_react());
var import_prop_types18 = __toESM(require_prop_types());
var import_jsx_runtime26 = __toESM(require_jsx_runtime());
var _excluded11 = ["id", "dataIndex", "classes", "color", "slots", "slotProps", "style", "onClick"];
function getBarElementUtilityClass(slot) {
  return generateUtilityClass("MuiBarElement", slot);
}
var barElementClasses = generateUtilityClasses("MuiBarElement", ["root"]);
var useUtilityClasses7 = (ownerState) => {
  const {
    classes,
    id
  } = ownerState;
  const slots = {
    root: ["root", `series-${id}`]
  };
  return composeClasses(slots, getBarElementUtilityClass, classes);
};
var BarElementPath = styled_default(animated.rect, {
  name: "MuiBarElement",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})(({
  ownerState
}) => ({
  stroke: "none",
  fill: ownerState.isHighlighted ? color(ownerState.color).brighter(0.5).formatHex() : ownerState.color,
  transition: "opacity 0.2s ease-in, fill 0.2s ease-in",
  opacity: ownerState.isFaded && 0.3 || 1
}));
function BarElement(props) {
  const {
    id,
    dataIndex,
    classes: innerClasses,
    color: color2,
    slots,
    slotProps,
    style,
    onClick
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded11);
  const getInteractionItemProps = useInteractionItemProps();
  const {
    isFaded,
    isHighlighted
  } = useItemHighlighted({
    seriesId: id,
    dataIndex
  });
  const ownerState = {
    id,
    dataIndex,
    classes: innerClasses,
    color: color2,
    isFaded,
    isHighlighted
  };
  const classes = useUtilityClasses7(ownerState);
  const Bar = (slots == null ? void 0 : slots.bar) ?? BarElementPath;
  const barProps = useSlotProps_default({
    elementType: Bar,
    externalSlotProps: slotProps == null ? void 0 : slotProps.bar,
    externalForwardedProps: other,
    additionalProps: _extends({}, getInteractionItemProps({
      type: "bar",
      seriesId: id,
      dataIndex
    }), {
      style,
      onClick,
      cursor: onClick ? "pointer" : "unset"
    }),
    className: classes.root,
    ownerState
  });
  return (0, import_jsx_runtime26.jsx)(Bar, _extends({}, barProps));
}
true ? BarElement.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types18.default.object,
  dataIndex: import_prop_types18.default.number.isRequired,
  id: import_prop_types18.default.oneOfType([import_prop_types18.default.number, import_prop_types18.default.string]).isRequired,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types18.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types18.default.object
} : void 0;

// node_modules/@mui/x-charts/BarChart/BarClipPath.js
init_extends();
var React32 = __toESM(require_react());

// node_modules/@mui/x-charts/BarChart/getRadius.js
var getRadius = (corner, {
  hasNegative,
  hasPositive,
  borderRadius,
  layout
}) => {
  if (!borderRadius) {
    return 0;
  }
  const isVertical = layout === "vertical";
  if (corner === "top-left" && (isVertical && hasPositive || !isVertical && hasNegative)) {
    return borderRadius;
  }
  if (corner === "top-right" && (isVertical && hasPositive || !isVertical && hasPositive)) {
    return borderRadius;
  }
  if (corner === "bottom-right" && (isVertical && hasNegative || !isVertical && hasPositive)) {
    return borderRadius;
  }
  if (corner === "bottom-left" && (isVertical && hasNegative || !isVertical && hasNegative)) {
    return borderRadius;
  }
  return 0;
};

// node_modules/@mui/x-charts/BarChart/BarClipPath.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime());
var _excluded12 = ["style", "maskId"];
var buildInset = (corners) => `inset(0px round ${corners.topLeft}px ${corners.topRight}px ${corners.bottomRight}px ${corners.bottomLeft}px)`;
function BarClipRect(props) {
  var _a, _b;
  const radiusData = props.ownerState;
  return (0, import_jsx_runtime27.jsx)(animated.rect, {
    style: _extends({}, props.style, {
      clipPath: (props.ownerState.layout === "vertical" ? (_a = props.style) == null ? void 0 : _a.height : (_b = props.style) == null ? void 0 : _b.width).to((value) => buildInset({
        topLeft: Math.min(value, getRadius("top-left", radiusData)),
        topRight: Math.min(value, getRadius("top-right", radiusData)),
        bottomRight: Math.min(value, getRadius("bottom-right", radiusData)),
        bottomLeft: Math.min(value, getRadius("bottom-left", radiusData))
      }))
    })
  });
}
function BarClipPath(props) {
  const {
    style,
    maskId
  } = props, rest = _objectWithoutPropertiesLoose(props, _excluded12);
  if (!props.borderRadius || props.borderRadius <= 0) {
    return null;
  }
  return (0, import_jsx_runtime27.jsx)("clipPath", {
    id: maskId,
    children: (0, import_jsx_runtime27.jsx)(BarClipRect, {
      ownerState: rest,
      style
    })
  });
}

// node_modules/@mui/x-charts/BarChart/BarLabel/BarLabelPlot.js
init_extends();
var React35 = __toESM(require_react());

// node_modules/@mui/x-charts/BarChart/BarLabel/BarLabelItem.js
init_extends();
var React34 = __toESM(require_react());
var import_prop_types20 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/BarChart/BarLabel/barLabelClasses.js
function getBarLabelUtilityClass(slot) {
  return generateUtilityClass("MuiBarLabel", slot);
}
var barLabelClasses = generateUtilityClasses("MuiBarLabel", ["root", "highlighted", "faded"]);
var useUtilityClasses8 = (ownerState) => {
  const {
    classes,
    seriesId,
    isFaded,
    isHighlighted
  } = ownerState;
  const slots = {
    root: ["root", `series-${seriesId}`, isHighlighted && "highlighted", isFaded && "faded"]
  };
  return composeClasses(slots, getBarLabelUtilityClass, classes);
};

// node_modules/@mui/x-charts/BarChart/BarLabel/getBarLabel.js
var getBarLabel = (options) => {
  const {
    barLabel,
    value,
    dataIndex,
    seriesId,
    height,
    width
  } = options;
  if (barLabel === "value") {
    return value ? value == null ? void 0 : value.toString() : null;
  }
  return barLabel({
    seriesId,
    dataIndex,
    value
  }, {
    bar: {
      height,
      width
    }
  });
};

// node_modules/@mui/x-charts/BarChart/BarLabel/BarLabel.js
init_extends();
var React33 = __toESM(require_react());
var import_prop_types19 = __toESM(require_prop_types());
var import_jsx_runtime28 = __toESM(require_jsx_runtime());
var _excluded13 = ["seriesId", "dataIndex", "color", "isFaded", "isHighlighted", "classes"];
var BarLabelComponent = styled_default(animated.text, {
  name: "MuiBarLabel",
  slot: "Root",
  overridesResolver: (_, styles) => [{
    [`&.${barLabelClasses.faded}`]: styles.faded
  }, {
    [`&.${barLabelClasses.highlighted}`]: styles.highlighted
  }, styles.root]
})(({
  theme
}) => {
  var _a, _b, _c, _d;
  return _extends({}, (_a = theme == null ? void 0 : theme.typography) == null ? void 0 : _a.body2, {
    stroke: "none",
    fill: (_d = (_c = (_b = theme.vars || theme) == null ? void 0 : _b.palette) == null ? void 0 : _c.text) == null ? void 0 : _d.primary,
    transition: "opacity 0.2s ease-in, fill 0.2s ease-in",
    textAnchor: "middle",
    dominantBaseline: "central",
    pointerEvents: "none",
    opacity: 1,
    [`&.${barLabelClasses.faded}`]: {
      opacity: 0.3
    }
  });
});
function BarLabel(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiBarLabel"
  });
  const otherProps = _objectWithoutPropertiesLoose(props, _excluded13);
  return (0, import_jsx_runtime28.jsx)(BarLabelComponent, _extends({}, otherProps));
}
true ? BarLabel.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types19.default.object,
  dataIndex: import_prop_types19.default.number.isRequired,
  isFaded: import_prop_types19.default.bool.isRequired,
  isHighlighted: import_prop_types19.default.bool.isRequired,
  seriesId: import_prop_types19.default.oneOfType([import_prop_types19.default.number, import_prop_types19.default.string]).isRequired
} : void 0;

// node_modules/@mui/x-charts/BarChart/BarLabel/BarLabelItem.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime());
var _excluded14 = ["seriesId", "classes", "color", "style", "dataIndex", "barLabel", "slots", "slotProps", "height", "width", "value"];
var _excluded22 = ["ownerState"];
function BarLabelItem(props) {
  const {
    seriesId,
    classes: innerClasses,
    color: color2,
    style,
    dataIndex,
    barLabel,
    slots,
    slotProps,
    height,
    width,
    value
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded14);
  const {
    isFaded,
    isHighlighted
  } = useItemHighlighted({
    seriesId,
    dataIndex
  });
  const ownerState = {
    seriesId,
    classes: innerClasses,
    color: color2,
    isFaded,
    isHighlighted,
    dataIndex
  };
  const classes = useUtilityClasses8(ownerState);
  const Component = (slots == null ? void 0 : slots.barLabel) ?? BarLabel;
  const _useSlotProps = useSlotProps_default({
    elementType: Component,
    externalSlotProps: slotProps == null ? void 0 : slotProps.barLabel,
    additionalProps: _extends({}, other, {
      style,
      className: classes.root
    }),
    ownerState
  }), {
    ownerState: barLabelOwnerState
  } = _useSlotProps, barLabelProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded22);
  if (!barLabel) {
    return null;
  }
  const formattedLabelText = getBarLabel({
    barLabel,
    value,
    dataIndex,
    seriesId,
    height,
    width
  });
  if (!formattedLabelText) {
    return null;
  }
  return (0, import_jsx_runtime29.jsx)(Component, _extends({}, barLabelProps, barLabelOwnerState, {
    children: formattedLabelText
  }));
}
true ? BarLabelItem.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If provided, the function will be used to format the label of the bar.
   * It can be set to 'value' to display the current value.
   * @param {BarItem} item The item to format.
   * @param {BarLabelContext} context data about the bar.
   * @returns {string} The formatted label.
   */
  barLabel: import_prop_types20.default.oneOfType([import_prop_types20.default.oneOf(["value"]), import_prop_types20.default.func]),
  classes: import_prop_types20.default.object,
  color: import_prop_types20.default.string.isRequired,
  dataIndex: import_prop_types20.default.number.isRequired,
  /**
   * The height of the bar.
   */
  height: import_prop_types20.default.number.isRequired,
  seriesId: import_prop_types20.default.oneOfType([import_prop_types20.default.number, import_prop_types20.default.string]).isRequired,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types20.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types20.default.object,
  /**
   * The value of the data point.
   */
  value: import_prop_types20.default.number,
  /**
   * The width of the bar.
   */
  width: import_prop_types20.default.number.isRequired
} : void 0;

// node_modules/@mui/x-charts/BarChart/BarLabel/BarLabelPlot.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime());
var _excluded15 = ["bars", "skipAnimation"];
var leaveStyle = ({
  layout,
  yOrigin,
  x,
  width,
  y,
  xOrigin,
  height
}) => _extends({}, layout === "vertical" ? {
  y: yOrigin,
  x: x + width / 2,
  height: 0,
  width
} : {
  y: y + height / 2,
  x: xOrigin,
  height,
  width: 0
});
var enterStyle = ({
  x,
  width,
  y,
  height
}) => ({
  x: x + width / 2,
  y: y + height / 2,
  height,
  width
});
function BarLabelPlot(props) {
  const {
    bars,
    skipAnimation
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded15);
  const barLabelTransition = useTransition(bars, {
    keys: (bar) => `${bar.seriesId}-${bar.dataIndex}`,
    from: leaveStyle,
    leave: null,
    enter: enterStyle,
    update: enterStyle,
    immediate: skipAnimation
  });
  return (0, import_jsx_runtime30.jsx)(React35.Fragment, {
    children: barLabelTransition((style, {
      seriesId,
      dataIndex,
      color: color2,
      value,
      width,
      height
    }) => (0, import_jsx_runtime30.jsx)(BarLabelItem, _extends({
      seriesId,
      dataIndex,
      value,
      color: color2,
      width,
      height
    }, other, {
      style
    })))
  });
}

// node_modules/@mui/x-charts/BarChart/checkScaleErrors.js
var getAxisMessage = (axisDirection, axisId) => {
  const axisName = `${axisDirection}-axis`;
  const axisIdName = `${axisDirection}Axis`;
  const axisDefaultKey = axisDirection === "x" ? DEFAULT_X_AXIS_KEY : DEFAULT_Y_AXIS_KEY;
  return axisId === axisDefaultKey ? `The first \`${axisIdName}\`` : `The ${axisName} with id "${axisId}"`;
};
function checkScaleErrors(verticalLayout, seriesId, xAxisId, xAxis, yAxisId, yAxis) {
  const xAxisConfig = xAxis[xAxisId];
  const yAxisConfig = yAxis[yAxisId];
  const discreteAxisConfig = verticalLayout ? xAxisConfig : yAxisConfig;
  const continuousAxisConfig = verticalLayout ? yAxisConfig : xAxisConfig;
  const discreteAxisId = verticalLayout ? xAxisId : yAxisId;
  const continuousAxisId = verticalLayout ? yAxisId : xAxisId;
  const discreteAxisDirection = verticalLayout ? "x" : "y";
  const continuousAxisDirection = verticalLayout ? "y" : "x";
  if (!isBandScaleConfig(discreteAxisConfig)) {
    throw new Error(`MUI X: ${getAxisMessage(discreteAxisDirection, discreteAxisId)} should be of type "band" to display the bar series of id "${seriesId}".`);
  }
  if (discreteAxisConfig.data === void 0) {
    throw new Error(`MUI X: ${getAxisMessage(discreteAxisDirection, discreteAxisId)} should have data property.`);
  }
  if (isBandScaleConfig(continuousAxisConfig) || isPointScaleConfig(continuousAxisConfig)) {
    throw new Error(`MUI X: ${getAxisMessage(continuousAxisDirection, continuousAxisId)} should be a continuous type to display the bar series of id "${seriesId}".`);
  }
}

// node_modules/@mui/x-charts/BarChart/BarPlot.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime());
var _excluded16 = ["skipAnimation", "onItemClick", "borderRadius", "barLabel"];
function getBandSize({
  bandWidth: W,
  numberOfGroups: N,
  gapRatio: r
}) {
  if (r === 0) {
    return {
      barWidth: W / N,
      offset: 0
    };
  }
  const barWidth = W / (N + (N - 1) * r);
  const offset = r * barWidth;
  return {
    barWidth,
    offset
  };
}
var useAggregatedData = () => {
  const seriesData = useBarSeries() ?? {
    series: {},
    stackingGroups: [],
    seriesOrder: []
  };
  const axisData = useCartesianContext();
  const chartId = useChartId();
  const {
    series,
    stackingGroups
  } = seriesData;
  const {
    xAxis,
    yAxis,
    xAxisIds,
    yAxisIds
  } = axisData;
  const defaultXAxisId = xAxisIds[0];
  const defaultYAxisId = yAxisIds[0];
  const masks = {};
  const data = stackingGroups.flatMap(({
    ids: groupIds
  }, groupIndex) => {
    return groupIds.flatMap((seriesId) => {
      const xAxisId = series[seriesId].xAxisId ?? series[seriesId].xAxisKey ?? defaultXAxisId;
      const yAxisId = series[seriesId].yAxisId ?? series[seriesId].yAxisKey ?? defaultYAxisId;
      const xAxisConfig = xAxis[xAxisId];
      const yAxisConfig = yAxis[yAxisId];
      const verticalLayout = series[seriesId].layout === "vertical";
      checkScaleErrors(verticalLayout, seriesId, xAxisId, xAxis, yAxisId, yAxis);
      const baseScaleConfig = verticalLayout ? xAxisConfig : yAxisConfig;
      const xScale = xAxisConfig.scale;
      const yScale = yAxisConfig.scale;
      const colorGetter = getColor_default(series[seriesId], xAxis[xAxisId], yAxis[yAxisId]);
      const bandWidth = baseScaleConfig.scale.bandwidth();
      const {
        barWidth,
        offset
      } = getBandSize({
        bandWidth,
        numberOfGroups: stackingGroups.length,
        gapRatio: baseScaleConfig.barGapRatio
      });
      const barOffset = groupIndex * (barWidth + offset);
      const {
        stackedData
      } = series[seriesId];
      return stackedData.map((values, dataIndex) => {
        var _a, _b;
        const valueCoordinates = values.map((v2) => verticalLayout ? yScale(v2) : xScale(v2));
        const minValueCoord = Math.round(Math.min(...valueCoordinates));
        const maxValueCoord = Math.round(Math.max(...valueCoordinates));
        const stackId = series[seriesId].stack;
        const result = {
          seriesId,
          dataIndex,
          layout: series[seriesId].layout,
          x: verticalLayout ? xScale((_a = xAxis[xAxisId].data) == null ? void 0 : _a[dataIndex]) + barOffset : minValueCoord,
          y: verticalLayout ? minValueCoord : yScale((_b = yAxis[yAxisId].data) == null ? void 0 : _b[dataIndex]) + barOffset,
          xOrigin: xScale(0),
          yOrigin: yScale(0),
          height: verticalLayout ? maxValueCoord - minValueCoord : barWidth,
          width: verticalLayout ? barWidth : maxValueCoord - minValueCoord,
          color: colorGetter(dataIndex),
          value: series[seriesId].data[dataIndex],
          maskId: `${chartId}_${stackId || seriesId}_${groupIndex}_${dataIndex}`
        };
        if (!masks[result.maskId]) {
          masks[result.maskId] = {
            id: result.maskId,
            width: 0,
            height: 0,
            hasNegative: false,
            hasPositive: false,
            layout: result.layout,
            xOrigin: xScale(0),
            yOrigin: yScale(0),
            x: 0,
            y: 0
          };
        }
        const mask = masks[result.maskId];
        mask.width = result.layout === "vertical" ? result.width : mask.width + result.width;
        mask.height = result.layout === "vertical" ? mask.height + result.height : result.height;
        mask.x = Math.min(mask.x === 0 ? Infinity : mask.x, result.x);
        mask.y = Math.min(mask.y === 0 ? Infinity : mask.y, result.y);
        mask.hasNegative = mask.hasNegative || (result.value ?? 0) < 0;
        mask.hasPositive = mask.hasPositive || (result.value ?? 0) > 0;
        return result;
      });
    });
  });
  return {
    completedData: data,
    masksData: Object.values(masks)
  };
};
var leaveStyle2 = ({
  layout,
  yOrigin,
  x,
  width,
  y,
  xOrigin,
  height
}) => _extends({}, layout === "vertical" ? {
  y: yOrigin,
  x,
  height: 0,
  width
} : {
  y,
  x: xOrigin,
  height,
  width: 0
});
var enterStyle2 = ({
  x,
  width,
  y,
  height
}) => ({
  y,
  x,
  height,
  width
});
function BarPlot(props) {
  const {
    completedData,
    masksData
  } = useAggregatedData();
  const {
    skipAnimation: inSkipAnimation,
    onItemClick,
    borderRadius,
    barLabel
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded16);
  const skipAnimation = useSkipAnimation(inSkipAnimation);
  const withoutBorderRadius = !borderRadius || borderRadius <= 0;
  const transition = useTransition(completedData, {
    keys: (bar) => `${bar.seriesId}-${bar.dataIndex}`,
    from: leaveStyle2,
    leave: leaveStyle2,
    enter: enterStyle2,
    update: enterStyle2,
    immediate: skipAnimation
  });
  const maskTransition = useTransition(withoutBorderRadius ? [] : masksData, {
    keys: (v2) => v2.id,
    from: leaveStyle2,
    leave: leaveStyle2,
    enter: enterStyle2,
    update: enterStyle2,
    immediate: skipAnimation
  });
  return (0, import_jsx_runtime31.jsxs)(React36.Fragment, {
    children: [!withoutBorderRadius && maskTransition((style, {
      id,
      hasPositive,
      hasNegative,
      layout
    }) => {
      return (0, import_jsx_runtime31.jsx)(BarClipPath, {
        maskId: id,
        borderRadius,
        hasNegative,
        hasPositive,
        layout,
        style
      });
    }), transition((style, {
      seriesId,
      dataIndex,
      color: color2,
      maskId
    }) => {
      const barElement = (0, import_jsx_runtime31.jsx)(BarElement, _extends({
        id: seriesId,
        dataIndex,
        color: color2
      }, other, {
        onClick: onItemClick && ((event) => {
          onItemClick(event, {
            type: "bar",
            seriesId,
            dataIndex
          });
        }),
        style
      }));
      if (withoutBorderRadius) {
        return barElement;
      }
      return (0, import_jsx_runtime31.jsx)("g", {
        clipPath: `url(#${maskId})`,
        children: barElement
      });
    }), barLabel && (0, import_jsx_runtime31.jsx)(BarLabelPlot, _extends({
      bars: completedData,
      skipAnimation,
      barLabel
    }, other))]
  });
}
true ? BarPlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If provided, the function will be used to format the label of the bar.
   * It can be set to 'value' to display the current value.
   * @param {BarItem} item The item to format.
   * @param {BarLabelContext} context data about the bar.
   * @returns {string} The formatted label.
   */
  barLabel: import_prop_types21.default.oneOfType([import_prop_types21.default.oneOf(["value"]), import_prop_types21.default.func]),
  /**
   * Defines the border radius of the bar element.
   */
  borderRadius: import_prop_types21.default.number,
  /**
   * Callback fired when a bar item is clicked.
   * @param {React.MouseEvent<SVGElement, MouseEvent>} event The event source of the callback.
   * @param {BarItemIdentifier} barItemIdentifier The bar item identifier.
   */
  onItemClick: import_prop_types21.default.func,
  /**
   * If `true`, animations are skipped.
   * @default undefined
   */
  skipAnimation: import_prop_types21.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types21.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types21.default.object
} : void 0;

// node_modules/@mui/x-charts/ResponsiveChartContainer/ResponsiveChartContainer.js
init_extends();
var React40 = __toESM(require_react());
var import_prop_types24 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/ChartContainer/ChartContainer.js
init_extends();
var React39 = __toESM(require_react());
var import_prop_types23 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/ChartsSurface/ChartsSurface.js
init_extends();
var import_prop_types22 = __toESM(require_prop_types());
var React38 = __toESM(require_react());

// node_modules/@mui/x-charts/hooks/useAxisEvents.js
var React37 = __toESM(require_react());
function getAsANumber(value) {
  return value instanceof Date ? value.getTime() : value;
}
var useAxisEvents = (disableAxisListener) => {
  const svgRef = useSvgRef();
  const drawingArea = useDrawingArea();
  const {
    xAxis,
    yAxis,
    xAxisIds,
    yAxisIds
  } = useCartesianContext();
  const {
    dispatch
  } = React37.useContext(InteractionContext);
  const usedXAxis = xAxisIds[0];
  const usedYAxis = yAxisIds[0];
  const mousePosition = React37.useRef({
    isInChart: false,
    x: -1,
    y: -1
  });
  React37.useEffect(() => {
    const element = svgRef.current;
    if (element === null || disableAxisListener) {
      return () => {
      };
    }
    function getNewAxisState(axisConfig, mouseValue) {
      const {
        scale: scale2,
        data: axisData,
        reverse
      } = axisConfig;
      if (!isBandScale(scale2)) {
        const value = scale2.invert(mouseValue);
        if (axisData === void 0) {
          return {
            value,
            index: -1
          };
        }
        const valueAsNumber = getAsANumber(value);
        const closestIndex = axisData == null ? void 0 : axisData.findIndex((pointValue, index) => {
          const v2 = getAsANumber(pointValue);
          if (v2 > valueAsNumber) {
            if (index === 0 || Math.abs(valueAsNumber - v2) <= Math.abs(valueAsNumber - getAsANumber(axisData[index - 1]))) {
              return true;
            }
          }
          if (v2 <= valueAsNumber) {
            if (index === axisData.length - 1 || Math.abs(getAsANumber(value) - v2) < Math.abs(getAsANumber(value) - getAsANumber(axisData[index + 1]))) {
              return true;
            }
          }
          return false;
        });
        return {
          value: closestIndex !== void 0 && closestIndex >= 0 ? axisData[closestIndex] : value,
          index: closestIndex
        };
      }
      const dataIndex = scale2.bandwidth() === 0 ? Math.floor((mouseValue - Math.min(...scale2.range()) + scale2.step() / 2) / scale2.step()) : Math.floor((mouseValue - Math.min(...scale2.range())) / scale2.step());
      if (dataIndex < 0 || dataIndex >= axisData.length) {
        return null;
      }
      if (reverse) {
        const reverseIndex = axisData.length - 1 - dataIndex;
        return {
          index: reverseIndex,
          value: axisData[reverseIndex]
        };
      }
      return {
        index: dataIndex,
        value: axisData[dataIndex]
      };
    }
    const handleOut = () => {
      mousePosition.current = {
        isInChart: false,
        x: -1,
        y: -1
      };
      dispatch({
        type: "exitChart"
      });
    };
    const handleMove = (event) => {
      const target = "targetTouches" in event ? event.targetTouches[0] : event;
      const svgPoint = getSVGPoint(element, target);
      mousePosition.current.x = svgPoint.x;
      mousePosition.current.y = svgPoint.y;
      if (!drawingArea.isPointInside(svgPoint, {
        targetElement: event.target
      })) {
        if (mousePosition.current.isInChart) {
          dispatch({
            type: "exitChart"
          });
          mousePosition.current.isInChart = false;
        }
        return;
      }
      mousePosition.current.isInChart = true;
      const newStateX = getNewAxisState(xAxis[usedXAxis], svgPoint.x);
      const newStateY = getNewAxisState(yAxis[usedYAxis], svgPoint.y);
      dispatch({
        type: "updateAxis",
        data: {
          x: newStateX,
          y: newStateY
        }
      });
    };
    const handleDown = (event) => {
      const target = event.currentTarget;
      if (!target) {
        return;
      }
      if (target.hasPointerCapture(event.pointerId)) {
        target.releasePointerCapture(event.pointerId);
      }
    };
    element.addEventListener("pointerdown", handleDown);
    element.addEventListener("pointermove", handleMove);
    element.addEventListener("pointerout", handleOut);
    element.addEventListener("pointercancel", handleOut);
    element.addEventListener("pointerleave", handleOut);
    return () => {
      element.removeEventListener("pointerdown", handleDown);
      element.removeEventListener("pointermove", handleMove);
      element.removeEventListener("pointerout", handleOut);
      element.removeEventListener("pointercancel", handleOut);
      element.removeEventListener("pointerleave", handleOut);
    };
  }, [svgRef, dispatch, usedYAxis, yAxis, usedXAxis, xAxis, disableAxisListener, drawingArea]);
};

// node_modules/@mui/x-charts/ChartsSurface/ChartsSurface.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime());
var _excluded17 = ["children", "width", "height", "viewBox", "disableAxisListener", "className", "title", "desc"];
var ChartChartsSurfaceStyles = styled_default("svg", {
  name: "MuiChartsSurface",
  slot: "Root"
})(() => ({
  // This prevents default touch actions when using the svg on mobile devices.
  // For example, prevent page scroll & zoom.
  touchAction: "none"
}));
var ChartsSurface = React38.forwardRef(function ChartsSurface2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiChartsSurface"
  });
  const {
    children,
    width,
    height,
    viewBox,
    disableAxisListener = false,
    className,
    title,
    desc
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded17);
  const svgView = _extends({
    width,
    height,
    x: 0,
    y: 0
  }, viewBox);
  useAxisEvents(disableAxisListener);
  return (0, import_jsx_runtime32.jsxs)(ChartChartsSurfaceStyles, _extends({
    width,
    height,
    viewBox: `${svgView.x} ${svgView.y} ${svgView.width} ${svgView.height}`,
    ref,
    className
  }, other, {
    children: [(0, import_jsx_runtime32.jsx)("title", {
      children: title
    }), (0, import_jsx_runtime32.jsx)("desc", {
      children: desc
    }), children]
  }));
});
true ? ChartsSurface.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: import_prop_types22.default.node,
  className: import_prop_types22.default.string,
  desc: import_prop_types22.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types22.default.bool,
  /**
   * The height of the chart in px.
   */
  height: import_prop_types22.default.number.isRequired,
  sx: import_prop_types22.default.oneOfType([import_prop_types22.default.arrayOf(import_prop_types22.default.oneOfType([import_prop_types22.default.func, import_prop_types22.default.object, import_prop_types22.default.bool])), import_prop_types22.default.func, import_prop_types22.default.object]),
  title: import_prop_types22.default.string,
  viewBox: import_prop_types22.default.shape({
    height: import_prop_types22.default.number,
    width: import_prop_types22.default.number,
    x: import_prop_types22.default.number,
    y: import_prop_types22.default.number
  }),
  /**
   * The width of the chart in px.
   */
  width: import_prop_types22.default.number.isRequired
} : void 0;

// node_modules/@mui/x-charts/ChartContainer/ChartContainer.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime());
var ChartContainer = React39.forwardRef(function ChartContainer2(props, ref) {
  const {
    children,
    drawingProviderProps,
    seriesProviderProps,
    cartesianProviderProps,
    zAxisContextProps,
    highlightedProviderProps,
    chartsSurfaceProps,
    pluginProviderProps,
    animationProviderProps
  } = useChartContainerProps(props, ref);
  return (0, import_jsx_runtime33.jsx)(DrawingProvider, _extends({}, drawingProviderProps, {
    children: (0, import_jsx_runtime33.jsx)(PluginProvider, _extends({}, pluginProviderProps, {
      children: (0, import_jsx_runtime33.jsx)(SeriesProvider, _extends({}, seriesProviderProps, {
        children: (0, import_jsx_runtime33.jsx)(CartesianProvider, _extends({}, cartesianProviderProps, {
          children: (0, import_jsx_runtime33.jsx)(ZAxisContextProvider, _extends({}, zAxisContextProps, {
            children: (0, import_jsx_runtime33.jsx)(InteractionProvider, {
              children: (0, import_jsx_runtime33.jsx)(HighlightedProvider, _extends({}, highlightedProviderProps, {
                children: (0, import_jsx_runtime33.jsxs)(ChartsSurface, _extends({}, chartsSurfaceProps, {
                  children: [(0, import_jsx_runtime33.jsx)(ChartsAxesGradients, {}), (0, import_jsx_runtime33.jsx)(AnimationProvider, _extends({}, animationProviderProps, {
                    children
                  }))]
                }))
              }))
            })
          }))
        }))
      }))
    }))
  }));
});
true ? ChartContainer.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: import_prop_types23.default.node,
  className: import_prop_types23.default.string,
  /**
   * Color palette used to colorize multiple series.
   * @default blueberryTwilightPalette
   */
  colors: import_prop_types23.default.oneOfType([import_prop_types23.default.arrayOf(import_prop_types23.default.string), import_prop_types23.default.func]),
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types23.default.arrayOf(import_prop_types23.default.object),
  desc: import_prop_types23.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types23.default.bool,
  /**
   * The height of the chart in px.
   */
  height: import_prop_types23.default.number.isRequired,
  /**
   * The item currently highlighted. Turns highlighting into a controlled prop.
   */
  highlightedItem: import_prop_types23.default.shape({
    dataIndex: import_prop_types23.default.number,
    seriesId: import_prop_types23.default.oneOfType([import_prop_types23.default.number, import_prop_types23.default.string])
  }),
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   * Accepts an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   * @default object Depends on the charts type.
   */
  margin: import_prop_types23.default.shape({
    bottom: import_prop_types23.default.number,
    left: import_prop_types23.default.number,
    right: import_prop_types23.default.number,
    top: import_prop_types23.default.number
  }),
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types23.default.func,
  /**
   * An array of plugins defining how to preprocess data.
   * If not provided, the container supports line, bar, scatter and pie charts.
   */
  plugins: import_prop_types23.default.arrayOf(import_prop_types23.default.object),
  /**
   * The array of series to display.
   * Each type of series has its own specificity.
   * Please refer to the appropriate docs page to learn more about it.
   */
  series: import_prop_types23.default.arrayOf(import_prop_types23.default.object).isRequired,
  /**
   * If `true`, animations are skipped.
   * If unset or `false`, the animations respects the user's `prefers-reduced-motion` setting.
   */
  skipAnimation: import_prop_types23.default.bool,
  sx: import_prop_types23.default.oneOfType([import_prop_types23.default.arrayOf(import_prop_types23.default.oneOfType([import_prop_types23.default.func, import_prop_types23.default.object, import_prop_types23.default.bool])), import_prop_types23.default.func, import_prop_types23.default.object]),
  title: import_prop_types23.default.string,
  viewBox: import_prop_types23.default.shape({
    height: import_prop_types23.default.number,
    width: import_prop_types23.default.number,
    x: import_prop_types23.default.number,
    y: import_prop_types23.default.number
  }),
  /**
   * The width of the chart in px.
   */
  width: import_prop_types23.default.number.isRequired,
  /**
   * The configuration of the x-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  xAxis: import_prop_types23.default.arrayOf(import_prop_types23.default.shape({
    classes: import_prop_types23.default.object,
    colorMap: import_prop_types23.default.oneOfType([import_prop_types23.default.shape({
      colors: import_prop_types23.default.arrayOf(import_prop_types23.default.string).isRequired,
      type: import_prop_types23.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types23.default.string,
      values: import_prop_types23.default.arrayOf(import_prop_types23.default.oneOfType([import_prop_types23.default.instanceOf(Date), import_prop_types23.default.number, import_prop_types23.default.string]).isRequired)
    }), import_prop_types23.default.shape({
      color: import_prop_types23.default.oneOfType([import_prop_types23.default.arrayOf(import_prop_types23.default.string.isRequired), import_prop_types23.default.func]).isRequired,
      max: import_prop_types23.default.oneOfType([import_prop_types23.default.instanceOf(Date), import_prop_types23.default.number]),
      min: import_prop_types23.default.oneOfType([import_prop_types23.default.instanceOf(Date), import_prop_types23.default.number]),
      type: import_prop_types23.default.oneOf(["continuous"]).isRequired
    }), import_prop_types23.default.shape({
      colors: import_prop_types23.default.arrayOf(import_prop_types23.default.string).isRequired,
      thresholds: import_prop_types23.default.arrayOf(import_prop_types23.default.oneOfType([import_prop_types23.default.instanceOf(Date), import_prop_types23.default.number]).isRequired).isRequired,
      type: import_prop_types23.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types23.default.array,
    dataKey: import_prop_types23.default.string,
    disableLine: import_prop_types23.default.bool,
    disableTicks: import_prop_types23.default.bool,
    fill: import_prop_types23.default.string,
    hideTooltip: import_prop_types23.default.bool,
    id: import_prop_types23.default.oneOfType([import_prop_types23.default.number, import_prop_types23.default.string]),
    label: import_prop_types23.default.string,
    labelFontSize: import_prop_types23.default.number,
    labelStyle: import_prop_types23.default.object,
    max: import_prop_types23.default.oneOfType([import_prop_types23.default.instanceOf(Date), import_prop_types23.default.number]),
    min: import_prop_types23.default.oneOfType([import_prop_types23.default.instanceOf(Date), import_prop_types23.default.number]),
    position: import_prop_types23.default.oneOf(["bottom", "top"]),
    reverse: import_prop_types23.default.bool,
    scaleType: import_prop_types23.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types23.default.object,
    slots: import_prop_types23.default.object,
    stroke: import_prop_types23.default.string,
    sx: import_prop_types23.default.oneOfType([import_prop_types23.default.arrayOf(import_prop_types23.default.oneOfType([import_prop_types23.default.func, import_prop_types23.default.object, import_prop_types23.default.bool])), import_prop_types23.default.func, import_prop_types23.default.object]),
    tickFontSize: import_prop_types23.default.number,
    tickInterval: import_prop_types23.default.oneOfType([import_prop_types23.default.oneOf(["auto"]), import_prop_types23.default.array, import_prop_types23.default.func]),
    tickLabelInterval: import_prop_types23.default.oneOfType([import_prop_types23.default.oneOf(["auto"]), import_prop_types23.default.func]),
    tickLabelPlacement: import_prop_types23.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types23.default.object,
    tickMaxStep: import_prop_types23.default.number,
    tickMinStep: import_prop_types23.default.number,
    tickNumber: import_prop_types23.default.number,
    tickPlacement: import_prop_types23.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types23.default.number,
    valueFormatter: import_prop_types23.default.func
  })),
  /**
   * The configuration of the y-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  yAxis: import_prop_types23.default.arrayOf(import_prop_types23.default.shape({
    classes: import_prop_types23.default.object,
    colorMap: import_prop_types23.default.oneOfType([import_prop_types23.default.shape({
      colors: import_prop_types23.default.arrayOf(import_prop_types23.default.string).isRequired,
      type: import_prop_types23.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types23.default.string,
      values: import_prop_types23.default.arrayOf(import_prop_types23.default.oneOfType([import_prop_types23.default.instanceOf(Date), import_prop_types23.default.number, import_prop_types23.default.string]).isRequired)
    }), import_prop_types23.default.shape({
      color: import_prop_types23.default.oneOfType([import_prop_types23.default.arrayOf(import_prop_types23.default.string.isRequired), import_prop_types23.default.func]).isRequired,
      max: import_prop_types23.default.oneOfType([import_prop_types23.default.instanceOf(Date), import_prop_types23.default.number]),
      min: import_prop_types23.default.oneOfType([import_prop_types23.default.instanceOf(Date), import_prop_types23.default.number]),
      type: import_prop_types23.default.oneOf(["continuous"]).isRequired
    }), import_prop_types23.default.shape({
      colors: import_prop_types23.default.arrayOf(import_prop_types23.default.string).isRequired,
      thresholds: import_prop_types23.default.arrayOf(import_prop_types23.default.oneOfType([import_prop_types23.default.instanceOf(Date), import_prop_types23.default.number]).isRequired).isRequired,
      type: import_prop_types23.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types23.default.array,
    dataKey: import_prop_types23.default.string,
    disableLine: import_prop_types23.default.bool,
    disableTicks: import_prop_types23.default.bool,
    fill: import_prop_types23.default.string,
    hideTooltip: import_prop_types23.default.bool,
    id: import_prop_types23.default.oneOfType([import_prop_types23.default.number, import_prop_types23.default.string]),
    label: import_prop_types23.default.string,
    labelFontSize: import_prop_types23.default.number,
    labelStyle: import_prop_types23.default.object,
    max: import_prop_types23.default.oneOfType([import_prop_types23.default.instanceOf(Date), import_prop_types23.default.number]),
    min: import_prop_types23.default.oneOfType([import_prop_types23.default.instanceOf(Date), import_prop_types23.default.number]),
    position: import_prop_types23.default.oneOf(["left", "right"]),
    reverse: import_prop_types23.default.bool,
    scaleType: import_prop_types23.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types23.default.object,
    slots: import_prop_types23.default.object,
    stroke: import_prop_types23.default.string,
    sx: import_prop_types23.default.oneOfType([import_prop_types23.default.arrayOf(import_prop_types23.default.oneOfType([import_prop_types23.default.func, import_prop_types23.default.object, import_prop_types23.default.bool])), import_prop_types23.default.func, import_prop_types23.default.object]),
    tickFontSize: import_prop_types23.default.number,
    tickInterval: import_prop_types23.default.oneOfType([import_prop_types23.default.oneOf(["auto"]), import_prop_types23.default.array, import_prop_types23.default.func]),
    tickLabelInterval: import_prop_types23.default.oneOfType([import_prop_types23.default.oneOf(["auto"]), import_prop_types23.default.func]),
    tickLabelPlacement: import_prop_types23.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types23.default.object,
    tickMaxStep: import_prop_types23.default.number,
    tickMinStep: import_prop_types23.default.number,
    tickNumber: import_prop_types23.default.number,
    tickPlacement: import_prop_types23.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types23.default.number,
    valueFormatter: import_prop_types23.default.func
  })),
  /**
   * The configuration of the z-axes.
   */
  zAxis: import_prop_types23.default.arrayOf(import_prop_types23.default.shape({
    colorMap: import_prop_types23.default.oneOfType([import_prop_types23.default.shape({
      colors: import_prop_types23.default.arrayOf(import_prop_types23.default.string).isRequired,
      type: import_prop_types23.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types23.default.string,
      values: import_prop_types23.default.arrayOf(import_prop_types23.default.oneOfType([import_prop_types23.default.instanceOf(Date), import_prop_types23.default.number, import_prop_types23.default.string]).isRequired)
    }), import_prop_types23.default.shape({
      color: import_prop_types23.default.oneOfType([import_prop_types23.default.arrayOf(import_prop_types23.default.string.isRequired), import_prop_types23.default.func]).isRequired,
      max: import_prop_types23.default.oneOfType([import_prop_types23.default.instanceOf(Date), import_prop_types23.default.number]),
      min: import_prop_types23.default.oneOfType([import_prop_types23.default.instanceOf(Date), import_prop_types23.default.number]),
      type: import_prop_types23.default.oneOf(["continuous"]).isRequired
    }), import_prop_types23.default.shape({
      colors: import_prop_types23.default.arrayOf(import_prop_types23.default.string).isRequired,
      thresholds: import_prop_types23.default.arrayOf(import_prop_types23.default.oneOfType([import_prop_types23.default.instanceOf(Date), import_prop_types23.default.number]).isRequired).isRequired,
      type: import_prop_types23.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types23.default.array,
    dataKey: import_prop_types23.default.string,
    id: import_prop_types23.default.string,
    max: import_prop_types23.default.number,
    min: import_prop_types23.default.number
  }))
} : void 0;

// node_modules/@mui/x-charts/ResponsiveChartContainer/ResponsiveChartContainer.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime());
var ResponsiveChartContainer = React40.forwardRef(function ResponsiveChartContainer2(props, ref) {
  const {
    hasIntrinsicSize,
    chartContainerProps,
    resizableChartContainerProps
  } = useResponsiveChartContainerProps(props, ref);
  return (0, import_jsx_runtime34.jsx)(ResizableContainer, _extends({}, resizableChartContainerProps, {
    children: hasIntrinsicSize ? (0, import_jsx_runtime34.jsx)(ChartContainer, _extends({}, chartContainerProps)) : null
  }));
});
true ? ResponsiveChartContainer.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: import_prop_types24.default.node,
  className: import_prop_types24.default.string,
  /**
   * Color palette used to colorize multiple series.
   * @default blueberryTwilightPalette
   */
  colors: import_prop_types24.default.oneOfType([import_prop_types24.default.arrayOf(import_prop_types24.default.string), import_prop_types24.default.func]),
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types24.default.arrayOf(import_prop_types24.default.object),
  desc: import_prop_types24.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types24.default.bool,
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types24.default.number,
  /**
   * The item currently highlighted. Turns highlighting into a controlled prop.
   */
  highlightedItem: import_prop_types24.default.shape({
    dataIndex: import_prop_types24.default.number,
    seriesId: import_prop_types24.default.oneOfType([import_prop_types24.default.number, import_prop_types24.default.string])
  }),
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   * Accepts an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   * @default object Depends on the charts type.
   */
  margin: import_prop_types24.default.shape({
    bottom: import_prop_types24.default.number,
    left: import_prop_types24.default.number,
    right: import_prop_types24.default.number,
    top: import_prop_types24.default.number
  }),
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types24.default.func,
  /**
   * An array of plugins defining how to preprocess data.
   * If not provided, the container supports line, bar, scatter and pie charts.
   */
  plugins: import_prop_types24.default.arrayOf(import_prop_types24.default.object),
  /**
   * The chart will try to wait for the parent container to resolve its size
   * before it renders for the first time.
   *
   * This can be useful in some scenarios where the chart appear to grow after
   * the first render, like when used inside a grid.
   *
   * @default false
   */
  resolveSizeBeforeRender: import_prop_types24.default.bool,
  /**
   * The array of series to display.
   * Each type of series has its own specificity.
   * Please refer to the appropriate docs page to learn more about it.
   */
  series: import_prop_types24.default.arrayOf(import_prop_types24.default.object).isRequired,
  /**
   * If `true`, animations are skipped.
   * If unset or `false`, the animations respects the user's `prefers-reduced-motion` setting.
   */
  skipAnimation: import_prop_types24.default.bool,
  sx: import_prop_types24.default.oneOfType([import_prop_types24.default.arrayOf(import_prop_types24.default.oneOfType([import_prop_types24.default.func, import_prop_types24.default.object, import_prop_types24.default.bool])), import_prop_types24.default.func, import_prop_types24.default.object]),
  title: import_prop_types24.default.string,
  viewBox: import_prop_types24.default.shape({
    height: import_prop_types24.default.number,
    width: import_prop_types24.default.number,
    x: import_prop_types24.default.number,
    y: import_prop_types24.default.number
  }),
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types24.default.number,
  /**
   * The configuration of the x-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  xAxis: import_prop_types24.default.arrayOf(import_prop_types24.default.shape({
    classes: import_prop_types24.default.object,
    colorMap: import_prop_types24.default.oneOfType([import_prop_types24.default.shape({
      colors: import_prop_types24.default.arrayOf(import_prop_types24.default.string).isRequired,
      type: import_prop_types24.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types24.default.string,
      values: import_prop_types24.default.arrayOf(import_prop_types24.default.oneOfType([import_prop_types24.default.instanceOf(Date), import_prop_types24.default.number, import_prop_types24.default.string]).isRequired)
    }), import_prop_types24.default.shape({
      color: import_prop_types24.default.oneOfType([import_prop_types24.default.arrayOf(import_prop_types24.default.string.isRequired), import_prop_types24.default.func]).isRequired,
      max: import_prop_types24.default.oneOfType([import_prop_types24.default.instanceOf(Date), import_prop_types24.default.number]),
      min: import_prop_types24.default.oneOfType([import_prop_types24.default.instanceOf(Date), import_prop_types24.default.number]),
      type: import_prop_types24.default.oneOf(["continuous"]).isRequired
    }), import_prop_types24.default.shape({
      colors: import_prop_types24.default.arrayOf(import_prop_types24.default.string).isRequired,
      thresholds: import_prop_types24.default.arrayOf(import_prop_types24.default.oneOfType([import_prop_types24.default.instanceOf(Date), import_prop_types24.default.number]).isRequired).isRequired,
      type: import_prop_types24.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types24.default.array,
    dataKey: import_prop_types24.default.string,
    disableLine: import_prop_types24.default.bool,
    disableTicks: import_prop_types24.default.bool,
    fill: import_prop_types24.default.string,
    hideTooltip: import_prop_types24.default.bool,
    id: import_prop_types24.default.oneOfType([import_prop_types24.default.number, import_prop_types24.default.string]),
    label: import_prop_types24.default.string,
    labelFontSize: import_prop_types24.default.number,
    labelStyle: import_prop_types24.default.object,
    max: import_prop_types24.default.oneOfType([import_prop_types24.default.instanceOf(Date), import_prop_types24.default.number]),
    min: import_prop_types24.default.oneOfType([import_prop_types24.default.instanceOf(Date), import_prop_types24.default.number]),
    position: import_prop_types24.default.oneOf(["bottom", "top"]),
    reverse: import_prop_types24.default.bool,
    scaleType: import_prop_types24.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types24.default.object,
    slots: import_prop_types24.default.object,
    stroke: import_prop_types24.default.string,
    sx: import_prop_types24.default.oneOfType([import_prop_types24.default.arrayOf(import_prop_types24.default.oneOfType([import_prop_types24.default.func, import_prop_types24.default.object, import_prop_types24.default.bool])), import_prop_types24.default.func, import_prop_types24.default.object]),
    tickFontSize: import_prop_types24.default.number,
    tickInterval: import_prop_types24.default.oneOfType([import_prop_types24.default.oneOf(["auto"]), import_prop_types24.default.array, import_prop_types24.default.func]),
    tickLabelInterval: import_prop_types24.default.oneOfType([import_prop_types24.default.oneOf(["auto"]), import_prop_types24.default.func]),
    tickLabelPlacement: import_prop_types24.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types24.default.object,
    tickMaxStep: import_prop_types24.default.number,
    tickMinStep: import_prop_types24.default.number,
    tickNumber: import_prop_types24.default.number,
    tickPlacement: import_prop_types24.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types24.default.number,
    valueFormatter: import_prop_types24.default.func
  })),
  /**
   * The configuration of the y-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  yAxis: import_prop_types24.default.arrayOf(import_prop_types24.default.shape({
    classes: import_prop_types24.default.object,
    colorMap: import_prop_types24.default.oneOfType([import_prop_types24.default.shape({
      colors: import_prop_types24.default.arrayOf(import_prop_types24.default.string).isRequired,
      type: import_prop_types24.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types24.default.string,
      values: import_prop_types24.default.arrayOf(import_prop_types24.default.oneOfType([import_prop_types24.default.instanceOf(Date), import_prop_types24.default.number, import_prop_types24.default.string]).isRequired)
    }), import_prop_types24.default.shape({
      color: import_prop_types24.default.oneOfType([import_prop_types24.default.arrayOf(import_prop_types24.default.string.isRequired), import_prop_types24.default.func]).isRequired,
      max: import_prop_types24.default.oneOfType([import_prop_types24.default.instanceOf(Date), import_prop_types24.default.number]),
      min: import_prop_types24.default.oneOfType([import_prop_types24.default.instanceOf(Date), import_prop_types24.default.number]),
      type: import_prop_types24.default.oneOf(["continuous"]).isRequired
    }), import_prop_types24.default.shape({
      colors: import_prop_types24.default.arrayOf(import_prop_types24.default.string).isRequired,
      thresholds: import_prop_types24.default.arrayOf(import_prop_types24.default.oneOfType([import_prop_types24.default.instanceOf(Date), import_prop_types24.default.number]).isRequired).isRequired,
      type: import_prop_types24.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types24.default.array,
    dataKey: import_prop_types24.default.string,
    disableLine: import_prop_types24.default.bool,
    disableTicks: import_prop_types24.default.bool,
    fill: import_prop_types24.default.string,
    hideTooltip: import_prop_types24.default.bool,
    id: import_prop_types24.default.oneOfType([import_prop_types24.default.number, import_prop_types24.default.string]),
    label: import_prop_types24.default.string,
    labelFontSize: import_prop_types24.default.number,
    labelStyle: import_prop_types24.default.object,
    max: import_prop_types24.default.oneOfType([import_prop_types24.default.instanceOf(Date), import_prop_types24.default.number]),
    min: import_prop_types24.default.oneOfType([import_prop_types24.default.instanceOf(Date), import_prop_types24.default.number]),
    position: import_prop_types24.default.oneOf(["left", "right"]),
    reverse: import_prop_types24.default.bool,
    scaleType: import_prop_types24.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types24.default.object,
    slots: import_prop_types24.default.object,
    stroke: import_prop_types24.default.string,
    sx: import_prop_types24.default.oneOfType([import_prop_types24.default.arrayOf(import_prop_types24.default.oneOfType([import_prop_types24.default.func, import_prop_types24.default.object, import_prop_types24.default.bool])), import_prop_types24.default.func, import_prop_types24.default.object]),
    tickFontSize: import_prop_types24.default.number,
    tickInterval: import_prop_types24.default.oneOfType([import_prop_types24.default.oneOf(["auto"]), import_prop_types24.default.array, import_prop_types24.default.func]),
    tickLabelInterval: import_prop_types24.default.oneOfType([import_prop_types24.default.oneOf(["auto"]), import_prop_types24.default.func]),
    tickLabelPlacement: import_prop_types24.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types24.default.object,
    tickMaxStep: import_prop_types24.default.number,
    tickMinStep: import_prop_types24.default.number,
    tickNumber: import_prop_types24.default.number,
    tickPlacement: import_prop_types24.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types24.default.number,
    valueFormatter: import_prop_types24.default.func
  })),
  /**
   * The configuration of the z-axes.
   */
  zAxis: import_prop_types24.default.arrayOf(import_prop_types24.default.shape({
    colorMap: import_prop_types24.default.oneOfType([import_prop_types24.default.shape({
      colors: import_prop_types24.default.arrayOf(import_prop_types24.default.string).isRequired,
      type: import_prop_types24.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types24.default.string,
      values: import_prop_types24.default.arrayOf(import_prop_types24.default.oneOfType([import_prop_types24.default.instanceOf(Date), import_prop_types24.default.number, import_prop_types24.default.string]).isRequired)
    }), import_prop_types24.default.shape({
      color: import_prop_types24.default.oneOfType([import_prop_types24.default.arrayOf(import_prop_types24.default.string.isRequired), import_prop_types24.default.func]).isRequired,
      max: import_prop_types24.default.oneOfType([import_prop_types24.default.instanceOf(Date), import_prop_types24.default.number]),
      min: import_prop_types24.default.oneOfType([import_prop_types24.default.instanceOf(Date), import_prop_types24.default.number]),
      type: import_prop_types24.default.oneOf(["continuous"]).isRequired
    }), import_prop_types24.default.shape({
      colors: import_prop_types24.default.arrayOf(import_prop_types24.default.string).isRequired,
      thresholds: import_prop_types24.default.arrayOf(import_prop_types24.default.oneOfType([import_prop_types24.default.instanceOf(Date), import_prop_types24.default.number]).isRequired).isRequired,
      type: import_prop_types24.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types24.default.array,
    dataKey: import_prop_types24.default.string,
    id: import_prop_types24.default.string,
    max: import_prop_types24.default.number,
    min: import_prop_types24.default.number
  }))
} : void 0;

// node_modules/@mui/x-charts/ChartsOverlay/ChartsOverlay.js
init_extends();
var React43 = __toESM(require_react());

// node_modules/@mui/x-charts/ChartsOverlay/ChartsLoadingOverlay.js
init_extends();
var React41 = __toESM(require_react());
var import_jsx_runtime35 = __toESM(require_jsx_runtime());
var _excluded18 = ["message"];
var StyledText = styled_default("text")(({
  theme
}) => _extends({}, theme.typography.body2, {
  stroke: "none",
  fill: theme.palette.text.primary,
  shapeRendering: "crispEdges",
  textAnchor: "middle",
  dominantBaseline: "middle"
}));
function ChartsLoadingOverlay(props) {
  const {
    message
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded18);
  const {
    top,
    left,
    height,
    width
  } = useDrawingArea();
  return (0, import_jsx_runtime35.jsx)(StyledText, _extends({
    x: left + width / 2,
    y: top + height / 2
  }, other, {
    children: message ?? "Loading data…"
  }));
}

// node_modules/@mui/x-charts/ChartsOverlay/ChartsNoDataOverlay.js
init_extends();
var React42 = __toESM(require_react());
var import_jsx_runtime36 = __toESM(require_jsx_runtime());
var _excluded19 = ["message"];
var StyledText2 = styled_default("text")(({
  theme
}) => _extends({}, theme.typography.body2, {
  stroke: "none",
  fill: theme.palette.text.primary,
  shapeRendering: "crispEdges",
  textAnchor: "middle",
  dominantBaseline: "middle"
}));
function ChartsNoDataOverlay(props) {
  const {
    message
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded19);
  const {
    top,
    left,
    height,
    width
  } = useDrawingArea();
  return (0, import_jsx_runtime36.jsx)(StyledText2, _extends({
    x: left + width / 2,
    y: top + height / 2
  }, other, {
    children: message ?? "No data to display"
  }));
}

// node_modules/@mui/x-charts/ChartsOverlay/ChartsOverlay.js
var import_jsx_runtime37 = __toESM(require_jsx_runtime());
function useNoData() {
  const seriesPerType = useSeries();
  return Object.values(seriesPerType).every((seriesOfGivenType) => {
    if (!seriesOfGivenType) {
      return true;
    }
    const {
      series,
      seriesOrder
    } = seriesOfGivenType;
    return seriesOrder.every((seriesId) => series[seriesId].data.length === 0);
  });
}
function ChartsOverlay(props) {
  var _a, _b, _c, _d;
  const noData = useNoData();
  if (props.loading) {
    const LoadingOverlay = ((_a = props.slots) == null ? void 0 : _a.loadingOverlay) ?? ChartsLoadingOverlay;
    return (0, import_jsx_runtime37.jsx)(LoadingOverlay, _extends({}, (_b = props.slotProps) == null ? void 0 : _b.loadingOverlay));
  }
  if (noData) {
    const NoDataOverlay = ((_c = props.slots) == null ? void 0 : _c.noDataOverlay) ?? ChartsNoDataOverlay;
    return (0, import_jsx_runtime37.jsx)(NoDataOverlay, _extends({}, (_d = props.slotProps) == null ? void 0 : _d.noDataOverlay));
  }
  return null;
}

// node_modules/@mui/x-charts/BarChart/BarChart.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime());
var BarChart = React44.forwardRef(function BarChart2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiBarChart"
  });
  const {
    chartContainerProps,
    barPlotProps,
    axisClickHandlerProps,
    gridProps,
    clipPathProps,
    clipPathGroupProps,
    overlayProps,
    chartsAxisProps,
    axisHighlightProps,
    legendProps,
    tooltipProps,
    children
  } = useBarChartProps(props);
  return (0, import_jsx_runtime38.jsxs)(ResponsiveChartContainer, _extends({
    ref
  }, chartContainerProps, {
    children: [props.onAxisClick && (0, import_jsx_runtime38.jsx)(ChartsOnAxisClickHandler, _extends({}, axisClickHandlerProps)), (0, import_jsx_runtime38.jsx)(ChartsGrid, _extends({}, gridProps)), (0, import_jsx_runtime38.jsxs)("g", _extends({}, clipPathGroupProps, {
      children: [(0, import_jsx_runtime38.jsx)(BarPlot, _extends({}, barPlotProps)), (0, import_jsx_runtime38.jsx)(ChartsOverlay, _extends({}, overlayProps)), (0, import_jsx_runtime38.jsx)(ChartsAxisHighlight, _extends({}, axisHighlightProps))]
    })), (0, import_jsx_runtime38.jsx)(ChartsAxis, _extends({}, chartsAxisProps)), (0, import_jsx_runtime38.jsx)(ChartsLegend, _extends({}, legendProps)), !props.loading && (0, import_jsx_runtime38.jsx)(ChartsTooltip, _extends({}, tooltipProps)), (0, import_jsx_runtime38.jsx)(ChartsClipPath, _extends({}, clipPathProps)), children]
  }));
});
true ? BarChart.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The configuration of axes highlight.
   * Default is set to 'band' in the bar direction.
   * Depends on `layout` prop.
   * @see See {@link https://mui.com/x/react-charts/highlighting highlighting docs} for more details.
   */
  axisHighlight: import_prop_types25.default.shape({
    x: import_prop_types25.default.oneOf(["band", "line", "none"]),
    y: import_prop_types25.default.oneOf(["band", "line", "none"])
  }),
  /**
   * If provided, the function will be used to format the label of the bar.
   * It can be set to 'value' to display the current value.
   * @param {BarItem} item The item to format.
   * @param {BarLabelContext} context data about the bar.
   * @returns {string} The formatted label.
   */
  barLabel: import_prop_types25.default.oneOfType([import_prop_types25.default.oneOf(["value"]), import_prop_types25.default.func]),
  /**
   * Defines the border radius of the bar element.
   */
  borderRadius: import_prop_types25.default.number,
  /**
   * Indicate which axis to display the bottom of the charts.
   * Can be a string (the id of the axis) or an object `ChartsXAxisProps`.
   * @default xAxisIds[0] The id of the first provided axis
   */
  bottomAxis: import_prop_types25.default.oneOfType([import_prop_types25.default.object, import_prop_types25.default.string]),
  children: import_prop_types25.default.node,
  className: import_prop_types25.default.string,
  /**
   * Color palette used to colorize multiple series.
   * @default blueberryTwilightPalette
   */
  colors: import_prop_types25.default.oneOfType([import_prop_types25.default.arrayOf(import_prop_types25.default.string), import_prop_types25.default.func]),
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types25.default.arrayOf(import_prop_types25.default.object),
  desc: import_prop_types25.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types25.default.bool,
  /**
   * Option to display a cartesian grid in the background.
   */
  grid: import_prop_types25.default.shape({
    horizontal: import_prop_types25.default.bool,
    vertical: import_prop_types25.default.bool
  }),
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types25.default.number,
  /**
   * The item currently highlighted. Turns highlighting into a controlled prop.
   */
  highlightedItem: import_prop_types25.default.shape({
    dataIndex: import_prop_types25.default.number,
    seriesId: import_prop_types25.default.oneOfType([import_prop_types25.default.number, import_prop_types25.default.string])
  }),
  /**
   * The direction of the bar elements.
   * @default 'vertical'
   */
  layout: import_prop_types25.default.oneOf(["horizontal", "vertical"]),
  /**
   * Indicate which axis to display the left of the charts.
   * Can be a string (the id of the axis) or an object `ChartsYAxisProps`.
   * @default yAxisIds[0] The id of the first provided axis
   */
  leftAxis: import_prop_types25.default.oneOfType([import_prop_types25.default.object, import_prop_types25.default.string]),
  /**
   * @deprecated Consider using `slotProps.legend` instead.
   */
  legend: import_prop_types25.default.shape({
    classes: import_prop_types25.default.object,
    direction: import_prop_types25.default.oneOf(["column", "row"]),
    hidden: import_prop_types25.default.bool,
    itemGap: import_prop_types25.default.number,
    itemMarkHeight: import_prop_types25.default.number,
    itemMarkWidth: import_prop_types25.default.number,
    labelStyle: import_prop_types25.default.object,
    markGap: import_prop_types25.default.number,
    onItemClick: import_prop_types25.default.func,
    padding: import_prop_types25.default.oneOfType([import_prop_types25.default.number, import_prop_types25.default.shape({
      bottom: import_prop_types25.default.number,
      left: import_prop_types25.default.number,
      right: import_prop_types25.default.number,
      top: import_prop_types25.default.number
    })]),
    position: import_prop_types25.default.shape({
      horizontal: import_prop_types25.default.oneOf(["left", "middle", "right"]).isRequired,
      vertical: import_prop_types25.default.oneOf(["bottom", "middle", "top"]).isRequired
    }),
    slotProps: import_prop_types25.default.object,
    slots: import_prop_types25.default.object
  }),
  /**
   * If `true`, a loading overlay is displayed.
   * @default false
   */
  loading: import_prop_types25.default.bool,
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   * Accepts an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   * @default object Depends on the charts type.
   */
  margin: import_prop_types25.default.shape({
    bottom: import_prop_types25.default.number,
    left: import_prop_types25.default.number,
    right: import_prop_types25.default.number,
    top: import_prop_types25.default.number
  }),
  /**
   * The function called for onClick events.
   * The second argument contains information about all line/bar elements at the current mouse position.
   * @param {MouseEvent} event The mouse event recorded on the `<svg/>` element.
   * @param {null | AxisData} data The data about the clicked axis and items associated with it.
   */
  onAxisClick: import_prop_types25.default.func,
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types25.default.func,
  /**
   * Callback fired when a bar item is clicked.
   * @param {React.MouseEvent<SVGElement, MouseEvent>} event The event source of the callback.
   * @param {BarItemIdentifier} barItemIdentifier The bar item identifier.
   */
  onItemClick: import_prop_types25.default.func,
  /**
   * The chart will try to wait for the parent container to resolve its size
   * before it renders for the first time.
   *
   * This can be useful in some scenarios where the chart appear to grow after
   * the first render, like when used inside a grid.
   *
   * @default false
   */
  resolveSizeBeforeRender: import_prop_types25.default.bool,
  /**
   * Indicate which axis to display the right of the charts.
   * Can be a string (the id of the axis) or an object `ChartsYAxisProps`.
   * @default null
   */
  rightAxis: import_prop_types25.default.oneOfType([import_prop_types25.default.object, import_prop_types25.default.string]),
  /**
   * The series to display in the bar chart.
   * An array of [[BarSeriesType]] objects.
   */
  series: import_prop_types25.default.arrayOf(import_prop_types25.default.object).isRequired,
  /**
   * If `true`, animations are skipped.
   * If unset or `false`, the animations respects the user's `prefers-reduced-motion` setting.
   */
  skipAnimation: import_prop_types25.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types25.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types25.default.object,
  sx: import_prop_types25.default.oneOfType([import_prop_types25.default.arrayOf(import_prop_types25.default.oneOfType([import_prop_types25.default.func, import_prop_types25.default.object, import_prop_types25.default.bool])), import_prop_types25.default.func, import_prop_types25.default.object]),
  title: import_prop_types25.default.string,
  /**
   * The configuration of the tooltip.
   * @see See {@link https://mui.com/x/react-charts/tooltip/ tooltip docs} for more details.
   */
  tooltip: import_prop_types25.default.shape({
    axisContent: import_prop_types25.default.elementType,
    classes: import_prop_types25.default.object,
    itemContent: import_prop_types25.default.elementType,
    slotProps: import_prop_types25.default.object,
    slots: import_prop_types25.default.object,
    trigger: import_prop_types25.default.oneOf(["axis", "item", "none"])
  }),
  /**
   * Indicate which axis to display the top of the charts.
   * Can be a string (the id of the axis) or an object `ChartsXAxisProps`.
   * @default null
   */
  topAxis: import_prop_types25.default.oneOfType([import_prop_types25.default.object, import_prop_types25.default.string]),
  viewBox: import_prop_types25.default.shape({
    height: import_prop_types25.default.number,
    width: import_prop_types25.default.number,
    x: import_prop_types25.default.number,
    y: import_prop_types25.default.number
  }),
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types25.default.number,
  /**
   * The configuration of the x-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  xAxis: import_prop_types25.default.arrayOf(import_prop_types25.default.shape({
    classes: import_prop_types25.default.object,
    colorMap: import_prop_types25.default.oneOfType([import_prop_types25.default.shape({
      colors: import_prop_types25.default.arrayOf(import_prop_types25.default.string).isRequired,
      type: import_prop_types25.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types25.default.string,
      values: import_prop_types25.default.arrayOf(import_prop_types25.default.oneOfType([import_prop_types25.default.instanceOf(Date), import_prop_types25.default.number, import_prop_types25.default.string]).isRequired)
    }), import_prop_types25.default.shape({
      color: import_prop_types25.default.oneOfType([import_prop_types25.default.arrayOf(import_prop_types25.default.string.isRequired), import_prop_types25.default.func]).isRequired,
      max: import_prop_types25.default.oneOfType([import_prop_types25.default.instanceOf(Date), import_prop_types25.default.number]),
      min: import_prop_types25.default.oneOfType([import_prop_types25.default.instanceOf(Date), import_prop_types25.default.number]),
      type: import_prop_types25.default.oneOf(["continuous"]).isRequired
    }), import_prop_types25.default.shape({
      colors: import_prop_types25.default.arrayOf(import_prop_types25.default.string).isRequired,
      thresholds: import_prop_types25.default.arrayOf(import_prop_types25.default.oneOfType([import_prop_types25.default.instanceOf(Date), import_prop_types25.default.number]).isRequired).isRequired,
      type: import_prop_types25.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types25.default.array,
    dataKey: import_prop_types25.default.string,
    disableLine: import_prop_types25.default.bool,
    disableTicks: import_prop_types25.default.bool,
    fill: import_prop_types25.default.string,
    hideTooltip: import_prop_types25.default.bool,
    id: import_prop_types25.default.oneOfType([import_prop_types25.default.number, import_prop_types25.default.string]),
    label: import_prop_types25.default.string,
    labelFontSize: import_prop_types25.default.number,
    labelStyle: import_prop_types25.default.object,
    max: import_prop_types25.default.oneOfType([import_prop_types25.default.instanceOf(Date), import_prop_types25.default.number]),
    min: import_prop_types25.default.oneOfType([import_prop_types25.default.instanceOf(Date), import_prop_types25.default.number]),
    position: import_prop_types25.default.oneOf(["bottom", "top"]),
    reverse: import_prop_types25.default.bool,
    scaleType: import_prop_types25.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types25.default.object,
    slots: import_prop_types25.default.object,
    stroke: import_prop_types25.default.string,
    sx: import_prop_types25.default.oneOfType([import_prop_types25.default.arrayOf(import_prop_types25.default.oneOfType([import_prop_types25.default.func, import_prop_types25.default.object, import_prop_types25.default.bool])), import_prop_types25.default.func, import_prop_types25.default.object]),
    tickFontSize: import_prop_types25.default.number,
    tickInterval: import_prop_types25.default.oneOfType([import_prop_types25.default.oneOf(["auto"]), import_prop_types25.default.array, import_prop_types25.default.func]),
    tickLabelInterval: import_prop_types25.default.oneOfType([import_prop_types25.default.oneOf(["auto"]), import_prop_types25.default.func]),
    tickLabelPlacement: import_prop_types25.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types25.default.object,
    tickMaxStep: import_prop_types25.default.number,
    tickMinStep: import_prop_types25.default.number,
    tickNumber: import_prop_types25.default.number,
    tickPlacement: import_prop_types25.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types25.default.number,
    valueFormatter: import_prop_types25.default.func
  })),
  /**
   * The configuration of the y-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  yAxis: import_prop_types25.default.arrayOf(import_prop_types25.default.shape({
    classes: import_prop_types25.default.object,
    colorMap: import_prop_types25.default.oneOfType([import_prop_types25.default.shape({
      colors: import_prop_types25.default.arrayOf(import_prop_types25.default.string).isRequired,
      type: import_prop_types25.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types25.default.string,
      values: import_prop_types25.default.arrayOf(import_prop_types25.default.oneOfType([import_prop_types25.default.instanceOf(Date), import_prop_types25.default.number, import_prop_types25.default.string]).isRequired)
    }), import_prop_types25.default.shape({
      color: import_prop_types25.default.oneOfType([import_prop_types25.default.arrayOf(import_prop_types25.default.string.isRequired), import_prop_types25.default.func]).isRequired,
      max: import_prop_types25.default.oneOfType([import_prop_types25.default.instanceOf(Date), import_prop_types25.default.number]),
      min: import_prop_types25.default.oneOfType([import_prop_types25.default.instanceOf(Date), import_prop_types25.default.number]),
      type: import_prop_types25.default.oneOf(["continuous"]).isRequired
    }), import_prop_types25.default.shape({
      colors: import_prop_types25.default.arrayOf(import_prop_types25.default.string).isRequired,
      thresholds: import_prop_types25.default.arrayOf(import_prop_types25.default.oneOfType([import_prop_types25.default.instanceOf(Date), import_prop_types25.default.number]).isRequired).isRequired,
      type: import_prop_types25.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types25.default.array,
    dataKey: import_prop_types25.default.string,
    disableLine: import_prop_types25.default.bool,
    disableTicks: import_prop_types25.default.bool,
    fill: import_prop_types25.default.string,
    hideTooltip: import_prop_types25.default.bool,
    id: import_prop_types25.default.oneOfType([import_prop_types25.default.number, import_prop_types25.default.string]),
    label: import_prop_types25.default.string,
    labelFontSize: import_prop_types25.default.number,
    labelStyle: import_prop_types25.default.object,
    max: import_prop_types25.default.oneOfType([import_prop_types25.default.instanceOf(Date), import_prop_types25.default.number]),
    min: import_prop_types25.default.oneOfType([import_prop_types25.default.instanceOf(Date), import_prop_types25.default.number]),
    position: import_prop_types25.default.oneOf(["left", "right"]),
    reverse: import_prop_types25.default.bool,
    scaleType: import_prop_types25.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types25.default.object,
    slots: import_prop_types25.default.object,
    stroke: import_prop_types25.default.string,
    sx: import_prop_types25.default.oneOfType([import_prop_types25.default.arrayOf(import_prop_types25.default.oneOfType([import_prop_types25.default.func, import_prop_types25.default.object, import_prop_types25.default.bool])), import_prop_types25.default.func, import_prop_types25.default.object]),
    tickFontSize: import_prop_types25.default.number,
    tickInterval: import_prop_types25.default.oneOfType([import_prop_types25.default.oneOf(["auto"]), import_prop_types25.default.array, import_prop_types25.default.func]),
    tickLabelInterval: import_prop_types25.default.oneOfType([import_prop_types25.default.oneOf(["auto"]), import_prop_types25.default.func]),
    tickLabelPlacement: import_prop_types25.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types25.default.object,
    tickMaxStep: import_prop_types25.default.number,
    tickMinStep: import_prop_types25.default.number,
    tickNumber: import_prop_types25.default.number,
    tickPlacement: import_prop_types25.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types25.default.number,
    valueFormatter: import_prop_types25.default.func
  }))
} : void 0;

// node_modules/@mui/x-charts/LineChart/LineChart.js
init_extends();
var React58 = __toESM(require_react());
var import_prop_types37 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/LineChart/AreaPlot.js
init_extends();
var React49 = __toESM(require_react());
var import_prop_types28 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/LineChart/AreaElement.js
init_extends();
var React48 = __toESM(require_react());
var import_prop_types27 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/LineChart/AnimatedArea.js
init_extends();
var React47 = __toESM(require_react());
var import_prop_types26 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/internals/useStringInterpolator.js
var React45 = __toESM(require_react());
function usePrevious(value) {
  const ref = React45.useRef({
    currentPath: value,
    previousPath: void 0
  });
  if (ref.current.currentPath !== value) {
    ref.current = {
      currentPath: value,
      previousPath: ref.current.currentPath
    };
  }
  return ref.current;
}
var useStringInterpolator = (path) => {
  const memoryRef = usePrevious(path);
  const interpolator = React45.useMemo(() => memoryRef.previousPath ? string_default(memoryRef.previousPath, memoryRef.currentPath) : () => memoryRef.currentPath, [memoryRef.currentPath, memoryRef.previousPath]);
  return interpolator;
};

// node_modules/@mui/x-charts/LineChart/AppearingMask.js
var React46 = __toESM(require_react());

// node_modules/@mui/x-charts/internals/cleanId.js
function cleanId(id) {
  return id.replace(" ", "_");
}

// node_modules/@mui/x-charts/LineChart/AppearingMask.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime());
function AppearingMask(props) {
  const drawingArea = useDrawingArea();
  const chartId = useChartId();
  const transitionAppear = useTransition([drawingArea], {
    from: (v2) => ({
      animatedWidth: v2.left
    }),
    enter: (v2) => ({
      animatedWidth: v2.width + v2.left + v2.right
    }),
    leave: (v2) => ({
      animatedWidth: v2.width + v2.left + v2.right
    }),
    reset: false,
    immediate: props.skipAnimation
  });
  const clipId = cleanId(`${chartId}-${props.id}`);
  return (0, import_jsx_runtime39.jsxs)(React46.Fragment, {
    children: [(0, import_jsx_runtime39.jsx)("clipPath", {
      id: clipId,
      children: transitionAppear((style) => (0, import_jsx_runtime39.jsx)(animated.rect, {
        x: 0,
        y: 0,
        width: style.animatedWidth,
        height: drawingArea.top + drawingArea.height + drawingArea.bottom
      }))
    }), (0, import_jsx_runtime39.jsx)("g", {
      clipPath: `url(#${clipId})`,
      children: props.children
    })]
  });
}

// node_modules/@mui/x-charts/LineChart/AnimatedArea.js
var import_jsx_runtime40 = __toESM(require_jsx_runtime());
var _excluded20 = ["d", "skipAnimation", "ownerState"];
var AreaElementPath = styled_default(animated.path, {
  name: "MuiAreaElement",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})(({
  ownerState
}) => ({
  stroke: "none",
  fill: ownerState.gradientId && `url(#${ownerState.gradientId})` || ownerState.isHighlighted && color(ownerState.color).brighter(1).formatHex() || color(ownerState.color).brighter(0.5).formatHex(),
  transition: "opacity 0.2s ease-in, fill 0.2s ease-in",
  opacity: ownerState.isFaded ? 0.3 : 1
}));
function AnimatedArea(props) {
  const {
    d,
    skipAnimation,
    ownerState
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded20);
  const stringInterpolator = useStringInterpolator(d);
  const transitionChange = useTransition([stringInterpolator], {
    from: {
      value: 0
    },
    to: {
      value: 1
    },
    enter: {
      value: 1
    },
    reset: false,
    immediate: skipAnimation
  });
  return (0, import_jsx_runtime40.jsx)(AppearingMask, {
    skipAnimation,
    id: `${ownerState.id}-area-clip`,
    children: transitionChange((style, interpolator) => (0, import_jsx_runtime40.jsx)(AreaElementPath, _extends({}, other, {
      ownerState,
      d: style.value.to(interpolator)
    })))
  });
}
true ? AnimatedArea.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  d: import_prop_types26.default.string.isRequired,
  ownerState: import_prop_types26.default.shape({
    classes: import_prop_types26.default.object,
    color: import_prop_types26.default.string.isRequired,
    gradientId: import_prop_types26.default.string,
    id: import_prop_types26.default.oneOfType([import_prop_types26.default.number, import_prop_types26.default.string]).isRequired,
    isFaded: import_prop_types26.default.bool.isRequired,
    isHighlighted: import_prop_types26.default.bool.isRequired
  }).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types26.default.bool
} : void 0;

// node_modules/@mui/x-charts/LineChart/AreaElement.js
var import_jsx_runtime41 = __toESM(require_jsx_runtime());
var _excluded21 = ["id", "classes", "color", "gradientId", "slots", "slotProps", "onClick"];
function getAreaElementUtilityClass(slot) {
  return generateUtilityClass("MuiAreaElement", slot);
}
var areaElementClasses = generateUtilityClasses("MuiAreaElement", ["root", "highlighted", "faded"]);
var useUtilityClasses9 = (ownerState) => {
  const {
    classes,
    id,
    isFaded,
    isHighlighted
  } = ownerState;
  const slots = {
    root: ["root", `series-${id}`, isHighlighted && "highlighted", isFaded && "faded"]
  };
  return composeClasses(slots, getAreaElementUtilityClass, classes);
};
function AreaElement(props) {
  const {
    id,
    classes: innerClasses,
    color: color2,
    gradientId,
    slots,
    slotProps,
    onClick
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded21);
  const getInteractionItemProps = useInteractionItemProps();
  const {
    isFaded,
    isHighlighted
  } = useItemHighlighted({
    seriesId: id
  });
  const ownerState = {
    id,
    classes: innerClasses,
    color: color2,
    gradientId,
    isFaded,
    isHighlighted
  };
  const classes = useUtilityClasses9(ownerState);
  const Area = (slots == null ? void 0 : slots.area) ?? AnimatedArea;
  const areaProps = useSlotProps_default({
    elementType: Area,
    externalSlotProps: slotProps == null ? void 0 : slotProps.area,
    additionalProps: _extends({}, getInteractionItemProps({
      type: "line",
      seriesId: id
    }), {
      onClick,
      cursor: onClick ? "pointer" : "unset"
    }),
    className: classes.root,
    ownerState
  });
  return (0, import_jsx_runtime41.jsx)(Area, _extends({}, other, areaProps));
}
true ? AreaElement.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types27.default.object,
  color: import_prop_types27.default.string.isRequired,
  d: import_prop_types27.default.string.isRequired,
  gradientId: import_prop_types27.default.string,
  id: import_prop_types27.default.oneOfType([import_prop_types27.default.number, import_prop_types27.default.string]).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types27.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types27.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types27.default.object
} : void 0;

// node_modules/@mui/x-charts/internals/getCurve.js
function getCurveFactory(curveType) {
  switch (curveType) {
    case "catmullRom": {
      return catmullRom_default.alpha(0.5);
    }
    case "linear": {
      return linear_default;
    }
    case "monotoneX": {
      return monotoneX;
    }
    case "monotoneY": {
      return monotoneY;
    }
    case "natural": {
      return natural_default;
    }
    case "step": {
      return step_default;
    }
    case "stepBefore": {
      return stepBefore;
    }
    case "stepAfter": {
      return stepAfter;
    }
    default:
      return monotoneX;
  }
}

// node_modules/@mui/x-charts/LineChart/AreaPlot.js
var import_jsx_runtime42 = __toESM(require_jsx_runtime());
var _excluded23 = ["slots", "slotProps", "onItemClick", "skipAnimation"];
var useAggregatedData2 = () => {
  const seriesData = useLineSeries();
  const axisData = useCartesianContext();
  const allData = React49.useMemo(() => {
    if (seriesData === void 0) {
      return [];
    }
    const {
      series,
      stackingGroups
    } = seriesData;
    const {
      xAxis,
      yAxis,
      xAxisIds,
      yAxisIds
    } = axisData;
    const defaultXAxisId = xAxisIds[0];
    const defaultYAxisId = yAxisIds[0];
    return stackingGroups.flatMap(({
      ids: groupIds
    }) => {
      return [...groupIds].reverse().map((seriesId) => {
        const {
          xAxisId: xAxisIdProp,
          yAxisId: yAxisIdProp,
          xAxisKey = defaultXAxisId,
          yAxisKey = defaultYAxisId,
          stackedData,
          data,
          connectNulls,
          baseline
        } = series[seriesId];
        const xAxisId = xAxisIdProp ?? xAxisKey;
        const yAxisId = yAxisIdProp ?? yAxisKey;
        const xScale = getValueToPositionMapper(xAxis[xAxisId].scale);
        const yScale = yAxis[yAxisId].scale;
        const xData = xAxis[xAxisId].data;
        const gradientUsed = yAxis[yAxisId].colorScale && [yAxisId, "y"] || xAxis[xAxisId].colorScale && [xAxisId, "x"] || void 0;
        if (true) {
          if (xData === void 0) {
            throw new Error(`MUI X: ${xAxisId === DEFAULT_X_AXIS_KEY ? "The first `xAxis`" : `The x-axis with id "${xAxisId}"`} should have data property to be able to display a line plot.`);
          }
          if (xData.length < stackedData.length) {
            throw new Error(`MUI X: The data length of the x axis (${xData.length} items) is lower than the length of series (${stackedData.length} items).`);
          }
        }
        const areaPath = area_default().x((d2) => xScale(d2.x)).defined((_, i) => connectNulls || data[i] != null).y0((d2) => {
          if (typeof baseline === "number") {
            return yScale(baseline);
          }
          if (baseline === "max") {
            return yScale.range()[1];
          }
          if (baseline === "min") {
            return yScale.range()[0];
          }
          const value = d2.y && yScale(d2.y[0]);
          if (Number.isNaN(value)) {
            return yScale.range()[0];
          }
          return value;
        }).y1((d2) => d2.y && yScale(d2.y[1]));
        const curve = getCurveFactory(series[seriesId].curve);
        const formattedData = (xData == null ? void 0 : xData.map((x, index) => ({
          x,
          y: stackedData[index]
        }))) ?? [];
        const d3Data = connectNulls ? formattedData.filter((_, i) => data[i] != null) : formattedData;
        const d = areaPath.curve(curve)(d3Data) || "";
        return _extends({}, series[seriesId], {
          gradientUsed,
          d,
          seriesId
        });
      });
    });
  }, [seriesData, axisData]);
  return allData;
};
function AreaPlot(props) {
  const {
    slots,
    slotProps,
    onItemClick,
    skipAnimation: inSkipAnimation
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded23);
  const skipAnimation = useSkipAnimation(inSkipAnimation);
  const getGradientId = useChartGradient();
  const completedData = useAggregatedData2();
  return (0, import_jsx_runtime42.jsx)("g", _extends({}, other, {
    children: completedData.map(({
      d,
      seriesId,
      color: color2,
      area,
      gradientUsed
    }) => !!area && (0, import_jsx_runtime42.jsx)(AreaElement, {
      id: seriesId,
      d,
      color: color2,
      gradientId: gradientUsed && getGradientId(...gradientUsed),
      slots,
      slotProps,
      onClick: onItemClick && ((event) => onItemClick(event, {
        type: "line",
        seriesId
      })),
      skipAnimation
    }, seriesId))
  }));
}
true ? AreaPlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Callback fired when a line area item is clicked.
   * @param {React.MouseEvent<SVGPathElement, MouseEvent>} event The event source of the callback.
   * @param {LineItemIdentifier} lineItemIdentifier The line item identifier.
   */
  onItemClick: import_prop_types28.default.func,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types28.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types28.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types28.default.object
} : void 0;

// node_modules/@mui/x-charts/LineChart/LinePlot.js
init_extends();
var React52 = __toESM(require_react());
var import_prop_types31 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/LineChart/LineElement.js
init_extends();
var React51 = __toESM(require_react());
var import_prop_types30 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/LineChart/AnimatedLine.js
init_extends();
var React50 = __toESM(require_react());
var import_prop_types29 = __toESM(require_prop_types());
var import_jsx_runtime43 = __toESM(require_jsx_runtime());
var _excluded24 = ["d", "skipAnimation", "ownerState"];
var LineElementPath = styled_default(animated.path, {
  name: "MuiLineElement",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})(({
  ownerState
}) => ({
  strokeWidth: 2,
  strokeLinejoin: "round",
  fill: "none",
  stroke: ownerState.gradientId && `url(#${ownerState.gradientId})` || ownerState.isHighlighted && color(ownerState.color).brighter(0.5).formatHex() || ownerState.color,
  transition: "opacity 0.2s ease-in, stroke 0.2s ease-in",
  opacity: ownerState.isFaded ? 0.3 : 1
}));
function AnimatedLine(props) {
  const {
    d,
    skipAnimation,
    ownerState
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded24);
  const stringInterpolator = useStringInterpolator(d);
  const transitionChange = useTransition([stringInterpolator], {
    from: {
      value: 0
    },
    to: {
      value: 1
    },
    enter: {
      value: 1
    },
    reset: false,
    immediate: skipAnimation
  });
  return (0, import_jsx_runtime43.jsx)(AppearingMask, {
    skipAnimation,
    id: `${ownerState.id}-line-clip`,
    children: transitionChange((style, interpolator) => (0, import_jsx_runtime43.jsx)(LineElementPath, _extends({}, other, {
      ownerState,
      d: style.value.to(interpolator)
    })))
  });
}
true ? AnimatedLine.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  d: import_prop_types29.default.string.isRequired,
  ownerState: import_prop_types29.default.shape({
    classes: import_prop_types29.default.object,
    color: import_prop_types29.default.string.isRequired,
    gradientId: import_prop_types29.default.string,
    id: import_prop_types29.default.oneOfType([import_prop_types29.default.number, import_prop_types29.default.string]).isRequired,
    isFaded: import_prop_types29.default.bool.isRequired,
    isHighlighted: import_prop_types29.default.bool.isRequired
  }).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types29.default.bool
} : void 0;

// node_modules/@mui/x-charts/LineChart/LineElement.js
var import_jsx_runtime44 = __toESM(require_jsx_runtime());
var _excluded25 = ["id", "classes", "color", "gradientId", "slots", "slotProps", "onClick"];
function getLineElementUtilityClass(slot) {
  return generateUtilityClass("MuiLineElement", slot);
}
var lineElementClasses = generateUtilityClasses("MuiLineElement", ["root", "highlighted", "faded"]);
var useUtilityClasses10 = (ownerState) => {
  const {
    classes,
    id,
    isFaded,
    isHighlighted
  } = ownerState;
  const slots = {
    root: ["root", `series-${id}`, isHighlighted && "highlighted", isFaded && "faded"]
  };
  return composeClasses(slots, getLineElementUtilityClass, classes);
};
function LineElement(props) {
  const {
    id,
    classes: innerClasses,
    color: color2,
    gradientId,
    slots,
    slotProps,
    onClick
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded25);
  const getInteractionItemProps = useInteractionItemProps();
  const {
    isFaded,
    isHighlighted
  } = useItemHighlighted({
    seriesId: id
  });
  const ownerState = {
    id,
    classes: innerClasses,
    color: color2,
    gradientId,
    isFaded,
    isHighlighted
  };
  const classes = useUtilityClasses10(ownerState);
  const Line = (slots == null ? void 0 : slots.line) ?? AnimatedLine;
  const lineProps = useSlotProps_default({
    elementType: Line,
    externalSlotProps: slotProps == null ? void 0 : slotProps.line,
    additionalProps: _extends({}, getInteractionItemProps({
      type: "line",
      seriesId: id
    }), {
      onClick,
      cursor: onClick ? "pointer" : "unset"
    }),
    className: classes.root,
    ownerState
  });
  return (0, import_jsx_runtime44.jsx)(Line, _extends({}, other, lineProps));
}
true ? LineElement.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types30.default.object,
  color: import_prop_types30.default.string.isRequired,
  d: import_prop_types30.default.string.isRequired,
  gradientId: import_prop_types30.default.string,
  id: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.string]).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types30.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types30.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types30.default.object
} : void 0;

// node_modules/@mui/x-charts/LineChart/LinePlot.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime());
var _excluded26 = ["slots", "slotProps", "skipAnimation", "onItemClick"];
var useAggregatedData3 = () => {
  const seriesData = useLineSeries();
  const axisData = useCartesianContext();
  const allData = React52.useMemo(() => {
    if (seriesData === void 0) {
      return [];
    }
    const {
      series,
      stackingGroups
    } = seriesData;
    const {
      xAxis,
      yAxis,
      xAxisIds,
      yAxisIds
    } = axisData;
    const defaultXAxisId = xAxisIds[0];
    const defaultYAxisId = yAxisIds[0];
    return stackingGroups.flatMap(({
      ids: groupIds
    }) => {
      return groupIds.flatMap((seriesId) => {
        const {
          xAxisId: xAxisIdProp,
          yAxisId: yAxisIdProp,
          xAxisKey = defaultXAxisId,
          yAxisKey = defaultYAxisId,
          stackedData,
          data,
          connectNulls
        } = series[seriesId];
        const xAxisId = xAxisIdProp ?? xAxisKey;
        const yAxisId = yAxisIdProp ?? yAxisKey;
        const xScale = getValueToPositionMapper(xAxis[xAxisId].scale);
        const yScale = yAxis[yAxisId].scale;
        const xData = xAxis[xAxisId].data;
        const gradientUsed = yAxis[yAxisId].colorScale && [yAxisId, "y"] || xAxis[xAxisId].colorScale && [xAxisId, "x"] || void 0;
        if (true) {
          if (xData === void 0) {
            throw new Error(`MUI X: ${xAxisId === DEFAULT_X_AXIS_KEY ? "The first `xAxis`" : `The x-axis with id "${xAxisId}"`} should have data property to be able to display a line plot.`);
          }
          if (xData.length < stackedData.length) {
            throw new Error(`MUI X: The data length of the x axis (${xData.length} items) is lower than the length of series (${stackedData.length} items).`);
          }
        }
        const linePath = line_default().x((d2) => xScale(d2.x)).defined((_, i) => connectNulls || data[i] != null).y((d2) => yScale(d2.y[1]));
        const formattedData = (xData == null ? void 0 : xData.map((x, index) => ({
          x,
          y: stackedData[index]
        }))) ?? [];
        const d3Data = connectNulls ? formattedData.filter((_, i) => data[i] != null) : formattedData;
        const d = linePath.curve(getCurveFactory(series[seriesId].curve))(d3Data) || "";
        return _extends({}, series[seriesId], {
          gradientUsed,
          d,
          seriesId
        });
      });
    });
  }, [seriesData, axisData]);
  return allData;
};
function LinePlot(props) {
  const {
    slots,
    slotProps,
    skipAnimation: inSkipAnimation,
    onItemClick
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded26);
  const skipAnimation = useSkipAnimation(inSkipAnimation);
  const getGradientId = useChartGradient();
  const completedData = useAggregatedData3();
  return (0, import_jsx_runtime45.jsx)("g", _extends({}, other, {
    children: completedData.map(({
      d,
      seriesId,
      color: color2,
      gradientUsed
    }) => {
      return (0, import_jsx_runtime45.jsx)(LineElement, {
        id: seriesId,
        d,
        color: color2,
        gradientId: gradientUsed && getGradientId(...gradientUsed),
        skipAnimation,
        slots,
        slotProps,
        onClick: onItemClick && ((event) => onItemClick(event, {
          type: "line",
          seriesId
        }))
      }, seriesId);
    })
  }));
}
true ? LinePlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Callback fired when a line item is clicked.
   * @param {React.MouseEvent<SVGPathElement, MouseEvent>} event The event source of the callback.
   * @param {LineItemIdentifier} lineItemIdentifier The line item identifier.
   */
  onItemClick: import_prop_types31.default.func,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types31.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types31.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types31.default.object
} : void 0;

// node_modules/@mui/x-charts/LineChart/MarkPlot.js
init_extends();
var import_prop_types34 = __toESM(require_prop_types());
var React55 = __toESM(require_react());

// node_modules/@mui/x-charts/LineChart/CircleMarkElement.js
init_extends();
var React53 = __toESM(require_react());
var import_prop_types32 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/LineChart/markElementClasses.js
function getMarkElementUtilityClass(slot) {
  return generateUtilityClass("MuiMarkElement", slot);
}
var markElementClasses = generateUtilityClasses("MuiMarkElement", ["root", "highlighted", "faded"]);
var useUtilityClasses11 = (ownerState) => {
  const {
    classes,
    id,
    isFaded,
    isHighlighted
  } = ownerState;
  const slots = {
    root: ["root", `series-${id}`, isHighlighted && "highlighted", isFaded && "faded"]
  };
  return composeClasses(slots, getMarkElementUtilityClass, classes);
};

// node_modules/@mui/x-charts/LineChart/CircleMarkElement.js
var import_jsx_runtime46 = __toESM(require_jsx_runtime());
var _excluded27 = ["x", "y", "id", "classes", "color", "dataIndex", "onClick", "skipAnimation", "shape"];
function CircleMarkElement(props) {
  var _a;
  const {
    x,
    y,
    id,
    classes: innerClasses,
    color: color2,
    dataIndex,
    onClick,
    skipAnimation,
    shape
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded27);
  if (shape !== "circle") {
    warnOnce([`MUI X: The mark element of your line chart have shape "${shape}" which is not supported when using \`experimentalRendering=true\`.`, 'Only "circle" are supported with `experimentalRendering`.'].join("\n"), "error");
  }
  const theme = useTheme();
  const getInteractionItemProps = useInteractionItemProps();
  const {
    isFaded,
    isHighlighted
  } = useItemHighlighted({
    seriesId: id
  });
  const {
    axis
  } = React53.useContext(InteractionContext);
  const position = useSpring({
    to: {
      x,
      y
    },
    immediate: skipAnimation
  });
  const ownerState = {
    id,
    classes: innerClasses,
    isHighlighted: ((_a = axis.x) == null ? void 0 : _a.index) === dataIndex || isHighlighted,
    isFaded,
    color: color2
  };
  const classes = useUtilityClasses11(ownerState);
  return (0, import_jsx_runtime46.jsx)(animated.circle, _extends({}, other, {
    cx: position.x,
    cy: position.y,
    r: 5,
    fill: (theme.vars || theme).palette.background.paper,
    stroke: color2,
    strokeWidth: 2,
    className: classes.root,
    onClick,
    cursor: onClick ? "pointer" : "unset"
  }, getInteractionItemProps({
    type: "line",
    seriesId: id,
    dataIndex
  })));
}
true ? CircleMarkElement.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types32.default.object,
  /**
   * The index to the element in the series' data array.
   */
  dataIndex: import_prop_types32.default.number.isRequired,
  id: import_prop_types32.default.oneOfType([import_prop_types32.default.number, import_prop_types32.default.string]).isRequired,
  /**
   * The shape of the marker.
   */
  shape: import_prop_types32.default.oneOf(["circle", "cross", "diamond", "square", "star", "triangle", "wye"]).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types32.default.bool
} : void 0;

// node_modules/@mui/x-charts/LineChart/MarkElement.js
init_extends();
var React54 = __toESM(require_react());
var import_prop_types33 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/internals/getSymbol.js
function getSymbol(shape) {
  const symbolNames = "circle cross diamond square star triangle wye".split(/ /);
  return symbolNames.indexOf(shape) || 0;
}

// node_modules/@mui/x-charts/LineChart/MarkElement.js
var import_jsx_runtime47 = __toESM(require_jsx_runtime());
var _excluded28 = ["x", "y", "id", "classes", "color", "shape", "dataIndex", "onClick", "skipAnimation"];
var MarkElementPath = styled_default(animated.path, {
  name: "MuiMarkElement",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})(({
  ownerState,
  theme
}) => ({
  fill: (theme.vars || theme).palette.background.paper,
  stroke: ownerState.color,
  strokeWidth: 2
}));
function MarkElement(props) {
  var _a;
  const {
    x,
    y,
    id,
    classes: innerClasses,
    color: color2,
    shape,
    dataIndex,
    onClick,
    skipAnimation
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded28);
  const getInteractionItemProps = useInteractionItemProps();
  const {
    isFaded,
    isHighlighted
  } = useItemHighlighted({
    seriesId: id
  });
  const {
    axis
  } = React54.useContext(InteractionContext);
  const position = useSpring({
    to: {
      x,
      y
    },
    immediate: skipAnimation
  });
  const ownerState = {
    id,
    classes: innerClasses,
    isHighlighted: ((_a = axis.x) == null ? void 0 : _a.index) === dataIndex || isHighlighted,
    isFaded,
    color: color2
  };
  const classes = useUtilityClasses11(ownerState);
  return (0, import_jsx_runtime47.jsx)(MarkElementPath, _extends({}, other, {
    style: {
      transform: to([position.x, position.y], (pX, pY) => `translate(${pX}px, ${pY}px)`),
      transformOrigin: to([position.x, position.y], (pX, pY) => `${pX}px ${pY}px`)
    },
    ownerState,
    className: classes.root,
    d: Symbol(symbolsFill[getSymbol(shape)])(),
    onClick,
    cursor: onClick ? "pointer" : "unset"
  }, getInteractionItemProps({
    type: "line",
    seriesId: id,
    dataIndex
  })));
}
true ? MarkElement.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types33.default.object,
  /**
   * The index to the element in the series' data array.
   */
  dataIndex: import_prop_types33.default.number.isRequired,
  id: import_prop_types33.default.oneOfType([import_prop_types33.default.number, import_prop_types33.default.string]).isRequired,
  /**
   * The shape of the marker.
   */
  shape: import_prop_types33.default.oneOf(["circle", "cross", "diamond", "square", "star", "triangle", "wye"]).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types33.default.bool
} : void 0;

// node_modules/@mui/x-charts/LineChart/MarkPlot.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime());
var _excluded29 = ["slots", "slotProps", "skipAnimation", "onItemClick", "experimentalRendering"];
function MarkPlot(props) {
  const {
    slots,
    slotProps,
    skipAnimation: inSkipAnimation,
    onItemClick,
    experimentalRendering
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded29);
  const skipAnimation = useSkipAnimation(inSkipAnimation);
  const seriesData = useLineSeries();
  const axisData = useCartesianContext();
  const chartId = useChartId();
  const drawingArea = useDrawingArea();
  const Mark = (slots == null ? void 0 : slots.mark) ?? (experimentalRendering ? CircleMarkElement : MarkElement);
  if (seriesData === void 0) {
    return null;
  }
  const {
    series,
    stackingGroups
  } = seriesData;
  const {
    xAxis,
    yAxis,
    xAxisIds,
    yAxisIds
  } = axisData;
  const defaultXAxisId = xAxisIds[0];
  const defaultYAxisId = yAxisIds[0];
  return (0, import_jsx_runtime48.jsx)("g", _extends({}, other, {
    children: stackingGroups.flatMap(({
      ids: groupIds
    }) => {
      return groupIds.map((seriesId) => {
        const {
          xAxisId: xAxisIdProp,
          yAxisId: yAxisIdProp,
          xAxisKey = defaultXAxisId,
          yAxisKey = defaultYAxisId,
          stackedData,
          data,
          showMark = true
        } = series[seriesId];
        if (showMark === false) {
          return null;
        }
        const xAxisId = xAxisIdProp ?? xAxisKey;
        const yAxisId = yAxisIdProp ?? yAxisKey;
        const xScale = getValueToPositionMapper(xAxis[xAxisId].scale);
        const yScale = yAxis[yAxisId].scale;
        const xData = xAxis[xAxisId].data;
        if (xData === void 0) {
          throw new Error(`MUI X: ${xAxisId === DEFAULT_X_AXIS_KEY ? "The first `xAxis`" : `The x-axis with id "${xAxisId}"`} should have data property to be able to display a line plot.`);
        }
        const clipId = cleanId(`${chartId}-${seriesId}-line-clip`);
        const colorGetter = getColor_default3(series[seriesId], xAxis[xAxisId], yAxis[yAxisId]);
        return (0, import_jsx_runtime48.jsx)("g", {
          clipPath: `url(#${clipId})`,
          children: xData == null ? void 0 : xData.map((x, index) => {
            const value = data[index] == null ? null : stackedData[index][1];
            return {
              x: xScale(x),
              y: value === null ? null : yScale(value),
              position: x,
              value,
              index
            };
          }).filter(({
            x,
            y,
            index,
            position,
            value
          }) => {
            if (value === null || y === null) {
              return false;
            }
            if (!drawingArea.isPointInside({
              x,
              y
            })) {
              return false;
            }
            if (showMark === true) {
              return true;
            }
            return showMark({
              x,
              y,
              index,
              position,
              value
            });
          }).map(({
            x,
            y,
            index
          }) => {
            return (0, import_jsx_runtime48.jsx)(Mark, _extends({
              id: seriesId,
              dataIndex: index,
              shape: "circle",
              color: colorGetter(index),
              x,
              y,
              skipAnimation,
              onClick: onItemClick && ((event) => onItemClick(event, {
                type: "line",
                seriesId,
                dataIndex: index
              }))
            }, slotProps == null ? void 0 : slotProps.mark), `${seriesId}-${index}`);
          })
        }, seriesId);
      });
    })
  }));
}
true ? MarkPlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true` the mark element will only be able to render circle.
   * Giving fewer customization options, but saving around 40ms per 1.000 marks.
   * @default false
   */
  experimentalRendering: import_prop_types34.default.bool,
  /**
   * Callback fired when a line mark item is clicked.
   * @param {React.MouseEvent<SVGPathElement, MouseEvent>} event The event source of the callback.
   * @param {LineItemIdentifier} lineItemIdentifier The line mark item identifier.
   */
  onItemClick: import_prop_types34.default.func,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types34.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types34.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types34.default.object
} : void 0;

// node_modules/@mui/x-charts/LineChart/LineHighlightPlot.js
init_extends();
var React57 = __toESM(require_react());
var import_prop_types36 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/LineChart/LineHighlightElement.js
init_extends();
var React56 = __toESM(require_react());
var import_prop_types35 = __toESM(require_prop_types());
var import_jsx_runtime49 = __toESM(require_jsx_runtime());
var _excluded30 = ["x", "y", "id", "classes", "color"];
function getHighlightElementUtilityClass(slot) {
  return generateUtilityClass("MuiHighlightElement", slot);
}
var lineHighlightElementClasses = generateUtilityClasses("MuiHighlightElement", ["root"]);
var useUtilityClasses12 = (ownerState) => {
  const {
    classes,
    id
  } = ownerState;
  const slots = {
    root: ["root", `series-${id}`]
  };
  return composeClasses(slots, getHighlightElementUtilityClass, classes);
};
var HighlightElement = styled_default("circle", {
  name: "MuiHighlightElement",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})(({
  ownerState
}) => ({
  transform: `translate(${ownerState.x}px, ${ownerState.y}px)`,
  transformOrigin: `${ownerState.x}px ${ownerState.y}px`,
  fill: ownerState.color
}));
function LineHighlightElement(props) {
  const {
    x,
    y,
    id,
    classes: innerClasses,
    color: color2
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded30);
  const ownerState = {
    id,
    classes: innerClasses,
    color: color2,
    x,
    y
  };
  const classes = useUtilityClasses12(ownerState);
  return (0, import_jsx_runtime49.jsx)(HighlightElement, _extends({
    pointerEvents: "none",
    ownerState,
    className: classes.root,
    cx: 0,
    cy: 0,
    r: other.r === void 0 ? 5 : other.r
  }, other));
}
true ? LineHighlightElement.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types35.default.object,
  id: import_prop_types35.default.oneOfType([import_prop_types35.default.number, import_prop_types35.default.string]).isRequired
} : void 0;

// node_modules/@mui/x-charts/LineChart/LineHighlightPlot.js
var import_jsx_runtime50 = __toESM(require_jsx_runtime());
var _excluded31 = ["slots", "slotProps"];
function LineHighlightPlot(props) {
  var _a;
  const {
    slots,
    slotProps
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded31);
  const seriesData = useLineSeries();
  const axisData = useCartesianContext();
  const drawingArea = useDrawingArea();
  const {
    axis
  } = React57.useContext(InteractionContext);
  const highlightedIndex = (_a = axis.x) == null ? void 0 : _a.index;
  if (highlightedIndex === void 0) {
    return null;
  }
  if (seriesData === void 0) {
    return null;
  }
  const {
    series,
    stackingGroups
  } = seriesData;
  const {
    xAxis,
    yAxis,
    xAxisIds,
    yAxisIds
  } = axisData;
  const defaultXAxisId = xAxisIds[0];
  const defaultYAxisId = yAxisIds[0];
  const Element = (slots == null ? void 0 : slots.lineHighlight) ?? LineHighlightElement;
  return (0, import_jsx_runtime50.jsx)("g", _extends({}, other, {
    children: stackingGroups.flatMap(({
      ids: groupIds
    }) => {
      return groupIds.flatMap((seriesId) => {
        const {
          xAxisId: xAxisIdProp,
          yAxisId: yAxisIdProp,
          xAxisKey = defaultXAxisId,
          yAxisKey = defaultYAxisId,
          stackedData,
          data,
          disableHighlight
        } = series[seriesId];
        const xAxisId = xAxisIdProp ?? xAxisKey;
        const yAxisId = yAxisIdProp ?? yAxisKey;
        if (disableHighlight || data[highlightedIndex] == null) {
          return null;
        }
        const xScale = getValueToPositionMapper(xAxis[xAxisId].scale);
        const yScale = yAxis[yAxisId].scale;
        const xData = xAxis[xAxisId].data;
        if (xData === void 0) {
          throw new Error(`MUI X: ${xAxisId === DEFAULT_X_AXIS_KEY ? "The first `xAxis`" : `The x-axis with id "${xAxisId}"`} should have data property to be able to display a line plot.`);
        }
        const x = xScale(xData[highlightedIndex]);
        const y = yScale(stackedData[highlightedIndex][1]);
        if (!drawingArea.isPointInside({
          x,
          y
        })) {
          return null;
        }
        const colorGetter = getColor_default3(series[seriesId], xAxis[xAxisId], yAxis[yAxisId]);
        return (0, import_jsx_runtime50.jsx)(Element, _extends({
          id: seriesId,
          color: colorGetter(highlightedIndex),
          x,
          y
        }, slotProps == null ? void 0 : slotProps.lineHighlight), `${seriesId}`);
      });
    })
  }));
}
true ? LineHighlightPlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types36.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types36.default.object
} : void 0;

// node_modules/@mui/x-charts/LineChart/LineChart.js
var import_jsx_runtime51 = __toESM(require_jsx_runtime());
var LineChart = React58.forwardRef(function LineChart2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiLineChart"
  });
  const {
    chartContainerProps,
    axisClickHandlerProps,
    gridProps,
    clipPathProps,
    clipPathGroupProps,
    areaPlotProps,
    linePlotProps,
    markPlotProps,
    overlayProps,
    chartsAxisProps,
    axisHighlightProps,
    lineHighlightPlotProps,
    legendProps,
    tooltipProps,
    children
  } = useLineChartProps(props);
  return (0, import_jsx_runtime51.jsxs)(ResponsiveChartContainer, _extends({
    ref
  }, chartContainerProps, {
    children: [props.onAxisClick && (0, import_jsx_runtime51.jsx)(ChartsOnAxisClickHandler, _extends({}, axisClickHandlerProps)), (0, import_jsx_runtime51.jsx)(ChartsGrid, _extends({}, gridProps)), (0, import_jsx_runtime51.jsxs)("g", _extends({}, clipPathGroupProps, {
      children: [(0, import_jsx_runtime51.jsx)(AreaPlot, _extends({}, areaPlotProps)), (0, import_jsx_runtime51.jsx)(LinePlot, _extends({}, linePlotProps)), (0, import_jsx_runtime51.jsx)(ChartsOverlay, _extends({}, overlayProps)), (0, import_jsx_runtime51.jsx)(ChartsAxisHighlight, _extends({}, axisHighlightProps))]
    })), (0, import_jsx_runtime51.jsx)(ChartsAxis, _extends({}, chartsAxisProps)), (0, import_jsx_runtime51.jsx)("g", {
      "data-drawing-container": true,
      children: (0, import_jsx_runtime51.jsx)(MarkPlot, _extends({}, markPlotProps))
    }), (0, import_jsx_runtime51.jsx)(LineHighlightPlot, _extends({}, lineHighlightPlotProps)), (0, import_jsx_runtime51.jsx)(ChartsLegend, _extends({}, legendProps)), !props.loading && (0, import_jsx_runtime51.jsx)(ChartsTooltip, _extends({}, tooltipProps)), (0, import_jsx_runtime51.jsx)(ChartsClipPath, _extends({}, clipPathProps)), children]
  }));
});
true ? LineChart.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The configuration of axes highlight.
   * @see See {@link https://mui.com/x/react-charts/highlighting highlighting docs} for more details.
   * @default { x: 'line' }
   */
  axisHighlight: import_prop_types37.default.shape({
    x: import_prop_types37.default.oneOf(["band", "line", "none"]),
    y: import_prop_types37.default.oneOf(["band", "line", "none"])
  }),
  /**
   * Indicate which axis to display the bottom of the charts.
   * Can be a string (the id of the axis) or an object `ChartsXAxisProps`.
   * @default xAxisIds[0] The id of the first provided axis
   */
  bottomAxis: import_prop_types37.default.oneOfType([import_prop_types37.default.object, import_prop_types37.default.string]),
  children: import_prop_types37.default.node,
  className: import_prop_types37.default.string,
  /**
   * Color palette used to colorize multiple series.
   * @default blueberryTwilightPalette
   */
  colors: import_prop_types37.default.oneOfType([import_prop_types37.default.arrayOf(import_prop_types37.default.string), import_prop_types37.default.func]),
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types37.default.arrayOf(import_prop_types37.default.object),
  desc: import_prop_types37.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types37.default.bool,
  /**
   * If `true`, render the line highlight item.
   */
  disableLineItemHighlight: import_prop_types37.default.bool,
  /**
   * If `true` marks will render `<circle />` instead of `<path />` and drop theme override for faster rendering.
   */
  experimentalMarkRendering: import_prop_types37.default.bool,
  /**
   * Option to display a cartesian grid in the background.
   */
  grid: import_prop_types37.default.shape({
    horizontal: import_prop_types37.default.bool,
    vertical: import_prop_types37.default.bool
  }),
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types37.default.number,
  /**
   * The item currently highlighted. Turns highlighting into a controlled prop.
   */
  highlightedItem: import_prop_types37.default.shape({
    dataIndex: import_prop_types37.default.number,
    seriesId: import_prop_types37.default.oneOfType([import_prop_types37.default.number, import_prop_types37.default.string])
  }),
  /**
   * Indicate which axis to display the left of the charts.
   * Can be a string (the id of the axis) or an object `ChartsYAxisProps`.
   * @default yAxisIds[0] The id of the first provided axis
   */
  leftAxis: import_prop_types37.default.oneOfType([import_prop_types37.default.object, import_prop_types37.default.string]),
  /**
   * @deprecated Consider using `slotProps.legend` instead.
   */
  legend: import_prop_types37.default.shape({
    classes: import_prop_types37.default.object,
    direction: import_prop_types37.default.oneOf(["column", "row"]),
    hidden: import_prop_types37.default.bool,
    itemGap: import_prop_types37.default.number,
    itemMarkHeight: import_prop_types37.default.number,
    itemMarkWidth: import_prop_types37.default.number,
    labelStyle: import_prop_types37.default.object,
    markGap: import_prop_types37.default.number,
    onItemClick: import_prop_types37.default.func,
    padding: import_prop_types37.default.oneOfType([import_prop_types37.default.number, import_prop_types37.default.shape({
      bottom: import_prop_types37.default.number,
      left: import_prop_types37.default.number,
      right: import_prop_types37.default.number,
      top: import_prop_types37.default.number
    })]),
    position: import_prop_types37.default.shape({
      horizontal: import_prop_types37.default.oneOf(["left", "middle", "right"]).isRequired,
      vertical: import_prop_types37.default.oneOf(["bottom", "middle", "top"]).isRequired
    }),
    slotProps: import_prop_types37.default.object,
    slots: import_prop_types37.default.object
  }),
  /**
   * If `true`, a loading overlay is displayed.
   * @default false
   */
  loading: import_prop_types37.default.bool,
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   * Accepts an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   * @default object Depends on the charts type.
   */
  margin: import_prop_types37.default.shape({
    bottom: import_prop_types37.default.number,
    left: import_prop_types37.default.number,
    right: import_prop_types37.default.number,
    top: import_prop_types37.default.number
  }),
  /**
   * Callback fired when an area element is clicked.
   */
  onAreaClick: import_prop_types37.default.func,
  /**
   * The function called for onClick events.
   * The second argument contains information about all line/bar elements at the current mouse position.
   * @param {MouseEvent} event The mouse event recorded on the `<svg/>` element.
   * @param {null | AxisData} data The data about the clicked axis and items associated with it.
   */
  onAxisClick: import_prop_types37.default.func,
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types37.default.func,
  /**
   * Callback fired when a line element is clicked.
   */
  onLineClick: import_prop_types37.default.func,
  /**
   * Callback fired when a mark element is clicked.
   */
  onMarkClick: import_prop_types37.default.func,
  /**
   * The chart will try to wait for the parent container to resolve its size
   * before it renders for the first time.
   *
   * This can be useful in some scenarios where the chart appear to grow after
   * the first render, like when used inside a grid.
   *
   * @default false
   */
  resolveSizeBeforeRender: import_prop_types37.default.bool,
  /**
   * Indicate which axis to display the right of the charts.
   * Can be a string (the id of the axis) or an object `ChartsYAxisProps`.
   * @default null
   */
  rightAxis: import_prop_types37.default.oneOfType([import_prop_types37.default.object, import_prop_types37.default.string]),
  /**
   * The series to display in the line chart.
   * An array of [[LineSeriesType]] objects.
   */
  series: import_prop_types37.default.arrayOf(import_prop_types37.default.object).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types37.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types37.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types37.default.object,
  sx: import_prop_types37.default.oneOfType([import_prop_types37.default.arrayOf(import_prop_types37.default.oneOfType([import_prop_types37.default.func, import_prop_types37.default.object, import_prop_types37.default.bool])), import_prop_types37.default.func, import_prop_types37.default.object]),
  title: import_prop_types37.default.string,
  /**
   * The configuration of the tooltip.
   * @see See {@link https://mui.com/x/react-charts/tooltip/ tooltip docs} for more details.
   * @default { trigger: 'item' }
   */
  tooltip: import_prop_types37.default.shape({
    axisContent: import_prop_types37.default.elementType,
    classes: import_prop_types37.default.object,
    itemContent: import_prop_types37.default.elementType,
    slotProps: import_prop_types37.default.object,
    slots: import_prop_types37.default.object,
    trigger: import_prop_types37.default.oneOf(["axis", "item", "none"])
  }),
  /**
   * Indicate which axis to display the top of the charts.
   * Can be a string (the id of the axis) or an object `ChartsXAxisProps`.
   * @default null
   */
  topAxis: import_prop_types37.default.oneOfType([import_prop_types37.default.object, import_prop_types37.default.string]),
  viewBox: import_prop_types37.default.shape({
    height: import_prop_types37.default.number,
    width: import_prop_types37.default.number,
    x: import_prop_types37.default.number,
    y: import_prop_types37.default.number
  }),
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types37.default.number,
  /**
   * The configuration of the x-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  xAxis: import_prop_types37.default.arrayOf(import_prop_types37.default.shape({
    classes: import_prop_types37.default.object,
    colorMap: import_prop_types37.default.oneOfType([import_prop_types37.default.shape({
      colors: import_prop_types37.default.arrayOf(import_prop_types37.default.string).isRequired,
      type: import_prop_types37.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types37.default.string,
      values: import_prop_types37.default.arrayOf(import_prop_types37.default.oneOfType([import_prop_types37.default.instanceOf(Date), import_prop_types37.default.number, import_prop_types37.default.string]).isRequired)
    }), import_prop_types37.default.shape({
      color: import_prop_types37.default.oneOfType([import_prop_types37.default.arrayOf(import_prop_types37.default.string.isRequired), import_prop_types37.default.func]).isRequired,
      max: import_prop_types37.default.oneOfType([import_prop_types37.default.instanceOf(Date), import_prop_types37.default.number]),
      min: import_prop_types37.default.oneOfType([import_prop_types37.default.instanceOf(Date), import_prop_types37.default.number]),
      type: import_prop_types37.default.oneOf(["continuous"]).isRequired
    }), import_prop_types37.default.shape({
      colors: import_prop_types37.default.arrayOf(import_prop_types37.default.string).isRequired,
      thresholds: import_prop_types37.default.arrayOf(import_prop_types37.default.oneOfType([import_prop_types37.default.instanceOf(Date), import_prop_types37.default.number]).isRequired).isRequired,
      type: import_prop_types37.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types37.default.array,
    dataKey: import_prop_types37.default.string,
    disableLine: import_prop_types37.default.bool,
    disableTicks: import_prop_types37.default.bool,
    fill: import_prop_types37.default.string,
    hideTooltip: import_prop_types37.default.bool,
    id: import_prop_types37.default.oneOfType([import_prop_types37.default.number, import_prop_types37.default.string]),
    label: import_prop_types37.default.string,
    labelFontSize: import_prop_types37.default.number,
    labelStyle: import_prop_types37.default.object,
    max: import_prop_types37.default.oneOfType([import_prop_types37.default.instanceOf(Date), import_prop_types37.default.number]),
    min: import_prop_types37.default.oneOfType([import_prop_types37.default.instanceOf(Date), import_prop_types37.default.number]),
    position: import_prop_types37.default.oneOf(["bottom", "top"]),
    reverse: import_prop_types37.default.bool,
    scaleType: import_prop_types37.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types37.default.object,
    slots: import_prop_types37.default.object,
    stroke: import_prop_types37.default.string,
    sx: import_prop_types37.default.oneOfType([import_prop_types37.default.arrayOf(import_prop_types37.default.oneOfType([import_prop_types37.default.func, import_prop_types37.default.object, import_prop_types37.default.bool])), import_prop_types37.default.func, import_prop_types37.default.object]),
    tickFontSize: import_prop_types37.default.number,
    tickInterval: import_prop_types37.default.oneOfType([import_prop_types37.default.oneOf(["auto"]), import_prop_types37.default.array, import_prop_types37.default.func]),
    tickLabelInterval: import_prop_types37.default.oneOfType([import_prop_types37.default.oneOf(["auto"]), import_prop_types37.default.func]),
    tickLabelPlacement: import_prop_types37.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types37.default.object,
    tickMaxStep: import_prop_types37.default.number,
    tickMinStep: import_prop_types37.default.number,
    tickNumber: import_prop_types37.default.number,
    tickPlacement: import_prop_types37.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types37.default.number,
    valueFormatter: import_prop_types37.default.func
  })),
  /**
   * The configuration of the y-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  yAxis: import_prop_types37.default.arrayOf(import_prop_types37.default.shape({
    classes: import_prop_types37.default.object,
    colorMap: import_prop_types37.default.oneOfType([import_prop_types37.default.shape({
      colors: import_prop_types37.default.arrayOf(import_prop_types37.default.string).isRequired,
      type: import_prop_types37.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types37.default.string,
      values: import_prop_types37.default.arrayOf(import_prop_types37.default.oneOfType([import_prop_types37.default.instanceOf(Date), import_prop_types37.default.number, import_prop_types37.default.string]).isRequired)
    }), import_prop_types37.default.shape({
      color: import_prop_types37.default.oneOfType([import_prop_types37.default.arrayOf(import_prop_types37.default.string.isRequired), import_prop_types37.default.func]).isRequired,
      max: import_prop_types37.default.oneOfType([import_prop_types37.default.instanceOf(Date), import_prop_types37.default.number]),
      min: import_prop_types37.default.oneOfType([import_prop_types37.default.instanceOf(Date), import_prop_types37.default.number]),
      type: import_prop_types37.default.oneOf(["continuous"]).isRequired
    }), import_prop_types37.default.shape({
      colors: import_prop_types37.default.arrayOf(import_prop_types37.default.string).isRequired,
      thresholds: import_prop_types37.default.arrayOf(import_prop_types37.default.oneOfType([import_prop_types37.default.instanceOf(Date), import_prop_types37.default.number]).isRequired).isRequired,
      type: import_prop_types37.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types37.default.array,
    dataKey: import_prop_types37.default.string,
    disableLine: import_prop_types37.default.bool,
    disableTicks: import_prop_types37.default.bool,
    fill: import_prop_types37.default.string,
    hideTooltip: import_prop_types37.default.bool,
    id: import_prop_types37.default.oneOfType([import_prop_types37.default.number, import_prop_types37.default.string]),
    label: import_prop_types37.default.string,
    labelFontSize: import_prop_types37.default.number,
    labelStyle: import_prop_types37.default.object,
    max: import_prop_types37.default.oneOfType([import_prop_types37.default.instanceOf(Date), import_prop_types37.default.number]),
    min: import_prop_types37.default.oneOfType([import_prop_types37.default.instanceOf(Date), import_prop_types37.default.number]),
    position: import_prop_types37.default.oneOf(["left", "right"]),
    reverse: import_prop_types37.default.bool,
    scaleType: import_prop_types37.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types37.default.object,
    slots: import_prop_types37.default.object,
    stroke: import_prop_types37.default.string,
    sx: import_prop_types37.default.oneOfType([import_prop_types37.default.arrayOf(import_prop_types37.default.oneOfType([import_prop_types37.default.func, import_prop_types37.default.object, import_prop_types37.default.bool])), import_prop_types37.default.func, import_prop_types37.default.object]),
    tickFontSize: import_prop_types37.default.number,
    tickInterval: import_prop_types37.default.oneOfType([import_prop_types37.default.oneOf(["auto"]), import_prop_types37.default.array, import_prop_types37.default.func]),
    tickLabelInterval: import_prop_types37.default.oneOfType([import_prop_types37.default.oneOf(["auto"]), import_prop_types37.default.func]),
    tickLabelPlacement: import_prop_types37.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types37.default.object,
    tickMaxStep: import_prop_types37.default.number,
    tickMinStep: import_prop_types37.default.number,
    tickNumber: import_prop_types37.default.number,
    tickPlacement: import_prop_types37.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types37.default.number,
    valueFormatter: import_prop_types37.default.func
  }))
} : void 0;

// node_modules/@mui/x-charts/PieChart/PieChart.js
init_extends();
var React65 = __toESM(require_react());
var import_prop_types43 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/PieChart/PiePlot.js
var React64 = __toESM(require_react());
var import_prop_types42 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/PieChart/PieArcPlot.js
init_extends();
var React61 = __toESM(require_react());
var import_prop_types39 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/PieChart/PieArc.js
init_extends();
var React59 = __toESM(require_react());
var import_prop_types38 = __toESM(require_prop_types());
var import_jsx_runtime52 = __toESM(require_jsx_runtime());
var _excluded32 = ["classes", "color", "cornerRadius", "dataIndex", "endAngle", "id", "innerRadius", "isFaded", "isHighlighted", "onClick", "outerRadius", "paddingAngle", "startAngle", "highlightScope"];
function getPieArcUtilityClass(slot) {
  return generateUtilityClass("MuiPieArc", slot);
}
var pieArcClasses = generateUtilityClasses("MuiPieArc", ["root", "highlighted", "faded"]);
var useUtilityClasses13 = (ownerState) => {
  const {
    classes,
    id,
    isFaded,
    isHighlighted
  } = ownerState;
  const slots = {
    root: ["root", `series-${id}`, isHighlighted && "highlighted", isFaded && "faded"]
  };
  return composeClasses(slots, getPieArcUtilityClass, classes);
};
var PieArcRoot = styled_default(animated.path, {
  name: "MuiPieArc",
  slot: "Root",
  overridesResolver: (_, styles) => styles.arc
})(({
  theme
}) => ({
  stroke: (theme.vars || theme).palette.background.paper,
  strokeWidth: 1,
  strokeLinejoin: "round"
}));
function PieArc(props) {
  const {
    classes: innerClasses,
    color: color2,
    cornerRadius,
    dataIndex,
    endAngle,
    id,
    innerRadius,
    isFaded,
    isHighlighted,
    onClick,
    outerRadius,
    paddingAngle,
    startAngle
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded32);
  const ownerState = {
    id,
    dataIndex,
    classes: innerClasses,
    color: color2,
    isFaded,
    isHighlighted
  };
  const classes = useUtilityClasses13(ownerState);
  const getInteractionItemProps = useInteractionItemProps();
  return (0, import_jsx_runtime52.jsx)(PieArcRoot, _extends({
    d: to([startAngle, endAngle, paddingAngle, innerRadius, outerRadius, cornerRadius], (sA, eA, pA, iR, oR, cR) => arc_default().cornerRadius(cR)({
      padAngle: pA,
      startAngle: sA,
      endAngle: eA,
      innerRadius: iR,
      outerRadius: oR
    })),
    visibility: to([startAngle, endAngle], (sA, eA) => sA === eA ? "hidden" : "visible"),
    onClick,
    cursor: onClick ? "pointer" : "unset",
    ownerState,
    className: classes.root
  }, other, getInteractionItemProps({
    type: "pie",
    seriesId: id,
    dataIndex
  })));
}
true ? PieArc.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types38.default.object,
  dataIndex: import_prop_types38.default.number.isRequired,
  /**
   * @deprecated Use the `isFaded` or `isHighlighted` props instead.
   */
  highlightScope: import_prop_types38.default.shape({
    fade: import_prop_types38.default.oneOf(["global", "none", "series"]),
    faded: import_prop_types38.default.oneOf(["global", "none", "series"]),
    highlight: import_prop_types38.default.oneOf(["item", "none", "series"]),
    highlighted: import_prop_types38.default.oneOf(["item", "none", "series"])
  }),
  id: import_prop_types38.default.oneOfType([import_prop_types38.default.number, import_prop_types38.default.string]).isRequired,
  isFaded: import_prop_types38.default.bool.isRequired,
  isHighlighted: import_prop_types38.default.bool.isRequired
} : void 0;

// node_modules/@mui/x-charts/PieChart/dataTransform/transition.js
var defaultTransitionConfig = {
  keys: (item) => item.id,
  from: ({
    innerRadius,
    outerRadius,
    cornerRadius,
    startAngle,
    endAngle,
    paddingAngle,
    color: color2,
    isFaded
  }) => ({
    innerRadius,
    outerRadius: (innerRadius + outerRadius) / 2,
    cornerRadius,
    startAngle: (startAngle + endAngle) / 2,
    endAngle: (startAngle + endAngle) / 2,
    paddingAngle,
    fill: color2,
    opacity: isFaded ? 0.3 : 1
  }),
  leave: ({
    innerRadius,
    startAngle,
    endAngle
  }) => ({
    innerRadius,
    outerRadius: innerRadius,
    startAngle: (startAngle + endAngle) / 2,
    endAngle: (startAngle + endAngle) / 2
  }),
  enter: ({
    innerRadius,
    outerRadius,
    startAngle,
    endAngle
  }) => ({
    innerRadius,
    outerRadius,
    startAngle,
    endAngle
  }),
  update: ({
    innerRadius,
    outerRadius,
    cornerRadius,
    startAngle,
    endAngle,
    paddingAngle,
    color: color2,
    isFaded
  }) => ({
    innerRadius,
    outerRadius,
    cornerRadius,
    startAngle,
    endAngle,
    paddingAngle,
    fill: color2,
    opacity: isFaded ? 0.3 : 1
  }),
  config: {
    tension: 120,
    friction: 14,
    clamp: true
  }
};
var defaultLabelTransitionConfig = {
  keys: (item) => item.id,
  from: ({
    innerRadius,
    outerRadius,
    arcLabelRadius,
    cornerRadius,
    startAngle,
    endAngle,
    paddingAngle
  }) => ({
    innerRadius,
    outerRadius: (innerRadius + outerRadius) / 2,
    cornerRadius,
    arcLabelRadius,
    startAngle: (startAngle + endAngle) / 2,
    endAngle: (startAngle + endAngle) / 2,
    paddingAngle,
    opacity: 0
  }),
  leave: ({
    innerRadius,
    startAngle,
    endAngle
  }) => ({
    innerRadius,
    outerRadius: innerRadius,
    arcLabelRadius: innerRadius,
    startAngle: (startAngle + endAngle) / 2,
    endAngle: (startAngle + endAngle) / 2,
    opacity: 0
  }),
  enter: ({
    innerRadius,
    outerRadius,
    startAngle,
    endAngle,
    arcLabelRadius
  }) => ({
    innerRadius,
    outerRadius,
    startAngle,
    endAngle,
    arcLabelRadius,
    opacity: 1
  }),
  update: ({
    innerRadius,
    outerRadius,
    cornerRadius,
    startAngle,
    endAngle,
    paddingAngle,
    arcLabelRadius
  }) => ({
    innerRadius,
    outerRadius,
    cornerRadius,
    startAngle,
    endAngle,
    paddingAngle,
    arcLabelRadius,
    opacity: 1
  }),
  config: {
    tension: 120,
    friction: 14,
    clamp: true
  }
};

// node_modules/@mui/x-charts/PieChart/dataTransform/useTransformData.js
init_extends();
var React60 = __toESM(require_react());
function useTransformData(series) {
  const {
    id: seriesId,
    data,
    faded,
    highlighted,
    paddingAngle: basePaddingAngle = 0,
    innerRadius: baseInnerRadius = 0,
    arcLabelRadius: baseArcLabelRadius,
    outerRadius: baseOuterRadius,
    cornerRadius: baseCornerRadius = 0
  } = series;
  const {
    isFaded: isItemFaded,
    isHighlighted: isItemHighlighted
  } = useHighlighted();
  const dataWithHighlight = React60.useMemo(() => data.map((item, itemIndex) => {
    const currentItem = {
      seriesId,
      dataIndex: itemIndex
    };
    const isHighlighted = isItemHighlighted(currentItem);
    const isFaded = !isHighlighted && isItemFaded(currentItem);
    const attributesOverride = _extends({
      additionalRadius: 0
    }, isFaded && faded || isHighlighted && highlighted || {});
    const paddingAngle = Math.max(0, Math.PI * (attributesOverride.paddingAngle ?? basePaddingAngle) / 180);
    const innerRadius = Math.max(0, attributesOverride.innerRadius ?? baseInnerRadius);
    const outerRadius = Math.max(0, attributesOverride.outerRadius ?? baseOuterRadius + attributesOverride.additionalRadius);
    const cornerRadius = attributesOverride.cornerRadius ?? baseCornerRadius;
    const arcLabelRadius = attributesOverride.arcLabelRadius ?? baseArcLabelRadius ?? (innerRadius + outerRadius) / 2;
    return _extends({}, item, attributesOverride, {
      isFaded,
      isHighlighted,
      paddingAngle,
      innerRadius,
      outerRadius,
      cornerRadius,
      arcLabelRadius
    });
  }), [baseCornerRadius, baseInnerRadius, baseOuterRadius, basePaddingAngle, baseArcLabelRadius, data, faded, highlighted, isItemFaded, isItemHighlighted, seriesId]);
  return dataWithHighlight;
}

// node_modules/@mui/x-charts/PieChart/PieArcPlot.js
var import_jsx_runtime53 = __toESM(require_jsx_runtime());
var _excluded33 = ["slots", "slotProps", "innerRadius", "outerRadius", "cornerRadius", "paddingAngle", "id", "highlighted", "faded", "data", "onItemClick", "skipAnimation"];
var _excluded210 = ["startAngle", "endAngle", "paddingAngle", "innerRadius", "arcLabelRadius", "outerRadius", "cornerRadius"];
function PieArcPlot(props) {
  const {
    slots,
    slotProps,
    innerRadius = 0,
    outerRadius,
    cornerRadius = 0,
    paddingAngle = 0,
    id,
    highlighted,
    faded = {
      additionalRadius: -5
    },
    data,
    onItemClick,
    skipAnimation
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded33);
  const transformedData = useTransformData({
    innerRadius,
    outerRadius,
    cornerRadius,
    paddingAngle,
    id,
    highlighted,
    faded,
    data
  });
  const transition = useTransition(transformedData, _extends({}, defaultTransitionConfig, {
    immediate: skipAnimation
  }));
  const {
    highlightScope
  } = useHighlighted();
  if (data.length === 0) {
    return null;
  }
  const Arc = (slots == null ? void 0 : slots.pieArc) ?? PieArc;
  return (0, import_jsx_runtime53.jsx)("g", _extends({}, other, {
    children: transition((_ref, item, _, index) => {
      let {
        startAngle,
        endAngle,
        paddingAngle: pA,
        innerRadius: iR,
        outerRadius: oR,
        cornerRadius: cR
      } = _ref, style = _objectWithoutPropertiesLoose(_ref, _excluded210);
      return (0, import_jsx_runtime53.jsx)(Arc, _extends({
        startAngle,
        endAngle,
        paddingAngle: pA,
        innerRadius: iR,
        outerRadius: oR,
        cornerRadius: cR,
        style,
        id,
        color: item.color,
        dataIndex: index,
        highlightScope,
        isFaded: item.isFaded,
        isHighlighted: item.isHighlighted,
        onClick: onItemClick && ((event) => {
          onItemClick(event, {
            type: "pie",
            seriesId: id,
            dataIndex: index
          }, item);
        })
      }, slotProps == null ? void 0 : slotProps.pieArc));
    })
  }));
}
true ? PieArcPlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The radius between circle center and the arc label in px.
   * @default (innerRadius - outerRadius) / 2
   */
  arcLabelRadius: import_prop_types39.default.number,
  /**
   * The radius applied to arc corners (similar to border radius).
   * @default 0
   */
  cornerRadius: import_prop_types39.default.number,
  data: import_prop_types39.default.arrayOf(import_prop_types39.default.shape({
    color: import_prop_types39.default.string.isRequired,
    endAngle: import_prop_types39.default.number.isRequired,
    formattedValue: import_prop_types39.default.string.isRequired,
    id: import_prop_types39.default.oneOfType([import_prop_types39.default.number, import_prop_types39.default.string]).isRequired,
    index: import_prop_types39.default.number.isRequired,
    label: import_prop_types39.default.oneOfType([import_prop_types39.default.func, import_prop_types39.default.string]),
    padAngle: import_prop_types39.default.number.isRequired,
    startAngle: import_prop_types39.default.number.isRequired,
    value: import_prop_types39.default.number.isRequired
  })).isRequired,
  /**
   * Override the arc attributes when it is faded.
   * @default { additionalRadius: -5 }
   */
  faded: import_prop_types39.default.shape({
    additionalRadius: import_prop_types39.default.number,
    arcLabelRadius: import_prop_types39.default.number,
    color: import_prop_types39.default.string,
    cornerRadius: import_prop_types39.default.number,
    innerRadius: import_prop_types39.default.number,
    outerRadius: import_prop_types39.default.number,
    paddingAngle: import_prop_types39.default.number
  }),
  /**
   * Override the arc attributes when it is highlighted.
   */
  highlighted: import_prop_types39.default.shape({
    additionalRadius: import_prop_types39.default.number,
    arcLabelRadius: import_prop_types39.default.number,
    color: import_prop_types39.default.string,
    cornerRadius: import_prop_types39.default.number,
    innerRadius: import_prop_types39.default.number,
    outerRadius: import_prop_types39.default.number,
    paddingAngle: import_prop_types39.default.number
  }),
  id: import_prop_types39.default.oneOfType([import_prop_types39.default.number, import_prop_types39.default.string]).isRequired,
  /**
   * The radius between circle center and the beginning of the arc.
   * @default 0
   */
  innerRadius: import_prop_types39.default.number,
  /**
   * Callback fired when a pie item is clicked.
   * @param {React.MouseEvent<SVGPathElement, MouseEvent>} event The event source of the callback.
   * @param {PieItemIdentifier} pieItemIdentifier The pie item identifier.
   * @param {DefaultizedPieValueType} item The pie item.
   */
  onItemClick: import_prop_types39.default.func,
  /**
   * The radius between circle center and the end of the arc.
   */
  outerRadius: import_prop_types39.default.number.isRequired,
  /**
   * The padding angle (deg) between two arcs.
   * @default 0
   */
  paddingAngle: import_prop_types39.default.number,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types39.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types39.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types39.default.object
} : void 0;

// node_modules/@mui/x-charts/PieChart/PieArcLabelPlot.js
init_extends();
var React63 = __toESM(require_react());
var import_prop_types41 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/PieChart/PieArcLabel.js
init_extends();
var React62 = __toESM(require_react());
var import_prop_types40 = __toESM(require_prop_types());
var import_jsx_runtime54 = __toESM(require_jsx_runtime());
var _excluded34 = ["id", "classes", "color", "startAngle", "endAngle", "paddingAngle", "arcLabelRadius", "innerRadius", "outerRadius", "cornerRadius", "formattedArcLabel", "isHighlighted", "isFaded", "style"];
function getPieArcLabelUtilityClass(slot) {
  return generateUtilityClass("MuiPieArcLabel", slot);
}
var pieArcLabelClasses = generateUtilityClasses("MuiPieArcLabel", ["root", "highlighted", "faded"]);
var useUtilityClasses14 = (ownerState) => {
  const {
    classes,
    id,
    isFaded,
    isHighlighted
  } = ownerState;
  const slots = {
    root: ["root", `series-${id}`, isHighlighted && "highlighted", isFaded && "faded"]
  };
  return composeClasses(slots, getPieArcLabelUtilityClass, classes);
};
var PieArcLabelRoot = styled_default(animated.text, {
  name: "MuiPieArcLabel",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})(({
  theme
}) => ({
  fill: (theme.vars || theme).palette.text.primary,
  textAnchor: "middle",
  dominantBaseline: "middle",
  pointerEvents: "none"
}));
var getLabelPosition = (formattedArcLabel, variable) => (startAngle, endAngle, padAngle, arcLabelRadius, cornerRadius) => {
  if (!formattedArcLabel) {
    return 0;
  }
  const [x, y] = arc_default().cornerRadius(cornerRadius).centroid({
    padAngle,
    startAngle,
    endAngle,
    innerRadius: arcLabelRadius,
    outerRadius: arcLabelRadius
  });
  if (variable === "x") {
    return x;
  }
  return y;
};
function PieArcLabel(props) {
  const {
    id,
    classes: innerClasses,
    color: color2,
    startAngle,
    endAngle,
    paddingAngle,
    arcLabelRadius,
    cornerRadius,
    formattedArcLabel,
    isHighlighted,
    isFaded,
    style
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded34);
  const ownerState = {
    id,
    classes: innerClasses,
    color: color2,
    isFaded,
    isHighlighted
  };
  const classes = useUtilityClasses14(ownerState);
  return (0, import_jsx_runtime54.jsx)(PieArcLabelRoot, _extends({
    className: classes.root
  }, other, {
    style: _extends({
      x: to([startAngle, endAngle, paddingAngle, arcLabelRadius, cornerRadius], getLabelPosition(formattedArcLabel, "x")),
      y: to([startAngle, endAngle, paddingAngle, arcLabelRadius, cornerRadius], getLabelPosition(formattedArcLabel, "y"))
    }, style),
    children: formattedArcLabel
  }));
}
true ? PieArcLabel.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types40.default.object,
  color: import_prop_types40.default.string.isRequired,
  formattedArcLabel: import_prop_types40.default.string,
  id: import_prop_types40.default.oneOfType([import_prop_types40.default.number, import_prop_types40.default.string]).isRequired,
  isFaded: import_prop_types40.default.bool.isRequired,
  isHighlighted: import_prop_types40.default.bool.isRequired
} : void 0;

// node_modules/@mui/x-charts/PieChart/PieArcLabelPlot.js
var import_jsx_runtime55 = __toESM(require_jsx_runtime());
var _excluded35 = ["arcLabel", "arcLabelMinAngle", "arcLabelRadius", "cornerRadius", "data", "faded", "highlighted", "id", "innerRadius", "outerRadius", "paddingAngle", "skipAnimation", "slotProps", "slots"];
var _excluded211 = ["startAngle", "endAngle", "paddingAngle", "innerRadius", "outerRadius", "arcLabelRadius", "cornerRadius"];
var RATIO = 180 / Math.PI;
function getItemLabel(arcLabel, arcLabelMinAngle, item) {
  var _a;
  if (!arcLabel) {
    return null;
  }
  const angle = (item.endAngle - item.startAngle) * RATIO;
  if (angle < arcLabelMinAngle) {
    return null;
  }
  switch (arcLabel) {
    case "label":
      return getLabel(item.label, "arc");
    case "value":
      return (_a = item.value) == null ? void 0 : _a.toString();
    case "formattedValue":
      return item.formattedValue;
    default:
      return arcLabel(_extends({}, item, {
        label: getLabel(item.label, "arc")
      }));
  }
}
function PieArcLabelPlot(props) {
  const {
    arcLabel,
    arcLabelMinAngle = 0,
    arcLabelRadius,
    cornerRadius = 0,
    data,
    faded = {
      additionalRadius: -5
    },
    highlighted,
    id,
    innerRadius,
    outerRadius,
    paddingAngle = 0,
    skipAnimation,
    slotProps,
    slots
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded35);
  const transformedData = useTransformData({
    innerRadius,
    outerRadius,
    arcLabelRadius,
    cornerRadius,
    paddingAngle,
    id,
    highlighted,
    faded,
    data
  });
  const transition = useTransition(transformedData, _extends({}, defaultLabelTransitionConfig, {
    immediate: skipAnimation
  }));
  if (data.length === 0) {
    return null;
  }
  const ArcLabel = (slots == null ? void 0 : slots.pieArcLabel) ?? PieArcLabel;
  return (0, import_jsx_runtime55.jsx)("g", _extends({}, other, {
    children: transition((_ref, item) => {
      let {
        startAngle,
        endAngle,
        paddingAngle: pA,
        innerRadius: iR,
        outerRadius: oR,
        arcLabelRadius: aLR,
        cornerRadius: cR
      } = _ref, style = _objectWithoutPropertiesLoose(_ref, _excluded211);
      return (0, import_jsx_runtime55.jsx)(ArcLabel, _extends({
        startAngle,
        endAngle,
        paddingAngle: pA,
        innerRadius: iR,
        outerRadius: oR,
        arcLabelRadius: aLR,
        cornerRadius: cR,
        style,
        id,
        color: item.color,
        isFaded: item.isFaded,
        isHighlighted: item.isHighlighted,
        formattedArcLabel: getItemLabel(arcLabel, arcLabelMinAngle, item)
      }, slotProps == null ? void 0 : slotProps.pieArcLabel));
    })
  }));
}
true ? PieArcLabelPlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The label displayed into the arc.
   */
  arcLabel: import_prop_types41.default.oneOfType([import_prop_types41.default.oneOf(["formattedValue", "label", "value"]), import_prop_types41.default.func]),
  /**
   * The minimal angle required to display the arc label.
   * @default 0
   */
  arcLabelMinAngle: import_prop_types41.default.number,
  /**
   * The radius between circle center and the arc label in px.
   * @default (innerRadius - outerRadius) / 2
   */
  arcLabelRadius: import_prop_types41.default.number,
  /**
   * The radius applied to arc corners (similar to border radius).
   * @default 0
   */
  cornerRadius: import_prop_types41.default.number,
  data: import_prop_types41.default.arrayOf(import_prop_types41.default.shape({
    color: import_prop_types41.default.string.isRequired,
    endAngle: import_prop_types41.default.number.isRequired,
    formattedValue: import_prop_types41.default.string.isRequired,
    id: import_prop_types41.default.oneOfType([import_prop_types41.default.number, import_prop_types41.default.string]).isRequired,
    index: import_prop_types41.default.number.isRequired,
    label: import_prop_types41.default.oneOfType([import_prop_types41.default.func, import_prop_types41.default.string]),
    padAngle: import_prop_types41.default.number.isRequired,
    startAngle: import_prop_types41.default.number.isRequired,
    value: import_prop_types41.default.number.isRequired
  })).isRequired,
  /**
   * Override the arc attributes when it is faded.
   * @default { additionalRadius: -5 }
   */
  faded: import_prop_types41.default.shape({
    additionalRadius: import_prop_types41.default.number,
    arcLabelRadius: import_prop_types41.default.number,
    color: import_prop_types41.default.string,
    cornerRadius: import_prop_types41.default.number,
    innerRadius: import_prop_types41.default.number,
    outerRadius: import_prop_types41.default.number,
    paddingAngle: import_prop_types41.default.number
  }),
  /**
   * Override the arc attributes when it is highlighted.
   */
  highlighted: import_prop_types41.default.shape({
    additionalRadius: import_prop_types41.default.number,
    arcLabelRadius: import_prop_types41.default.number,
    color: import_prop_types41.default.string,
    cornerRadius: import_prop_types41.default.number,
    innerRadius: import_prop_types41.default.number,
    outerRadius: import_prop_types41.default.number,
    paddingAngle: import_prop_types41.default.number
  }),
  id: import_prop_types41.default.oneOfType([import_prop_types41.default.number, import_prop_types41.default.string]).isRequired,
  /**
   * The radius between circle center and the beginning of the arc.
   * @default 0
   */
  innerRadius: import_prop_types41.default.number,
  /**
   * The radius between circle center and the end of the arc.
   */
  outerRadius: import_prop_types41.default.number.isRequired,
  /**
   * The padding angle (deg) between two arcs.
   * @default 0
   */
  paddingAngle: import_prop_types41.default.number,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types41.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types41.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types41.default.object
} : void 0;

// node_modules/@mui/x-charts/PieChart/getPieCoordinates.js
function getPieCoordinates(series, drawing) {
  const {
    height,
    width
  } = drawing;
  const {
    cx: cxParam,
    cy: cyParam
  } = series;
  const availableRadius = Math.min(width, height) / 2;
  const cx = getPercentageValue(cxParam ?? "50%", width);
  const cy = getPercentageValue(cyParam ?? "50%", height);
  return {
    cx,
    cy,
    availableRadius
  };
}

// node_modules/@mui/x-charts/PieChart/PiePlot.js
var import_jsx_runtime56 = __toESM(require_jsx_runtime());
function PiePlot(props) {
  const {
    skipAnimation: inSkipAnimation,
    slots,
    slotProps,
    onItemClick
  } = props;
  const seriesData = usePieSeries();
  const {
    left,
    top,
    width,
    height
  } = React64.useContext(DrawingContext);
  const skipAnimation = useSkipAnimation(inSkipAnimation);
  if (seriesData === void 0) {
    return null;
  }
  const {
    series,
    seriesOrder
  } = seriesData;
  return (0, import_jsx_runtime56.jsxs)("g", {
    children: [seriesOrder.map((seriesId) => {
      const {
        innerRadius: innerRadiusParam,
        outerRadius: outerRadiusParam,
        cornerRadius,
        paddingAngle,
        data,
        cx: cxParam,
        cy: cyParam,
        highlighted,
        faded
      } = series[seriesId];
      const {
        cx,
        cy,
        availableRadius
      } = getPieCoordinates({
        cx: cxParam,
        cy: cyParam
      }, {
        width,
        height
      });
      const outerRadius = getPercentageValue(outerRadiusParam ?? availableRadius, availableRadius);
      const innerRadius = getPercentageValue(innerRadiusParam ?? 0, availableRadius);
      return (0, import_jsx_runtime56.jsx)("g", {
        transform: `translate(${left + cx}, ${top + cy})`,
        children: (0, import_jsx_runtime56.jsx)(PieArcPlot, {
          innerRadius,
          outerRadius,
          cornerRadius,
          paddingAngle,
          id: seriesId,
          data,
          skipAnimation,
          highlighted,
          faded,
          onItemClick,
          slots,
          slotProps
        })
      }, seriesId);
    }), seriesOrder.map((seriesId) => {
      const {
        innerRadius: innerRadiusParam,
        outerRadius: outerRadiusParam,
        arcLabelRadius: arcLabelRadiusParam,
        cornerRadius,
        paddingAngle,
        arcLabel,
        arcLabelMinAngle,
        data,
        cx: cxParam,
        cy: cyParam
      } = series[seriesId];
      const {
        cx,
        cy,
        availableRadius
      } = getPieCoordinates({
        cx: cxParam,
        cy: cyParam
      }, {
        width,
        height
      });
      const outerRadius = getPercentageValue(outerRadiusParam ?? availableRadius, availableRadius);
      const innerRadius = getPercentageValue(innerRadiusParam ?? 0, availableRadius);
      const arcLabelRadius = arcLabelRadiusParam === void 0 ? (outerRadius + innerRadius) / 2 : getPercentageValue(arcLabelRadiusParam, availableRadius);
      return (0, import_jsx_runtime56.jsx)("g", {
        transform: `translate(${left + cx}, ${top + cy})`,
        children: (0, import_jsx_runtime56.jsx)(PieArcLabelPlot, {
          innerRadius,
          outerRadius: outerRadius ?? availableRadius,
          arcLabelRadius,
          cornerRadius,
          paddingAngle,
          id: seriesId,
          data,
          skipAnimation,
          arcLabel,
          arcLabelMinAngle,
          slots,
          slotProps
        })
      }, seriesId);
    })]
  });
}
true ? PiePlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Callback fired when a pie item is clicked.
   * @param {React.MouseEvent<SVGPathElement, MouseEvent>} event The event source of the callback.
   * @param {PieItemIdentifier} pieItemIdentifier The pie item identifier.
   * @param {DefaultizedPieValueType} item The pie item.
   */
  onItemClick: import_prop_types42.default.func,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types42.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types42.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types42.default.object
} : void 0;

// node_modules/@mui/x-charts/PieChart/PieChart.js
var import_jsx_runtime57 = __toESM(require_jsx_runtime());
var _excluded36 = ["xAxis", "yAxis", "series", "width", "height", "margin", "colors", "sx", "tooltip", "axisHighlight", "skipAnimation", "legend", "topAxis", "leftAxis", "rightAxis", "bottomAxis", "children", "slots", "slotProps", "onItemClick", "loading", "highlightedItem", "onHighlightChange", "className"];
var defaultMargin = {
  top: 5,
  bottom: 5,
  left: 5,
  right: 100
};
var defaultRTLMargin = {
  top: 5,
  bottom: 5,
  left: 100,
  right: 5
};
var PieChart = React65.forwardRef(function PieChart2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPieChart"
  });
  const {
    xAxis,
    yAxis,
    series,
    width,
    height,
    margin: marginProps,
    colors,
    sx,
    tooltip = {
      trigger: "item"
    },
    axisHighlight = {
      x: "none",
      y: "none"
    },
    skipAnimation,
    legend: legendProps,
    topAxis = null,
    leftAxis = null,
    rightAxis = null,
    bottomAxis = null,
    children,
    slots,
    slotProps,
    onItemClick,
    loading,
    highlightedItem,
    onHighlightChange,
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded36);
  const isRtl = useRtl();
  const margin = _extends({}, isRtl ? defaultRTLMargin : defaultMargin, marginProps);
  const legend = _extends({
    direction: "column",
    position: {
      vertical: "middle",
      horizontal: isRtl ? "left" : "right"
    }
  }, legendProps);
  return (0, import_jsx_runtime57.jsxs)(ResponsiveChartContainer, _extends({}, other, {
    ref,
    series: series.map((s) => _extends({
      type: "pie"
    }, s)),
    width,
    height,
    margin,
    xAxis: xAxis ?? [{
      id: DEFAULT_X_AXIS_KEY,
      scaleType: "point",
      data: [...new Array(Math.max(...series.map((s) => s.data.length)))].map((_, index) => index)
    }],
    yAxis,
    colors,
    sx,
    disableAxisListener: (tooltip == null ? void 0 : tooltip.trigger) !== "axis" && (axisHighlight == null ? void 0 : axisHighlight.x) === "none" && (axisHighlight == null ? void 0 : axisHighlight.y) === "none",
    highlightedItem,
    onHighlightChange,
    className,
    skipAnimation,
    children: [(0, import_jsx_runtime57.jsx)(ChartsAxis, {
      topAxis,
      leftAxis,
      rightAxis,
      bottomAxis,
      slots,
      slotProps
    }), (0, import_jsx_runtime57.jsx)(PiePlot, {
      slots,
      slotProps,
      onItemClick
    }), (0, import_jsx_runtime57.jsx)(ChartsOverlay, {
      loading,
      slots,
      slotProps
    }), (0, import_jsx_runtime57.jsx)(ChartsLegend, _extends({}, legend, {
      slots,
      slotProps
    })), (0, import_jsx_runtime57.jsx)(ChartsAxisHighlight, _extends({}, axisHighlight)), !loading && (0, import_jsx_runtime57.jsx)(ChartsTooltip, _extends({}, tooltip, {
      slots,
      slotProps
    })), children]
  }));
});
true ? PieChart.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The configuration of axes highlight.
   * @see See {@link https://mui.com/x/react-charts/highlighting highlighting docs} for more details.
   * @default { x: 'none', y: 'none' }
   */
  axisHighlight: import_prop_types43.default.shape({
    x: import_prop_types43.default.oneOf(["band", "line", "none"]),
    y: import_prop_types43.default.oneOf(["band", "line", "none"])
  }),
  /**
   * Indicate which axis to display the bottom of the charts.
   * Can be a string (the id of the axis) or an object `ChartsXAxisProps`.
   * @default null
   */
  bottomAxis: import_prop_types43.default.oneOfType([import_prop_types43.default.object, import_prop_types43.default.string]),
  children: import_prop_types43.default.node,
  className: import_prop_types43.default.string,
  /**
   * Color palette used to colorize multiple series.
   * @default blueberryTwilightPalette
   */
  colors: import_prop_types43.default.oneOfType([import_prop_types43.default.arrayOf(import_prop_types43.default.string), import_prop_types43.default.func]),
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types43.default.arrayOf(import_prop_types43.default.object),
  desc: import_prop_types43.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types43.default.bool,
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types43.default.number,
  /**
   * The item currently highlighted. Turns highlighting into a controlled prop.
   */
  highlightedItem: import_prop_types43.default.shape({
    dataIndex: import_prop_types43.default.number,
    seriesId: import_prop_types43.default.oneOfType([import_prop_types43.default.number, import_prop_types43.default.string])
  }),
  /**
   * Indicate which axis to display the left of the charts.
   * Can be a string (the id of the axis) or an object `ChartsYAxisProps`.
   * @default null
   */
  leftAxis: import_prop_types43.default.oneOfType([import_prop_types43.default.object, import_prop_types43.default.string]),
  /**
   * The props of the legend.
   * @default { direction: 'column', position: { vertical: 'middle', horizontal: 'right' } }
   * @deprecated Consider using `slotProps.legend` instead.
   */
  legend: import_prop_types43.default.shape({
    classes: import_prop_types43.default.object,
    direction: import_prop_types43.default.oneOf(["column", "row"]),
    hidden: import_prop_types43.default.bool,
    itemGap: import_prop_types43.default.number,
    itemMarkHeight: import_prop_types43.default.number,
    itemMarkWidth: import_prop_types43.default.number,
    labelStyle: import_prop_types43.default.object,
    markGap: import_prop_types43.default.number,
    onItemClick: import_prop_types43.default.func,
    padding: import_prop_types43.default.oneOfType([import_prop_types43.default.number, import_prop_types43.default.shape({
      bottom: import_prop_types43.default.number,
      left: import_prop_types43.default.number,
      right: import_prop_types43.default.number,
      top: import_prop_types43.default.number
    })]),
    position: import_prop_types43.default.shape({
      horizontal: import_prop_types43.default.oneOf(["left", "middle", "right"]).isRequired,
      vertical: import_prop_types43.default.oneOf(["bottom", "middle", "top"]).isRequired
    }),
    slotProps: import_prop_types43.default.object,
    slots: import_prop_types43.default.object
  }),
  /**
   * If `true`, a loading overlay is displayed.
   * @default false
   */
  loading: import_prop_types43.default.bool,
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   * Accepts an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   * @default object Depends on the charts type.
   */
  margin: import_prop_types43.default.shape({
    bottom: import_prop_types43.default.number,
    left: import_prop_types43.default.number,
    right: import_prop_types43.default.number,
    top: import_prop_types43.default.number
  }),
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types43.default.func,
  /**
   * Callback fired when a pie arc is clicked.
   */
  onItemClick: import_prop_types43.default.func,
  /**
   * The chart will try to wait for the parent container to resolve its size
   * before it renders for the first time.
   *
   * This can be useful in some scenarios where the chart appear to grow after
   * the first render, like when used inside a grid.
   *
   * @default false
   */
  resolveSizeBeforeRender: import_prop_types43.default.bool,
  /**
   * Indicate which axis to display the right of the charts.
   * Can be a string (the id of the axis) or an object `ChartsYAxisProps`.
   * @default null
   */
  rightAxis: import_prop_types43.default.oneOfType([import_prop_types43.default.object, import_prop_types43.default.string]),
  /**
   * The series to display in the pie chart.
   * An array of [[PieSeriesType]] objects.
   */
  series: import_prop_types43.default.arrayOf(import_prop_types43.default.object).isRequired,
  /**
   * If `true`, animations are skipped.
   * If unset or `false`, the animations respects the user's `prefers-reduced-motion` setting.
   */
  skipAnimation: import_prop_types43.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types43.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types43.default.object,
  sx: import_prop_types43.default.oneOfType([import_prop_types43.default.arrayOf(import_prop_types43.default.oneOfType([import_prop_types43.default.func, import_prop_types43.default.object, import_prop_types43.default.bool])), import_prop_types43.default.func, import_prop_types43.default.object]),
  title: import_prop_types43.default.string,
  /**
   * The configuration of the tooltip.
   * @see See {@link https://mui.com/x/react-charts/tooltip/ tooltip docs} for more details.
   * @default { trigger: 'item' }
   */
  tooltip: import_prop_types43.default.shape({
    axisContent: import_prop_types43.default.elementType,
    classes: import_prop_types43.default.object,
    itemContent: import_prop_types43.default.elementType,
    slotProps: import_prop_types43.default.object,
    slots: import_prop_types43.default.object,
    trigger: import_prop_types43.default.oneOf(["axis", "item", "none"])
  }),
  /**
   * Indicate which axis to display the top of the charts.
   * Can be a string (the id of the axis) or an object `ChartsXAxisProps`.
   * @default null
   */
  topAxis: import_prop_types43.default.oneOfType([import_prop_types43.default.object, import_prop_types43.default.string]),
  viewBox: import_prop_types43.default.shape({
    height: import_prop_types43.default.number,
    width: import_prop_types43.default.number,
    x: import_prop_types43.default.number,
    y: import_prop_types43.default.number
  }),
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types43.default.number,
  /**
   * The configuration of the x-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  xAxis: import_prop_types43.default.arrayOf(import_prop_types43.default.shape({
    classes: import_prop_types43.default.object,
    colorMap: import_prop_types43.default.oneOfType([import_prop_types43.default.shape({
      colors: import_prop_types43.default.arrayOf(import_prop_types43.default.string).isRequired,
      type: import_prop_types43.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types43.default.string,
      values: import_prop_types43.default.arrayOf(import_prop_types43.default.oneOfType([import_prop_types43.default.instanceOf(Date), import_prop_types43.default.number, import_prop_types43.default.string]).isRequired)
    }), import_prop_types43.default.shape({
      color: import_prop_types43.default.oneOfType([import_prop_types43.default.arrayOf(import_prop_types43.default.string.isRequired), import_prop_types43.default.func]).isRequired,
      max: import_prop_types43.default.oneOfType([import_prop_types43.default.instanceOf(Date), import_prop_types43.default.number]),
      min: import_prop_types43.default.oneOfType([import_prop_types43.default.instanceOf(Date), import_prop_types43.default.number]),
      type: import_prop_types43.default.oneOf(["continuous"]).isRequired
    }), import_prop_types43.default.shape({
      colors: import_prop_types43.default.arrayOf(import_prop_types43.default.string).isRequired,
      thresholds: import_prop_types43.default.arrayOf(import_prop_types43.default.oneOfType([import_prop_types43.default.instanceOf(Date), import_prop_types43.default.number]).isRequired).isRequired,
      type: import_prop_types43.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types43.default.array,
    dataKey: import_prop_types43.default.string,
    disableLine: import_prop_types43.default.bool,
    disableTicks: import_prop_types43.default.bool,
    fill: import_prop_types43.default.string,
    hideTooltip: import_prop_types43.default.bool,
    id: import_prop_types43.default.oneOfType([import_prop_types43.default.number, import_prop_types43.default.string]),
    label: import_prop_types43.default.string,
    labelFontSize: import_prop_types43.default.number,
    labelStyle: import_prop_types43.default.object,
    max: import_prop_types43.default.oneOfType([import_prop_types43.default.instanceOf(Date), import_prop_types43.default.number]),
    min: import_prop_types43.default.oneOfType([import_prop_types43.default.instanceOf(Date), import_prop_types43.default.number]),
    position: import_prop_types43.default.oneOf(["bottom", "top"]),
    reverse: import_prop_types43.default.bool,
    scaleType: import_prop_types43.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types43.default.object,
    slots: import_prop_types43.default.object,
    stroke: import_prop_types43.default.string,
    sx: import_prop_types43.default.oneOfType([import_prop_types43.default.arrayOf(import_prop_types43.default.oneOfType([import_prop_types43.default.func, import_prop_types43.default.object, import_prop_types43.default.bool])), import_prop_types43.default.func, import_prop_types43.default.object]),
    tickFontSize: import_prop_types43.default.number,
    tickInterval: import_prop_types43.default.oneOfType([import_prop_types43.default.oneOf(["auto"]), import_prop_types43.default.array, import_prop_types43.default.func]),
    tickLabelInterval: import_prop_types43.default.oneOfType([import_prop_types43.default.oneOf(["auto"]), import_prop_types43.default.func]),
    tickLabelPlacement: import_prop_types43.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types43.default.object,
    tickMaxStep: import_prop_types43.default.number,
    tickMinStep: import_prop_types43.default.number,
    tickNumber: import_prop_types43.default.number,
    tickPlacement: import_prop_types43.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types43.default.number,
    valueFormatter: import_prop_types43.default.func
  })),
  /**
   * The configuration of the y-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  yAxis: import_prop_types43.default.arrayOf(import_prop_types43.default.shape({
    classes: import_prop_types43.default.object,
    colorMap: import_prop_types43.default.oneOfType([import_prop_types43.default.shape({
      colors: import_prop_types43.default.arrayOf(import_prop_types43.default.string).isRequired,
      type: import_prop_types43.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types43.default.string,
      values: import_prop_types43.default.arrayOf(import_prop_types43.default.oneOfType([import_prop_types43.default.instanceOf(Date), import_prop_types43.default.number, import_prop_types43.default.string]).isRequired)
    }), import_prop_types43.default.shape({
      color: import_prop_types43.default.oneOfType([import_prop_types43.default.arrayOf(import_prop_types43.default.string.isRequired), import_prop_types43.default.func]).isRequired,
      max: import_prop_types43.default.oneOfType([import_prop_types43.default.instanceOf(Date), import_prop_types43.default.number]),
      min: import_prop_types43.default.oneOfType([import_prop_types43.default.instanceOf(Date), import_prop_types43.default.number]),
      type: import_prop_types43.default.oneOf(["continuous"]).isRequired
    }), import_prop_types43.default.shape({
      colors: import_prop_types43.default.arrayOf(import_prop_types43.default.string).isRequired,
      thresholds: import_prop_types43.default.arrayOf(import_prop_types43.default.oneOfType([import_prop_types43.default.instanceOf(Date), import_prop_types43.default.number]).isRequired).isRequired,
      type: import_prop_types43.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types43.default.array,
    dataKey: import_prop_types43.default.string,
    disableLine: import_prop_types43.default.bool,
    disableTicks: import_prop_types43.default.bool,
    fill: import_prop_types43.default.string,
    hideTooltip: import_prop_types43.default.bool,
    id: import_prop_types43.default.oneOfType([import_prop_types43.default.number, import_prop_types43.default.string]),
    label: import_prop_types43.default.string,
    labelFontSize: import_prop_types43.default.number,
    labelStyle: import_prop_types43.default.object,
    max: import_prop_types43.default.oneOfType([import_prop_types43.default.instanceOf(Date), import_prop_types43.default.number]),
    min: import_prop_types43.default.oneOfType([import_prop_types43.default.instanceOf(Date), import_prop_types43.default.number]),
    position: import_prop_types43.default.oneOf(["left", "right"]),
    reverse: import_prop_types43.default.bool,
    scaleType: import_prop_types43.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types43.default.object,
    slots: import_prop_types43.default.object,
    stroke: import_prop_types43.default.string,
    sx: import_prop_types43.default.oneOfType([import_prop_types43.default.arrayOf(import_prop_types43.default.oneOfType([import_prop_types43.default.func, import_prop_types43.default.object, import_prop_types43.default.bool])), import_prop_types43.default.func, import_prop_types43.default.object]),
    tickFontSize: import_prop_types43.default.number,
    tickInterval: import_prop_types43.default.oneOfType([import_prop_types43.default.oneOf(["auto"]), import_prop_types43.default.array, import_prop_types43.default.func]),
    tickLabelInterval: import_prop_types43.default.oneOfType([import_prop_types43.default.oneOf(["auto"]), import_prop_types43.default.func]),
    tickLabelPlacement: import_prop_types43.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types43.default.object,
    tickMaxStep: import_prop_types43.default.number,
    tickMinStep: import_prop_types43.default.number,
    tickNumber: import_prop_types43.default.number,
    tickPlacement: import_prop_types43.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types43.default.number,
    valueFormatter: import_prop_types43.default.func
  }))
} : void 0;

// node_modules/@mui/x-charts/ScatterChart/ScatterChart.js
init_extends();
var React68 = __toESM(require_react());
var import_prop_types46 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/ScatterChart/ScatterPlot.js
init_extends();
var React67 = __toESM(require_react());
var import_prop_types45 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/ScatterChart/Scatter.js
init_extends();
var React66 = __toESM(require_react());
var import_prop_types44 = __toESM(require_prop_types());
var import_jsx_runtime58 = __toESM(require_jsx_runtime());
function Scatter(props) {
  const {
    series,
    xScale,
    yScale,
    color: color2,
    colorGetter,
    markerSize,
    onItemClick
  } = props;
  const drawingArea = useDrawingArea();
  const {
    useVoronoiInteraction
  } = React66.useContext(InteractionContext);
  const skipInteractionHandlers = useVoronoiInteraction || series.disableHover;
  const getInteractionItemProps = useInteractionItemProps(skipInteractionHandlers);
  const {
    isFaded,
    isHighlighted
  } = useHighlighted();
  const cleanData = React66.useMemo(() => {
    const getXPosition = getValueToPositionMapper(xScale);
    const getYPosition = getValueToPositionMapper(yScale);
    const temp = [];
    for (let i = 0; i < series.data.length; i += 1) {
      const scatterPoint = series.data[i];
      const x = getXPosition(scatterPoint.x);
      const y = getYPosition(scatterPoint.y);
      const isInRange = drawingArea.isPointInside({
        x,
        y
      });
      const pointCtx = {
        type: "scatter",
        seriesId: series.id,
        dataIndex: i
      };
      if (isInRange) {
        const currentItem = {
          seriesId: pointCtx.seriesId,
          dataIndex: pointCtx.dataIndex
        };
        const isItemHighlighted = isHighlighted(currentItem);
        temp.push({
          x,
          y,
          isHighlighted: isItemHighlighted,
          isFaded: !isItemHighlighted && isFaded(currentItem),
          interactionProps: getInteractionItemProps(pointCtx),
          id: scatterPoint.id,
          dataIndex: i,
          color: colorGetter ? colorGetter(i) : color2
        });
      }
    }
    return temp;
  }, [xScale, yScale, drawingArea, series.data, series.id, isHighlighted, isFaded, getInteractionItemProps, colorGetter, color2]);
  return (0, import_jsx_runtime58.jsx)("g", {
    children: cleanData.map((dataPoint) => (0, import_jsx_runtime58.jsx)("circle", _extends({
      cx: 0,
      cy: 0,
      r: (dataPoint.isHighlighted ? 1.2 : 1) * markerSize,
      transform: `translate(${dataPoint.x}, ${dataPoint.y})`,
      fill: dataPoint.color,
      opacity: dataPoint.isFaded && 0.3 || 1,
      onClick: onItemClick && ((event) => onItemClick(event, {
        type: "scatter",
        seriesId: series.id,
        dataIndex: dataPoint.dataIndex
      })),
      cursor: onItemClick ? "pointer" : "unset"
    }, dataPoint.interactionProps), dataPoint.id))
  });
}
true ? Scatter.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  color: import_prop_types44.default.string.isRequired,
  colorGetter: import_prop_types44.default.func,
  markerSize: import_prop_types44.default.number.isRequired,
  /**
   * Callback fired when clicking on a scatter item.
   * @param {MouseEvent} event Mouse event recorded on the `<svg/>` element.
   * @param {ScatterItemIdentifier} scatterItemIdentifier The scatter item identifier.
   */
  onItemClick: import_prop_types44.default.func,
  series: import_prop_types44.default.object.isRequired,
  xScale: import_prop_types44.default.func.isRequired,
  yScale: import_prop_types44.default.func.isRequired
} : void 0;

// node_modules/@mui/x-charts/ScatterChart/ScatterPlot.js
var import_jsx_runtime59 = __toESM(require_jsx_runtime());
function ScatterPlot(props) {
  const {
    slots,
    slotProps,
    onItemClick
  } = props;
  const seriesData = useScatterSeries();
  const axisData = useCartesianContext();
  const {
    zAxis,
    zAxisIds
  } = React67.useContext(ZAxisContext);
  if (seriesData === void 0) {
    return null;
  }
  const {
    series,
    seriesOrder
  } = seriesData;
  const {
    xAxis,
    yAxis,
    xAxisIds,
    yAxisIds
  } = axisData;
  const defaultXAxisId = xAxisIds[0];
  const defaultYAxisId = yAxisIds[0];
  const defaultZAxisId = zAxisIds[0];
  const ScatterItems = (slots == null ? void 0 : slots.scatter) ?? Scatter;
  return (0, import_jsx_runtime59.jsx)(React67.Fragment, {
    children: seriesOrder.map((seriesId) => {
      const {
        id,
        xAxisKey,
        yAxisKey,
        zAxisKey,
        xAxisId,
        yAxisId,
        zAxisId,
        markerSize,
        color: color2
      } = series[seriesId];
      const colorGetter = getColor_default2(series[seriesId], xAxis[xAxisId ?? xAxisKey ?? defaultXAxisId], yAxis[yAxisId ?? yAxisKey ?? defaultYAxisId], zAxis[zAxisId ?? zAxisKey ?? defaultZAxisId]);
      const xScale = xAxis[xAxisId ?? xAxisKey ?? defaultXAxisId].scale;
      const yScale = yAxis[yAxisId ?? yAxisKey ?? defaultYAxisId].scale;
      return (0, import_jsx_runtime59.jsx)(ScatterItems, _extends({
        xScale,
        yScale,
        color: color2,
        colorGetter,
        markerSize: markerSize ?? 4,
        series: series[seriesId],
        onItemClick
      }, slotProps == null ? void 0 : slotProps.scatter), id);
    })
  });
}
true ? ScatterPlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Callback fired when clicking on a scatter item.
   * @param {MouseEvent} event Mouse event recorded on the `<svg/>` element.
   * @param {ScatterItemIdentifier} scatterItemIdentifier The scatter item identifier.
   */
  onItemClick: import_prop_types45.default.func,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types45.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types45.default.object
} : void 0;

// node_modules/@mui/x-charts/ScatterChart/ScatterChart.js
var import_jsx_runtime60 = __toESM(require_jsx_runtime());
var ScatterChart = React68.forwardRef(function ScatterChart2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiScatterChart"
  });
  const {
    chartContainerProps,
    zAxisProps,
    voronoiHandlerProps,
    chartsAxisProps,
    gridProps,
    scatterPlotProps,
    overlayProps,
    legendProps,
    axisHighlightProps,
    tooltipProps,
    children
  } = useScatterChartProps(props);
  return (0, import_jsx_runtime60.jsx)(ResponsiveChartContainer, _extends({
    ref
  }, chartContainerProps, {
    children: (0, import_jsx_runtime60.jsxs)(ZAxisContextProvider, _extends({}, zAxisProps, {
      children: [!props.disableVoronoi && (0, import_jsx_runtime60.jsx)(ChartsVoronoiHandler, _extends({}, voronoiHandlerProps)), (0, import_jsx_runtime60.jsx)(ChartsAxis, _extends({}, chartsAxisProps)), (0, import_jsx_runtime60.jsx)(ChartsGrid, _extends({}, gridProps)), (0, import_jsx_runtime60.jsx)("g", {
        "data-drawing-container": true,
        children: (0, import_jsx_runtime60.jsx)(ScatterPlot, _extends({}, scatterPlotProps))
      }), (0, import_jsx_runtime60.jsx)(ChartsOverlay, _extends({}, overlayProps)), (0, import_jsx_runtime60.jsx)(ChartsLegend, _extends({}, legendProps)), (0, import_jsx_runtime60.jsx)(ChartsAxisHighlight, _extends({}, axisHighlightProps)), !props.loading && (0, import_jsx_runtime60.jsx)(ChartsTooltip, _extends({}, tooltipProps)), children]
    }))
  }));
});
true ? ScatterChart.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The configuration of axes highlight.
   * @see See {@link https://mui.com/x/react-charts/highlighting highlighting docs} for more details.
   * @default { x: 'none', y: 'none' }
   */
  axisHighlight: import_prop_types46.default.shape({
    x: import_prop_types46.default.oneOf(["band", "line", "none"]),
    y: import_prop_types46.default.oneOf(["band", "line", "none"])
  }),
  /**
   * Indicate which axis to display the bottom of the charts.
   * Can be a string (the id of the axis) or an object `ChartsXAxisProps`.
   * @default xAxisIds[0] The id of the first provided axis
   */
  bottomAxis: import_prop_types46.default.oneOfType([import_prop_types46.default.object, import_prop_types46.default.string]),
  children: import_prop_types46.default.node,
  className: import_prop_types46.default.string,
  /**
   * Color palette used to colorize multiple series.
   * @default blueberryTwilightPalette
   */
  colors: import_prop_types46.default.oneOfType([import_prop_types46.default.arrayOf(import_prop_types46.default.string), import_prop_types46.default.func]),
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types46.default.arrayOf(import_prop_types46.default.object),
  desc: import_prop_types46.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types46.default.bool,
  /**
   * If true, the interaction will not use the Voronoi cell and fall back to hover events.
   * @default false
   */
  disableVoronoi: import_prop_types46.default.bool,
  /**
   * Option to display a cartesian grid in the background.
   */
  grid: import_prop_types46.default.shape({
    horizontal: import_prop_types46.default.bool,
    vertical: import_prop_types46.default.bool
  }),
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types46.default.number,
  /**
   * The item currently highlighted. Turns highlighting into a controlled prop.
   */
  highlightedItem: import_prop_types46.default.shape({
    dataIndex: import_prop_types46.default.number,
    seriesId: import_prop_types46.default.oneOfType([import_prop_types46.default.number, import_prop_types46.default.string])
  }),
  /**
   * Indicate which axis to display the left of the charts.
   * Can be a string (the id of the axis) or an object `ChartsYAxisProps`.
   * @default yAxisIds[0] The id of the first provided axis
   */
  leftAxis: import_prop_types46.default.oneOfType([import_prop_types46.default.object, import_prop_types46.default.string]),
  /**
   * @deprecated Consider using `slotProps.legend` instead.
   */
  legend: import_prop_types46.default.shape({
    classes: import_prop_types46.default.object,
    direction: import_prop_types46.default.oneOf(["column", "row"]),
    hidden: import_prop_types46.default.bool,
    itemGap: import_prop_types46.default.number,
    itemMarkHeight: import_prop_types46.default.number,
    itemMarkWidth: import_prop_types46.default.number,
    labelStyle: import_prop_types46.default.object,
    markGap: import_prop_types46.default.number,
    onItemClick: import_prop_types46.default.func,
    padding: import_prop_types46.default.oneOfType([import_prop_types46.default.number, import_prop_types46.default.shape({
      bottom: import_prop_types46.default.number,
      left: import_prop_types46.default.number,
      right: import_prop_types46.default.number,
      top: import_prop_types46.default.number
    })]),
    position: import_prop_types46.default.shape({
      horizontal: import_prop_types46.default.oneOf(["left", "middle", "right"]).isRequired,
      vertical: import_prop_types46.default.oneOf(["bottom", "middle", "top"]).isRequired
    }),
    slotProps: import_prop_types46.default.object,
    slots: import_prop_types46.default.object
  }),
  /**
   * If `true`, a loading overlay is displayed.
   * @default false
   */
  loading: import_prop_types46.default.bool,
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   * Accepts an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   * @default object Depends on the charts type.
   */
  margin: import_prop_types46.default.shape({
    bottom: import_prop_types46.default.number,
    left: import_prop_types46.default.number,
    right: import_prop_types46.default.number,
    top: import_prop_types46.default.number
  }),
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types46.default.func,
  /**
   * Callback fired when clicking on a scatter item.
   * @param {MouseEvent} event The mouse event recorded on the `<svg/>` element if using Voronoi cells. Or the Mouse event from the scatter element, when `disableVoronoi=true`.
   * @param {ScatterItemIdentifier} scatterItemIdentifier The scatter item identifier.
   */
  onItemClick: import_prop_types46.default.func,
  /**
   * The chart will try to wait for the parent container to resolve its size
   * before it renders for the first time.
   *
   * This can be useful in some scenarios where the chart appear to grow after
   * the first render, like when used inside a grid.
   *
   * @default false
   */
  resolveSizeBeforeRender: import_prop_types46.default.bool,
  /**
   * Indicate which axis to display the right of the charts.
   * Can be a string (the id of the axis) or an object `ChartsYAxisProps`.
   * @default null
   */
  rightAxis: import_prop_types46.default.oneOfType([import_prop_types46.default.object, import_prop_types46.default.string]),
  /**
   * The series to display in the scatter chart.
   * An array of [[ScatterSeriesType]] objects.
   */
  series: import_prop_types46.default.arrayOf(import_prop_types46.default.object).isRequired,
  /**
   * If `true`, animations are skipped.
   * If unset or `false`, the animations respects the user's `prefers-reduced-motion` setting.
   */
  skipAnimation: import_prop_types46.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types46.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types46.default.object,
  sx: import_prop_types46.default.oneOfType([import_prop_types46.default.arrayOf(import_prop_types46.default.oneOfType([import_prop_types46.default.func, import_prop_types46.default.object, import_prop_types46.default.bool])), import_prop_types46.default.func, import_prop_types46.default.object]),
  title: import_prop_types46.default.string,
  /**
   * The configuration of the tooltip.
   * @see See {@link https://mui.com/x/react-charts/tooltip/ tooltip docs} for more details.
   * @default { trigger: 'item' }
   */
  tooltip: import_prop_types46.default.shape({
    axisContent: import_prop_types46.default.elementType,
    classes: import_prop_types46.default.object,
    itemContent: import_prop_types46.default.elementType,
    slotProps: import_prop_types46.default.object,
    slots: import_prop_types46.default.object,
    trigger: import_prop_types46.default.oneOf(["axis", "item", "none"])
  }),
  /**
   * Indicate which axis to display the top of the charts.
   * Can be a string (the id of the axis) or an object `ChartsXAxisProps`.
   * @default null
   */
  topAxis: import_prop_types46.default.oneOfType([import_prop_types46.default.object, import_prop_types46.default.string]),
  viewBox: import_prop_types46.default.shape({
    height: import_prop_types46.default.number,
    width: import_prop_types46.default.number,
    x: import_prop_types46.default.number,
    y: import_prop_types46.default.number
  }),
  /**
   * Defines the maximal distance between a scatter point and the pointer that triggers the interaction.
   * If `undefined`, the radius is assumed to be infinite.
   */
  voronoiMaxRadius: import_prop_types46.default.number,
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types46.default.number,
  /**
   * The configuration of the x-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  xAxis: import_prop_types46.default.arrayOf(import_prop_types46.default.shape({
    classes: import_prop_types46.default.object,
    colorMap: import_prop_types46.default.oneOfType([import_prop_types46.default.shape({
      colors: import_prop_types46.default.arrayOf(import_prop_types46.default.string).isRequired,
      type: import_prop_types46.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types46.default.string,
      values: import_prop_types46.default.arrayOf(import_prop_types46.default.oneOfType([import_prop_types46.default.instanceOf(Date), import_prop_types46.default.number, import_prop_types46.default.string]).isRequired)
    }), import_prop_types46.default.shape({
      color: import_prop_types46.default.oneOfType([import_prop_types46.default.arrayOf(import_prop_types46.default.string.isRequired), import_prop_types46.default.func]).isRequired,
      max: import_prop_types46.default.oneOfType([import_prop_types46.default.instanceOf(Date), import_prop_types46.default.number]),
      min: import_prop_types46.default.oneOfType([import_prop_types46.default.instanceOf(Date), import_prop_types46.default.number]),
      type: import_prop_types46.default.oneOf(["continuous"]).isRequired
    }), import_prop_types46.default.shape({
      colors: import_prop_types46.default.arrayOf(import_prop_types46.default.string).isRequired,
      thresholds: import_prop_types46.default.arrayOf(import_prop_types46.default.oneOfType([import_prop_types46.default.instanceOf(Date), import_prop_types46.default.number]).isRequired).isRequired,
      type: import_prop_types46.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types46.default.array,
    dataKey: import_prop_types46.default.string,
    disableLine: import_prop_types46.default.bool,
    disableTicks: import_prop_types46.default.bool,
    fill: import_prop_types46.default.string,
    hideTooltip: import_prop_types46.default.bool,
    id: import_prop_types46.default.oneOfType([import_prop_types46.default.number, import_prop_types46.default.string]),
    label: import_prop_types46.default.string,
    labelFontSize: import_prop_types46.default.number,
    labelStyle: import_prop_types46.default.object,
    max: import_prop_types46.default.oneOfType([import_prop_types46.default.instanceOf(Date), import_prop_types46.default.number]),
    min: import_prop_types46.default.oneOfType([import_prop_types46.default.instanceOf(Date), import_prop_types46.default.number]),
    position: import_prop_types46.default.oneOf(["bottom", "top"]),
    reverse: import_prop_types46.default.bool,
    scaleType: import_prop_types46.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types46.default.object,
    slots: import_prop_types46.default.object,
    stroke: import_prop_types46.default.string,
    sx: import_prop_types46.default.oneOfType([import_prop_types46.default.arrayOf(import_prop_types46.default.oneOfType([import_prop_types46.default.func, import_prop_types46.default.object, import_prop_types46.default.bool])), import_prop_types46.default.func, import_prop_types46.default.object]),
    tickFontSize: import_prop_types46.default.number,
    tickInterval: import_prop_types46.default.oneOfType([import_prop_types46.default.oneOf(["auto"]), import_prop_types46.default.array, import_prop_types46.default.func]),
    tickLabelInterval: import_prop_types46.default.oneOfType([import_prop_types46.default.oneOf(["auto"]), import_prop_types46.default.func]),
    tickLabelPlacement: import_prop_types46.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types46.default.object,
    tickMaxStep: import_prop_types46.default.number,
    tickMinStep: import_prop_types46.default.number,
    tickNumber: import_prop_types46.default.number,
    tickPlacement: import_prop_types46.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types46.default.number,
    valueFormatter: import_prop_types46.default.func
  })),
  /**
   * The configuration of the y-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  yAxis: import_prop_types46.default.arrayOf(import_prop_types46.default.shape({
    classes: import_prop_types46.default.object,
    colorMap: import_prop_types46.default.oneOfType([import_prop_types46.default.shape({
      colors: import_prop_types46.default.arrayOf(import_prop_types46.default.string).isRequired,
      type: import_prop_types46.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types46.default.string,
      values: import_prop_types46.default.arrayOf(import_prop_types46.default.oneOfType([import_prop_types46.default.instanceOf(Date), import_prop_types46.default.number, import_prop_types46.default.string]).isRequired)
    }), import_prop_types46.default.shape({
      color: import_prop_types46.default.oneOfType([import_prop_types46.default.arrayOf(import_prop_types46.default.string.isRequired), import_prop_types46.default.func]).isRequired,
      max: import_prop_types46.default.oneOfType([import_prop_types46.default.instanceOf(Date), import_prop_types46.default.number]),
      min: import_prop_types46.default.oneOfType([import_prop_types46.default.instanceOf(Date), import_prop_types46.default.number]),
      type: import_prop_types46.default.oneOf(["continuous"]).isRequired
    }), import_prop_types46.default.shape({
      colors: import_prop_types46.default.arrayOf(import_prop_types46.default.string).isRequired,
      thresholds: import_prop_types46.default.arrayOf(import_prop_types46.default.oneOfType([import_prop_types46.default.instanceOf(Date), import_prop_types46.default.number]).isRequired).isRequired,
      type: import_prop_types46.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types46.default.array,
    dataKey: import_prop_types46.default.string,
    disableLine: import_prop_types46.default.bool,
    disableTicks: import_prop_types46.default.bool,
    fill: import_prop_types46.default.string,
    hideTooltip: import_prop_types46.default.bool,
    id: import_prop_types46.default.oneOfType([import_prop_types46.default.number, import_prop_types46.default.string]),
    label: import_prop_types46.default.string,
    labelFontSize: import_prop_types46.default.number,
    labelStyle: import_prop_types46.default.object,
    max: import_prop_types46.default.oneOfType([import_prop_types46.default.instanceOf(Date), import_prop_types46.default.number]),
    min: import_prop_types46.default.oneOfType([import_prop_types46.default.instanceOf(Date), import_prop_types46.default.number]),
    position: import_prop_types46.default.oneOf(["left", "right"]),
    reverse: import_prop_types46.default.bool,
    scaleType: import_prop_types46.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types46.default.object,
    slots: import_prop_types46.default.object,
    stroke: import_prop_types46.default.string,
    sx: import_prop_types46.default.oneOfType([import_prop_types46.default.arrayOf(import_prop_types46.default.oneOfType([import_prop_types46.default.func, import_prop_types46.default.object, import_prop_types46.default.bool])), import_prop_types46.default.func, import_prop_types46.default.object]),
    tickFontSize: import_prop_types46.default.number,
    tickInterval: import_prop_types46.default.oneOfType([import_prop_types46.default.oneOf(["auto"]), import_prop_types46.default.array, import_prop_types46.default.func]),
    tickLabelInterval: import_prop_types46.default.oneOfType([import_prop_types46.default.oneOf(["auto"]), import_prop_types46.default.func]),
    tickLabelPlacement: import_prop_types46.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types46.default.object,
    tickMaxStep: import_prop_types46.default.number,
    tickMinStep: import_prop_types46.default.number,
    tickNumber: import_prop_types46.default.number,
    tickPlacement: import_prop_types46.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types46.default.number,
    valueFormatter: import_prop_types46.default.func
  })),
  /**
   * The configuration of the z-axes.
   */
  zAxis: import_prop_types46.default.arrayOf(import_prop_types46.default.shape({
    colorMap: import_prop_types46.default.oneOfType([import_prop_types46.default.shape({
      colors: import_prop_types46.default.arrayOf(import_prop_types46.default.string).isRequired,
      type: import_prop_types46.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types46.default.string,
      values: import_prop_types46.default.arrayOf(import_prop_types46.default.oneOfType([import_prop_types46.default.instanceOf(Date), import_prop_types46.default.number, import_prop_types46.default.string]).isRequired)
    }), import_prop_types46.default.shape({
      color: import_prop_types46.default.oneOfType([import_prop_types46.default.arrayOf(import_prop_types46.default.string.isRequired), import_prop_types46.default.func]).isRequired,
      max: import_prop_types46.default.oneOfType([import_prop_types46.default.instanceOf(Date), import_prop_types46.default.number]),
      min: import_prop_types46.default.oneOfType([import_prop_types46.default.instanceOf(Date), import_prop_types46.default.number]),
      type: import_prop_types46.default.oneOf(["continuous"]).isRequired
    }), import_prop_types46.default.shape({
      colors: import_prop_types46.default.arrayOf(import_prop_types46.default.string).isRequired,
      thresholds: import_prop_types46.default.arrayOf(import_prop_types46.default.oneOfType([import_prop_types46.default.instanceOf(Date), import_prop_types46.default.number]).isRequired).isRequired,
      type: import_prop_types46.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types46.default.array,
    dataKey: import_prop_types46.default.string,
    id: import_prop_types46.default.string,
    max: import_prop_types46.default.number,
    min: import_prop_types46.default.number
  }))
} : void 0;

// node_modules/@mui/x-charts/SparkLineChart/SparkLineChart.js
init_extends();
var React69 = __toESM(require_react());
var import_prop_types47 = __toESM(require_prop_types());
var import_jsx_runtime61 = __toESM(require_jsx_runtime());
var _excluded37 = ["xAxis", "yAxis", "width", "height", "margin", "colors", "sx", "showTooltip", "tooltip", "showHighlight", "axisHighlight", "children", "slots", "slotProps", "data", "plotType", "valueFormatter", "area", "curve", "className"];
var SPARKLINE_DEFAULT_MARGIN = {
  top: 5,
  bottom: 5,
  left: 5,
  right: 5
};
var SparkLineChart = React69.forwardRef(function SparkLineChart2(props, ref) {
  const {
    xAxis,
    yAxis,
    width,
    height,
    margin = SPARKLINE_DEFAULT_MARGIN,
    colors,
    sx,
    showTooltip,
    tooltip,
    showHighlight,
    axisHighlight: inAxisHighlight,
    children,
    slots,
    slotProps,
    data,
    plotType = "line",
    valueFormatter = (value) => value === null ? "" : value.toString(),
    area,
    curve = "linear",
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded37);
  const defaultXHighlight = showHighlight && plotType === "bar" ? {
    x: "band"
  } : {
    x: "none"
  };
  const axisHighlight = _extends({}, defaultXHighlight, inAxisHighlight);
  return (0, import_jsx_runtime61.jsxs)(ResponsiveChartContainer, _extends({}, other, {
    ref,
    series: [_extends({
      type: plotType,
      data,
      valueFormatter
    }, plotType === "bar" ? {} : {
      area,
      curve,
      disableHighlight: !showHighlight
    })],
    width,
    height,
    margin,
    className,
    xAxis: [_extends({
      id: DEFAULT_X_AXIS_KEY,
      scaleType: plotType === "bar" ? "band" : "point",
      data: Array.from({
        length: data.length
      }, (_, index) => index),
      hideTooltip: xAxis === void 0
    }, xAxis)],
    yAxis: [_extends({
      id: DEFAULT_X_AXIS_KEY
    }, yAxis)],
    colors,
    sx,
    disableAxisListener: (!showTooltip || (tooltip == null ? void 0 : tooltip.trigger) !== "axis") && (axisHighlight == null ? void 0 : axisHighlight.x) === "none" && (axisHighlight == null ? void 0 : axisHighlight.y) === "none",
    children: [plotType === "bar" && (0, import_jsx_runtime61.jsx)(BarPlot, {
      skipAnimation: true,
      slots,
      slotProps,
      sx: {
        shapeRendering: "auto"
      }
    }), plotType === "line" && (0, import_jsx_runtime61.jsxs)(React69.Fragment, {
      children: [(0, import_jsx_runtime61.jsx)(AreaPlot, {
        skipAnimation: true,
        slots,
        slotProps
      }), (0, import_jsx_runtime61.jsx)(LinePlot, {
        skipAnimation: true,
        slots,
        slotProps
      }), (0, import_jsx_runtime61.jsx)(LineHighlightPlot, {
        slots,
        slotProps
      })]
    }), (0, import_jsx_runtime61.jsx)(ChartsAxisHighlight, _extends({}, axisHighlight)), showTooltip && (0, import_jsx_runtime61.jsx)(ChartsTooltip, _extends({}, tooltip, {
      slotProps,
      slots
    })), children]
  }));
});
true ? SparkLineChart.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Set to `true` to fill spark line area.
   * Has no effect if plotType='bar'.
   * @default false
   */
  area: import_prop_types47.default.bool,
  axisHighlight: import_prop_types47.default.shape({
    x: import_prop_types47.default.oneOf(["band", "line", "none"]),
    y: import_prop_types47.default.oneOf(["band", "line", "none"])
  }),
  children: import_prop_types47.default.node,
  className: import_prop_types47.default.string,
  /**
   * Color palette used to colorize multiple series.
   * @default blueberryTwilightPalette
   */
  colors: import_prop_types47.default.oneOfType([import_prop_types47.default.arrayOf(import_prop_types47.default.string), import_prop_types47.default.func]),
  /**
   * @default 'linear'
   */
  curve: import_prop_types47.default.oneOf(["catmullRom", "linear", "monotoneX", "monotoneY", "natural", "step", "stepAfter", "stepBefore"]),
  /**
   * Data to plot.
   */
  data: import_prop_types47.default.arrayOf(import_prop_types47.default.number).isRequired,
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types47.default.arrayOf(import_prop_types47.default.object),
  desc: import_prop_types47.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types47.default.bool,
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types47.default.number,
  /**
   * The item currently highlighted. Turns highlighting into a controlled prop.
   */
  highlightedItem: import_prop_types47.default.shape({
    dataIndex: import_prop_types47.default.number,
    seriesId: import_prop_types47.default.oneOfType([import_prop_types47.default.number, import_prop_types47.default.string])
  }),
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   * Accepts an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   * @default {
   *   top: 5,
   *   bottom: 5,
   *   left: 5,
   *   right: 5,
   * }
   */
  margin: import_prop_types47.default.shape({
    bottom: import_prop_types47.default.number,
    left: import_prop_types47.default.number,
    right: import_prop_types47.default.number,
    top: import_prop_types47.default.number
  }),
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types47.default.func,
  /**
   * Type of plot used.
   * @default 'line'
   */
  plotType: import_prop_types47.default.oneOf(["bar", "line"]),
  /**
   * The chart will try to wait for the parent container to resolve its size
   * before it renders for the first time.
   *
   * This can be useful in some scenarios where the chart appear to grow after
   * the first render, like when used inside a grid.
   *
   * @default false
   */
  resolveSizeBeforeRender: import_prop_types47.default.bool,
  /**
   * Set to `true` to highlight the value.
   * With line, it shows a point.
   * With bar, it shows a highlight band.
   * @default false
   */
  showHighlight: import_prop_types47.default.bool,
  /**
   * Set to `true` to enable the tooltip in the sparkline.
   * @default false
   */
  showTooltip: import_prop_types47.default.bool,
  /**
   * If `true`, animations are skipped.
   * If unset or `false`, the animations respects the user's `prefers-reduced-motion` setting.
   */
  skipAnimation: import_prop_types47.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types47.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types47.default.object,
  sx: import_prop_types47.default.oneOfType([import_prop_types47.default.arrayOf(import_prop_types47.default.oneOfType([import_prop_types47.default.func, import_prop_types47.default.object, import_prop_types47.default.bool])), import_prop_types47.default.func, import_prop_types47.default.object]),
  title: import_prop_types47.default.string,
  tooltip: import_prop_types47.default.shape({
    axisContent: import_prop_types47.default.elementType,
    classes: import_prop_types47.default.object,
    itemContent: import_prop_types47.default.elementType,
    slotProps: import_prop_types47.default.object,
    slots: import_prop_types47.default.object,
    trigger: import_prop_types47.default.oneOf(["axis", "item", "none"])
  }),
  /**
   * Formatter used by the tooltip.
   * @param {number} value The value to format.
   * @returns {string} the formatted value.
   * @default (value: number | null) => (value === null ? '' : value.toString())
   */
  valueFormatter: import_prop_types47.default.func,
  viewBox: import_prop_types47.default.shape({
    height: import_prop_types47.default.number,
    width: import_prop_types47.default.number,
    x: import_prop_types47.default.number,
    y: import_prop_types47.default.number
  }),
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types47.default.number,
  /**
   * The xAxis configuration.
   * Notice it is a single [[AxisConfig]] object, not an array of configuration.
   */
  xAxis: import_prop_types47.default.shape({
    classes: import_prop_types47.default.object,
    colorMap: import_prop_types47.default.oneOfType([import_prop_types47.default.shape({
      colors: import_prop_types47.default.arrayOf(import_prop_types47.default.string).isRequired,
      type: import_prop_types47.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types47.default.string,
      values: import_prop_types47.default.arrayOf(import_prop_types47.default.oneOfType([import_prop_types47.default.instanceOf(Date), import_prop_types47.default.number, import_prop_types47.default.string]).isRequired)
    }), import_prop_types47.default.shape({
      color: import_prop_types47.default.oneOfType([import_prop_types47.default.arrayOf(import_prop_types47.default.string.isRequired), import_prop_types47.default.func]).isRequired,
      max: import_prop_types47.default.oneOfType([import_prop_types47.default.instanceOf(Date), import_prop_types47.default.number]),
      min: import_prop_types47.default.oneOfType([import_prop_types47.default.instanceOf(Date), import_prop_types47.default.number]),
      type: import_prop_types47.default.oneOf(["continuous"]).isRequired
    }), import_prop_types47.default.shape({
      colors: import_prop_types47.default.arrayOf(import_prop_types47.default.string).isRequired,
      thresholds: import_prop_types47.default.arrayOf(import_prop_types47.default.oneOfType([import_prop_types47.default.instanceOf(Date), import_prop_types47.default.number]).isRequired).isRequired,
      type: import_prop_types47.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types47.default.array,
    dataKey: import_prop_types47.default.string,
    disableLine: import_prop_types47.default.bool,
    disableTicks: import_prop_types47.default.bool,
    fill: import_prop_types47.default.string,
    hideTooltip: import_prop_types47.default.bool,
    id: import_prop_types47.default.oneOfType([import_prop_types47.default.number, import_prop_types47.default.string]),
    label: import_prop_types47.default.string,
    labelFontSize: import_prop_types47.default.number,
    labelStyle: import_prop_types47.default.object,
    max: import_prop_types47.default.oneOfType([import_prop_types47.default.instanceOf(Date), import_prop_types47.default.number]),
    min: import_prop_types47.default.oneOfType([import_prop_types47.default.instanceOf(Date), import_prop_types47.default.number]),
    position: import_prop_types47.default.oneOf(["bottom", "top"]),
    reverse: import_prop_types47.default.bool,
    scaleType: import_prop_types47.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types47.default.object,
    slots: import_prop_types47.default.object,
    stroke: import_prop_types47.default.string,
    sx: import_prop_types47.default.oneOfType([import_prop_types47.default.arrayOf(import_prop_types47.default.oneOfType([import_prop_types47.default.func, import_prop_types47.default.object, import_prop_types47.default.bool])), import_prop_types47.default.func, import_prop_types47.default.object]),
    tickFontSize: import_prop_types47.default.number,
    tickInterval: import_prop_types47.default.oneOfType([import_prop_types47.default.oneOf(["auto"]), import_prop_types47.default.array, import_prop_types47.default.func]),
    tickLabelInterval: import_prop_types47.default.oneOfType([import_prop_types47.default.oneOf(["auto"]), import_prop_types47.default.func]),
    tickLabelPlacement: import_prop_types47.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types47.default.object,
    tickMaxStep: import_prop_types47.default.number,
    tickMinStep: import_prop_types47.default.number,
    tickNumber: import_prop_types47.default.number,
    tickPlacement: import_prop_types47.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types47.default.number,
    valueFormatter: import_prop_types47.default.func
  }),
  /**
   * The yAxis configuration.
   * Notice it is a single [[AxisConfig]] object, not an array of configuration.
   */
  yAxis: import_prop_types47.default.shape({
    classes: import_prop_types47.default.object,
    colorMap: import_prop_types47.default.oneOfType([import_prop_types47.default.shape({
      colors: import_prop_types47.default.arrayOf(import_prop_types47.default.string).isRequired,
      type: import_prop_types47.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types47.default.string,
      values: import_prop_types47.default.arrayOf(import_prop_types47.default.oneOfType([import_prop_types47.default.instanceOf(Date), import_prop_types47.default.number, import_prop_types47.default.string]).isRequired)
    }), import_prop_types47.default.shape({
      color: import_prop_types47.default.oneOfType([import_prop_types47.default.arrayOf(import_prop_types47.default.string.isRequired), import_prop_types47.default.func]).isRequired,
      max: import_prop_types47.default.oneOfType([import_prop_types47.default.instanceOf(Date), import_prop_types47.default.number]),
      min: import_prop_types47.default.oneOfType([import_prop_types47.default.instanceOf(Date), import_prop_types47.default.number]),
      type: import_prop_types47.default.oneOf(["continuous"]).isRequired
    }), import_prop_types47.default.shape({
      colors: import_prop_types47.default.arrayOf(import_prop_types47.default.string).isRequired,
      thresholds: import_prop_types47.default.arrayOf(import_prop_types47.default.oneOfType([import_prop_types47.default.instanceOf(Date), import_prop_types47.default.number]).isRequired).isRequired,
      type: import_prop_types47.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types47.default.array,
    dataKey: import_prop_types47.default.string,
    disableLine: import_prop_types47.default.bool,
    disableTicks: import_prop_types47.default.bool,
    fill: import_prop_types47.default.string,
    hideTooltip: import_prop_types47.default.bool,
    id: import_prop_types47.default.oneOfType([import_prop_types47.default.number, import_prop_types47.default.string]),
    label: import_prop_types47.default.string,
    labelFontSize: import_prop_types47.default.number,
    labelStyle: import_prop_types47.default.object,
    max: import_prop_types47.default.oneOfType([import_prop_types47.default.instanceOf(Date), import_prop_types47.default.number]),
    min: import_prop_types47.default.oneOfType([import_prop_types47.default.instanceOf(Date), import_prop_types47.default.number]),
    position: import_prop_types47.default.oneOf(["left", "right"]),
    reverse: import_prop_types47.default.bool,
    scaleType: import_prop_types47.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types47.default.object,
    slots: import_prop_types47.default.object,
    stroke: import_prop_types47.default.string,
    sx: import_prop_types47.default.oneOfType([import_prop_types47.default.arrayOf(import_prop_types47.default.oneOfType([import_prop_types47.default.func, import_prop_types47.default.object, import_prop_types47.default.bool])), import_prop_types47.default.func, import_prop_types47.default.object]),
    tickFontSize: import_prop_types47.default.number,
    tickInterval: import_prop_types47.default.oneOfType([import_prop_types47.default.oneOf(["auto"]), import_prop_types47.default.array, import_prop_types47.default.func]),
    tickLabelInterval: import_prop_types47.default.oneOfType([import_prop_types47.default.oneOf(["auto"]), import_prop_types47.default.func]),
    tickLabelPlacement: import_prop_types47.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types47.default.object,
    tickMaxStep: import_prop_types47.default.number,
    tickMinStep: import_prop_types47.default.number,
    tickNumber: import_prop_types47.default.number,
    tickPlacement: import_prop_types47.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types47.default.number,
    valueFormatter: import_prop_types47.default.func
  })
} : void 0;

// node_modules/@mui/x-charts/Gauge/Gauge.js
init_extends();
var React75 = __toESM(require_react());
var import_prop_types50 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/Gauge/GaugeContainer.js
init_extends();
var React71 = __toESM(require_react());
var import_prop_types48 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/Gauge/GaugeProvider.js
var React70 = __toESM(require_react());

// node_modules/@mui/x-charts/Gauge/utils.js
function deg2rad(angle) {
  return Math.PI * angle / 180;
}
function getPoint(angle) {
  const radAngle = deg2rad(angle);
  return [Math.sin(radAngle), -Math.cos(radAngle)];
}
function getArcRatios(startAngle, endAngle) {
  const points = [[0, 0], getPoint(startAngle), getPoint(endAngle)];
  const minAngle = Math.min(startAngle, endAngle);
  const maxAngle = Math.max(startAngle, endAngle);
  const initialAngle = Math.floor(minAngle / 90) * 90;
  for (let step = 1; step <= 4; step += 1) {
    const cardinalAngle = initialAngle + step * 90;
    if (cardinalAngle < maxAngle) {
      points.push(getPoint(cardinalAngle));
    }
  }
  const minX = Math.min(...points.map(([x]) => x));
  const maxX = Math.max(...points.map(([x]) => x));
  const minY = Math.min(...points.map(([, y]) => y));
  const maxY = Math.max(...points.map(([, y]) => y));
  return {
    cx: -minX / (maxX - minX),
    cy: -minY / (maxY - minY),
    minX,
    maxX,
    minY,
    maxY
  };
}
function getAvailableRadius(cx, cy, width, height, {
  minX,
  maxX,
  minY,
  maxY
}) {
  return Math.min(...[{
    ratio: Math.abs(minX),
    space: cx
  }, {
    ratio: Math.abs(maxX),
    space: width - cx
  }, {
    ratio: Math.abs(minY),
    space: cy
  }, {
    ratio: Math.abs(maxY),
    space: height - cy
  }].map(({
    ratio,
    space
  }) => {
    if (ratio < 1e-5) {
      return Infinity;
    }
    return space / ratio;
  }));
}

// node_modules/@mui/x-charts/Gauge/GaugeProvider.js
var import_jsx_runtime62 = __toESM(require_jsx_runtime());
var GaugeContext = React70.createContext({
  value: null,
  valueMin: 0,
  valueMax: 0,
  startAngle: 0,
  endAngle: 0,
  innerRadius: 0,
  outerRadius: 0,
  cornerRadius: 0,
  cx: 0,
  cy: 0,
  maxRadius: 0,
  valueAngle: null
});
if (true) {
  GaugeContext.displayName = "GaugeContext";
}
function GaugeProvider(props) {
  const {
    value = null,
    valueMin = 0,
    valueMax = 100,
    startAngle = 0,
    endAngle = 360,
    outerRadius: outerRadiusParam,
    innerRadius: innerRadiusParam,
    cornerRadius: cornerRadiusParam,
    cx: cxParam,
    cy: cyParam,
    children
  } = props;
  const {
    left,
    top,
    width,
    height
  } = useDrawingArea();
  const ratios = getArcRatios(startAngle, endAngle);
  const innerCx = cxParam ? getPercentageValue(cxParam, width) : ratios.cx * width;
  const innerCy = cyParam ? getPercentageValue(cyParam, height) : ratios.cy * height;
  let cx = left + innerCx;
  let cy = top + innerCy;
  const maxRadius = getAvailableRadius(innerCx, innerCy, width, height, ratios);
  if (cxParam === void 0) {
    const usedWidth = maxRadius * (ratios.maxX - ratios.minX);
    cx = left + (width - usedWidth) / 2 + ratios.cx * usedWidth;
  }
  if (cyParam === void 0) {
    const usedHeight = maxRadius * (ratios.maxY - ratios.minY);
    cy = top + (height - usedHeight) / 2 + ratios.cy * usedHeight;
  }
  const outerRadius = getPercentageValue(outerRadiusParam ?? maxRadius, maxRadius);
  const innerRadius = getPercentageValue(innerRadiusParam ?? "80%", maxRadius);
  const cornerRadius = getPercentageValue(cornerRadiusParam ?? 0, outerRadius - innerRadius);
  const contextValue = React70.useMemo(() => {
    const startAngleRad = Math.PI * startAngle / 180;
    const endAngleRad = Math.PI * endAngle / 180;
    return {
      value,
      valueMin,
      valueMax,
      startAngle: startAngleRad,
      endAngle: endAngleRad,
      outerRadius,
      innerRadius,
      cornerRadius,
      cx,
      cy,
      maxRadius,
      valueAngle: value === null ? null : startAngleRad + (endAngleRad - startAngleRad) * (value - valueMin) / (valueMax - valueMin)
    };
  }, [value, valueMin, valueMax, startAngle, endAngle, outerRadius, innerRadius, cornerRadius, cx, cy, maxRadius]);
  return (0, import_jsx_runtime62.jsx)(GaugeContext.Provider, {
    value: contextValue,
    children
  });
}
function useGaugeState() {
  return React70.useContext(GaugeContext);
}

// node_modules/@mui/x-charts/Gauge/GaugeContainer.js
var import_jsx_runtime63 = __toESM(require_jsx_runtime());
var _excluded38 = ["width", "height", "margin", "title", "desc", "value", "valueMin", "valueMax", "startAngle", "endAngle", "outerRadius", "innerRadius", "cornerRadius", "cx", "cy", "children"];
var ResizableContainer2 = styled_default("div", {
  name: "MuiGauge",
  slot: "Container"
})(({
  ownerState,
  theme
}) => ({
  width: ownerState.width ?? "100%",
  height: ownerState.height ?? "100%",
  display: "flex",
  position: "relative",
  flexGrow: 1,
  flexDirection: "column",
  alignItems: "center",
  justifyContent: "center",
  overflow: "hidden",
  "&>svg": {
    width: "100%",
    height: "100%"
  },
  "& text": {
    fill: (theme.vars || theme).palette.text.primary
  }
}));
var GaugeContainer = React71.forwardRef(function GaugeContainer2(props, ref) {
  const {
    width: inWidth,
    height: inHeight,
    margin,
    title,
    desc,
    value,
    valueMin = 0,
    valueMax = 100,
    startAngle,
    endAngle,
    outerRadius,
    innerRadius,
    cornerRadius,
    cx,
    cy,
    children
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded38);
  const {
    containerRef,
    width,
    height
  } = useChartContainerDimensions(inWidth, inHeight);
  const svgRef = React71.useRef(null);
  const chartSurfaceRef = useForkRef(ref, svgRef);
  return (0, import_jsx_runtime63.jsx)(ResizableContainer2, _extends({
    ref: containerRef,
    ownerState: {
      width: inWidth,
      height: inHeight
    },
    role: "meter",
    "aria-valuenow": value === null ? void 0 : value,
    "aria-valuemin": valueMin,
    "aria-valuemax": valueMax
  }, other, {
    children: width && height ? (0, import_jsx_runtime63.jsx)(DrawingProvider, {
      width,
      height,
      margin: _extends({
        left: 10,
        right: 10,
        top: 10,
        bottom: 10
      }, margin),
      svgRef,
      children: (0, import_jsx_runtime63.jsx)(GaugeProvider, {
        value,
        valueMin,
        valueMax,
        startAngle,
        endAngle,
        outerRadius,
        innerRadius,
        cornerRadius,
        cx,
        cy,
        children: (0, import_jsx_runtime63.jsx)(ChartsSurface, {
          width,
          height,
          ref: chartSurfaceRef,
          title,
          desc,
          disableAxisListener: true,
          "aria-hidden": "true",
          children
        })
      })
    }) : null
  }));
});
true ? GaugeContainer.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: import_prop_types48.default.node,
  className: import_prop_types48.default.string,
  /**
   * The radius applied to arc corners (similar to border radius).
   * Set it to '50%' to get rounded arc.
   * @default 0
   */
  cornerRadius: import_prop_types48.default.oneOfType([import_prop_types48.default.number, import_prop_types48.default.string]),
  /**
   * The x coordinate of the arc center.
   * Can be a number (in px) or a string with a percentage such as '50%'.
   * The '100%' is the width the drawing area.
   */
  cx: import_prop_types48.default.oneOfType([import_prop_types48.default.number, import_prop_types48.default.string]),
  /**
   * The y coordinate of the arc center.
   * Can be a number (in px) or a string with a percentage such as '50%'.
   * The '100%' is the height the drawing area.
   */
  cy: import_prop_types48.default.oneOfType([import_prop_types48.default.number, import_prop_types48.default.string]),
  desc: import_prop_types48.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types48.default.bool,
  /**
   * The end angle (deg).
   * @default 360
   */
  endAngle: import_prop_types48.default.number,
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types48.default.number,
  /**
   * The radius between circle center and the beginning of the arc.
   * Can be a number (in px) or a string with a percentage such as '50%'.
   * The '100%' is the maximal radius that fit into the drawing area.
   * @default '80%'
   */
  innerRadius: import_prop_types48.default.oneOfType([import_prop_types48.default.number, import_prop_types48.default.string]),
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   * Accepts an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   * @default object Depends on the charts type.
   */
  margin: import_prop_types48.default.shape({
    bottom: import_prop_types48.default.number,
    left: import_prop_types48.default.number,
    right: import_prop_types48.default.number,
    top: import_prop_types48.default.number
  }),
  /**
   * The radius between circle center and the end of the arc.
   * Can be a number (in px) or a string with a percentage such as '50%'.
   * The '100%' is the maximal radius that fit into the drawing area.
   * @default '100%'
   */
  outerRadius: import_prop_types48.default.oneOfType([import_prop_types48.default.number, import_prop_types48.default.string]),
  /**
   * The start angle (deg).
   * @default 0
   */
  startAngle: import_prop_types48.default.number,
  sx: import_prop_types48.default.oneOfType([import_prop_types48.default.arrayOf(import_prop_types48.default.oneOfType([import_prop_types48.default.func, import_prop_types48.default.object, import_prop_types48.default.bool])), import_prop_types48.default.func, import_prop_types48.default.object]),
  title: import_prop_types48.default.string,
  /**
   * The value of the gauge.
   * Set to `null` to not display a value.
   */
  value: import_prop_types48.default.number,
  /**
   * The maximal value of the gauge.
   * @default 100
   */
  valueMax: import_prop_types48.default.number,
  /**
   * The minimal value of the gauge.
   * @default 0
   */
  valueMin: import_prop_types48.default.number,
  viewBox: import_prop_types48.default.shape({
    height: import_prop_types48.default.number,
    width: import_prop_types48.default.number,
    x: import_prop_types48.default.number,
    y: import_prop_types48.default.number
  }),
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types48.default.number
} : void 0;

// node_modules/@mui/x-charts/Gauge/GaugeValueArc.js
init_extends();
var React72 = __toESM(require_react());
var import_jsx_runtime64 = __toESM(require_jsx_runtime());
var StyledPath = styled_default("path", {
  name: "MuiGauge",
  slot: "ReferenceArc",
  overridesResolver: (props, styles) => styles.referenceArc
})(({
  theme
}) => ({
  fill: (theme.vars || theme).palette.primary.main
}));
function GaugeValueArc(props) {
  const {
    value,
    valueMin,
    valueMax,
    startAngle,
    endAngle,
    outerRadius,
    innerRadius,
    cornerRadius,
    cx,
    cy
  } = useGaugeState();
  if (value === null) {
    return null;
  }
  const valueAngle = startAngle + (value - valueMin) / (valueMax - valueMin) * (endAngle - startAngle);
  return (0, import_jsx_runtime64.jsx)(StyledPath, _extends({
    transform: `translate(${cx}, ${cy})`,
    d: arc_default().cornerRadius(cornerRadius)({
      startAngle,
      endAngle: valueAngle,
      innerRadius,
      outerRadius
    })
  }, props));
}

// node_modules/@mui/x-charts/Gauge/GaugeReferenceArc.js
init_extends();
var React73 = __toESM(require_react());
var import_jsx_runtime65 = __toESM(require_jsx_runtime());
var StyledPath2 = styled_default("path", {
  name: "MuiGauge",
  slot: "ReferenceArc",
  overridesResolver: (props, styles) => styles.referenceArc
})(({
  theme
}) => ({
  fill: (theme.vars || theme).palette.divider
}));
function GaugeReferenceArc(props) {
  const {
    startAngle,
    endAngle,
    outerRadius,
    innerRadius,
    cornerRadius,
    cx,
    cy
  } = useGaugeState();
  return (0, import_jsx_runtime65.jsx)(StyledPath2, _extends({
    transform: `translate(${cx}, ${cy})`,
    d: arc_default().cornerRadius(cornerRadius)({
      startAngle,
      endAngle,
      innerRadius,
      outerRadius
    })
  }, props));
}

// node_modules/@mui/x-charts/Gauge/gaugeClasses.js
function getGaugeUtilityClass(slot) {
  return generateUtilityClass("MuiGauge", slot);
}
var gaugeClasses = generateUtilityClasses("MuiGauge", ["root", "valueArc", "referenceArc", "valueText"]);

// node_modules/@mui/x-charts/Gauge/GaugeValueText.js
init_extends();
var React74 = __toESM(require_react());
var import_prop_types49 = __toESM(require_prop_types());
var import_jsx_runtime66 = __toESM(require_jsx_runtime());
var _excluded39 = ["text", "className"];
function defaultFormatter({
  value
}) {
  return value === null ? null : value.toLocaleString();
}
function GaugeValueText(props) {
  const {
    text = defaultFormatter,
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded39);
  const {
    value,
    valueMin,
    valueMax,
    cx,
    cy
  } = useGaugeState();
  const formattedText = typeof text === "function" ? text({
    value,
    valueMin,
    valueMax
  }) : text;
  if (formattedText === null) {
    return null;
  }
  return (0, import_jsx_runtime66.jsx)("g", {
    className,
    children: (0, import_jsx_runtime66.jsx)(ChartsText, _extends({
      x: cx,
      y: cy,
      text: formattedText,
      style: {
        textAnchor: "middle",
        dominantBaseline: "central"
      }
    }, other))
  });
}
true ? GaugeValueText.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Height of a text line (in `em`).
   */
  lineHeight: import_prop_types49.default.number,
  /**
   * If `true`, the line width is computed.
   * @default false
   */
  needsComputation: import_prop_types49.default.bool,
  ownerState: import_prop_types49.default.any,
  /**
   * Style applied to text elements.
   */
  style: import_prop_types49.default.object,
  text: import_prop_types49.default.oneOfType([import_prop_types49.default.func, import_prop_types49.default.string])
} : void 0;

// node_modules/@mui/x-charts/Gauge/Gauge.js
var import_jsx_runtime67 = __toESM(require_jsx_runtime());
var _excluded40 = ["text", "children", "classes", "className"];
var useUtilityClasses15 = (props) => {
  const {
    classes
  } = props;
  const slots = {
    root: ["root"],
    valueArc: ["valueArc"],
    referenceArc: ["referenceArc"],
    valueText: ["valueText"]
  };
  return composeClasses(slots, getGaugeUtilityClass, classes);
};
var Gauge = React75.forwardRef(function Gauge2(props, ref) {
  const {
    text,
    children,
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded40);
  const classes = useUtilityClasses15(props);
  return (0, import_jsx_runtime67.jsxs)(GaugeContainer, _extends({}, other, {
    className: clsx_default(classes.root, className),
    ref,
    children: [(0, import_jsx_runtime67.jsx)(GaugeReferenceArc, {
      className: classes.referenceArc
    }), (0, import_jsx_runtime67.jsx)(GaugeValueArc, {
      className: classes.valueArc
    }), (0, import_jsx_runtime67.jsx)(GaugeValueText, {
      className: classes.valueText,
      text
    }), children]
  }));
});
true ? Gauge.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: import_prop_types50.default.node,
  classes: import_prop_types50.default.object,
  className: import_prop_types50.default.string,
  /**
   * The radius applied to arc corners (similar to border radius).
   * Set it to '50%' to get rounded arc.
   * @default 0
   */
  cornerRadius: import_prop_types50.default.oneOfType([import_prop_types50.default.number, import_prop_types50.default.string]),
  /**
   * The x coordinate of the arc center.
   * Can be a number (in px) or a string with a percentage such as '50%'.
   * The '100%' is the width the drawing area.
   */
  cx: import_prop_types50.default.oneOfType([import_prop_types50.default.number, import_prop_types50.default.string]),
  /**
   * The y coordinate of the arc center.
   * Can be a number (in px) or a string with a percentage such as '50%'.
   * The '100%' is the height the drawing area.
   */
  cy: import_prop_types50.default.oneOfType([import_prop_types50.default.number, import_prop_types50.default.string]),
  desc: import_prop_types50.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types50.default.bool,
  /**
   * The end angle (deg).
   * @default 360
   */
  endAngle: import_prop_types50.default.number,
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types50.default.number,
  /**
   * The radius between circle center and the beginning of the arc.
   * Can be a number (in px) or a string with a percentage such as '50%'.
   * The '100%' is the maximal radius that fit into the drawing area.
   * @default '80%'
   */
  innerRadius: import_prop_types50.default.oneOfType([import_prop_types50.default.number, import_prop_types50.default.string]),
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   * Accepts an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   * @default object Depends on the charts type.
   */
  margin: import_prop_types50.default.shape({
    bottom: import_prop_types50.default.number,
    left: import_prop_types50.default.number,
    right: import_prop_types50.default.number,
    top: import_prop_types50.default.number
  }),
  /**
   * The radius between circle center and the end of the arc.
   * Can be a number (in px) or a string with a percentage such as '50%'.
   * The '100%' is the maximal radius that fit into the drawing area.
   * @default '100%'
   */
  outerRadius: import_prop_types50.default.oneOfType([import_prop_types50.default.number, import_prop_types50.default.string]),
  /**
   * The start angle (deg).
   * @default 0
   */
  startAngle: import_prop_types50.default.number,
  sx: import_prop_types50.default.oneOfType([import_prop_types50.default.arrayOf(import_prop_types50.default.oneOfType([import_prop_types50.default.func, import_prop_types50.default.object, import_prop_types50.default.bool])), import_prop_types50.default.func, import_prop_types50.default.object]),
  text: import_prop_types50.default.oneOfType([import_prop_types50.default.func, import_prop_types50.default.string]),
  title: import_prop_types50.default.string,
  /**
   * The value of the gauge.
   * Set to `null` to not display a value.
   */
  value: import_prop_types50.default.number,
  /**
   * The maximal value of the gauge.
   * @default 100
   */
  valueMax: import_prop_types50.default.number,
  /**
   * The minimal value of the gauge.
   * @default 0
   */
  valueMin: import_prop_types50.default.number,
  viewBox: import_prop_types50.default.shape({
    height: import_prop_types50.default.number,
    width: import_prop_types50.default.number,
    x: import_prop_types50.default.number,
    y: import_prop_types50.default.number
  }),
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types50.default.number
} : void 0;
export {
  AnimatedArea,
  AnimatedLine,
  AreaElement,
  AreaElementPath,
  AreaPlot,
  BarChart,
  BarElement,
  BarElementPath,
  BarLabel,
  BarPlot,
  ChartContainer,
  ChartsAxis,
  ChartsAxisHighlight,
  ChartsAxisHighlightPath,
  ChartsAxisTooltipContent,
  ChartsClipPath,
  ChartsGrid,
  ChartsItemTooltipContent,
  ChartsLegend,
  ChartsOnAxisClickHandler,
  ChartsReferenceLine,
  ChartsSurface,
  ChartsText,
  ChartsTooltip,
  ChartsTooltipCell,
  ChartsTooltipMark,
  ChartsTooltipPaper,
  ChartsTooltipRow,
  ChartsTooltipTable,
  ChartsVoronoiHandler,
  ChartsXAxis,
  ChartsYAxis,
  ContinuousColorLegend,
  DEFAULT_MARGINS,
  DEFAULT_X_AXIS_KEY,
  DEFAULT_Y_AXIS_KEY,
  DefaultChartsAxisTooltipContent,
  DefaultChartsItemTooltipContent,
  DefaultChartsLegend,
  Gauge,
  GaugeContainer,
  GaugeReferenceArc,
  GaugeValueArc,
  GaugeValueText,
  HighlightedContext,
  HighlightedProvider,
  LineChart,
  LineElement,
  LineElementPath,
  LineHighlightElement,
  LineHighlightPlot,
  LinePlot,
  MarkElement,
  MarkPlot,
  PieArc,
  PieArcLabel,
  PieArcLabelPlot,
  PieArcPlot,
  PieChart,
  PiePlot,
  PiecewiseColorLegend,
  ResponsiveChartContainer,
  Scatter,
  ScatterChart,
  ScatterPlot,
  SparkLineChart,
  ZAxisContextProvider,
  areaElementClasses,
  axisClasses,
  barElementClasses,
  barLabelClasses,
  blueberryTwilightPalette,
  blueberryTwilightPaletteDark,
  blueberryTwilightPaletteLight,
  chartsAxisHighlightClasses,
  chartsGridClasses,
  chartsTooltipClasses,
  cheerfulFiestaPalette,
  cheerfulFiestaPaletteDark,
  cheerfulFiestaPaletteLight,
  gaugeClasses,
  getAreaElementUtilityClass,
  getAxisHighlightUtilityClass,
  getAxisUtilityClass,
  getBarElementUtilityClass,
  getBarLabelUtilityClass,
  getChartsGridUtilityClass,
  getChartsTooltipUtilityClass,
  getGaugeUtilityClass,
  getHighlightElementUtilityClass,
  getLegendUtilityClass,
  getLineElementUtilityClass,
  getMarkElementUtilityClass,
  getPieArcLabelUtilityClass,
  getPieArcUtilityClass,
  getPieCoordinates,
  getReferenceLineUtilityClass,
  getSeriesToDisplay,
  getValueToPositionMapper,
  isBarSeries,
  isDefaultizedBarSeries,
  legendClasses,
  lineElementClasses,
  lineHighlightElementClasses,
  mangoFusionPalette,
  mangoFusionPaletteDark,
  mangoFusionPaletteLight,
  markElementClasses,
  pieArcClasses,
  pieArcLabelClasses,
  referenceLineClasses,
  useBarSeries as unstable_useBarSeries,
  useLineSeries as unstable_useLineSeries,
  usePieSeries as unstable_usePieSeries,
  useScatterSeries as unstable_useScatterSeries,
  useSeries as unstable_useSeries,
  useAxisTooltip,
  useChartId,
  useDrawingArea,
  useGaugeState,
  useHighlighted,
  useItemHighlighted,
  useItemTooltip,
  useMouseTracker,
  useSvgRef,
  useXAxis,
  useXColorScale,
  useXScale,
  useYAxis,
  useYColorScale,
  useYScale,
  useZColorScale
};
/*! Bundled license information:

@mui/x-charts/index.js:
  (**
   * @mui/x-charts v7.21.0
   *
   * @license MIT
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@mui_x-charts.js.map
